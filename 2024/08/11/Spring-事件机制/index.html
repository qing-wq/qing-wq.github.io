<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="qing-wq">



    <meta name="description" content="Qing's Blog">



<title>Spring Event机制详解 | Qing&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Qing&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/categories">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Qing&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/categories">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Spring Event机制详解</h1>
            
                <div class="post-meta">
                    
                        👨‍🎓Author: <a itemprop="author" rel="author" href="/">qing-wq</a>
                    

                    
                        <span class="post-time">
                        📅Date: <a href="#">八月 11, 2024</a>
                        </span>
                    
                    <br/>
                    
                        <span class="post-category">
                            📚Category:
                            
                                <a href="/categories/Spring%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">Spring体系结构</a>
                            
                        </span>
                    
                    
                    
                        <span class="post-count">
                            📑Words:
                            <a href="">2.3k</a> 
                        </span>
                    
                    
                        <span class="post-count">
                            ⏱️Time:
                            <a href="">9min</a> 
                        </span>
                                            
                </div>
            
        </header>

        <div class="post-content">
            <p>Spring的事件机制提供了一种低耦合、无侵入的解决方式，它由三部分组成：</p>
<ul>
<li><code>ApplicationEventPublisher</code>：发布器，让容器拥有发布应用上下文事件的功能，包括容器启动事件、关闭事件等。</li>
<li><code>ApplicationListener</code>：监听器 ，可以接收到容器事件 ， 并对事件进行响应处理 。</li>
<li><code>ApplicationEventMulticaster</code>：事件多播器，它负责保存所有监听器，以便在容器产生上下文事件时通知这些事件监听者。</li>
<li><code>ApplicationEvent</code>：具体的事件</li>
</ul>
<p><img src="/../images/Spring-%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/image_k6VpJmK7hm.png"></p>
<blockquote>
<p>图片来自：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7140849555607650335#heading-10" title="https://juejin.cn/post/7140849555607650335#heading-10">https://juejin.cn/post/7140849555607650335#heading-10</a></p>
</blockquote>
<h2 id="1-Spring中的内置事件"><a href="#1-Spring中的内置事件" class="headerlink" title="1 Spring中的内置事件"></a>1 Spring中的内置事件</h2><p><img src="/../images/Spring-%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/image_NIowE11gVH.png"></p>
<ul>
<li><code>ContextRefreshedEvent</code>：在<code>refresh()</code>执行完成时触发，通知容器刷新完成。<ul>
<li>很适合我们做一些系统启动后的准备工作，此时我们就可以监听该事件，作为系统启动后初始预热的契机。</li>
</ul>
</li>
<li><code>ContextStartedEvent</code>：<code>ConfigurableApplicationContext</code>的<code>start()</code>执行完成时触发<ul>
<li>该事件的触发是所有的单例bean创建完成后发布，此时实现了<code>Lifecycle</code>接口的bean还没有回调<code>start()</code>，当这些<code>start()</code>被调用后，才会发布<code>ContextStartedEvent</code>事件。</li>
</ul>
</li>
<li><code>ContextClosedEvent</code>：<code>ConfigurableApplicationContext</code>的<code>close()</code>执行完成时触发<ul>
<li>此时IOC容器已经关闭，但尚未销毁所有的bean。</li>
</ul>
</li>
<li><code>ContextStoppedEvent</code>：<code>ConfigurableApplicationContext</code>的<code>stop()</code>执行完成时触发</li>
</ul>
<h2 id="2-自定义事件的使用"><a href="#2-自定义事件的使用" class="headerlink" title="2 自定义事件的使用"></a>2 自定义事件的使用</h2><ul>
<li><p><strong>定义事件</strong></p>
<p>自定义事件在使用上很简单，继承 ApplicationEvent 即可:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplicationEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> {</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyApplicationEvent</span><span class="params">(Long id)</span> {</span><br><span class="line">        <span class="built_in">super</span>(id);</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getId</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>发布自定义事件</strong></p>
<p><code>ApplicationContext</code>继承了<code>ApplicationEventPublisher</code>，因此也拥有消息发布的能力：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">applicationContext.publishEvent(<span class="keyword">new</span> <span class="title class_">MyApplicationEvent</span>(<span class="number">1L</span>));</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>定义监听器</strong></p>
<p>监听器需要实现<code>ApplicationListener</code>接口，<code>onApplicationEvent()</code>负责处理具体的事件</p>
<p>注意：需要通过泛型参数指定处理的事件类型</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyEventListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;MyApplicationEvent&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(MyApplicationEvent event)</span> {</span><br><span class="line">        System.out.println(event.getSource());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="3-ApplicationListener注册过程"><a href="#3-ApplicationListener注册过程" class="headerlink" title="3 ApplicationListener注册过程"></a>3 ApplicationListener注册过程</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException {</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 初始化各种监听器</span></span><br><span class="line">    <span class="built_in">this</span>.registerListeners();</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册监听器</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerListeners</span><span class="params">()</span> {</span><br><span class="line">  <span class="comment">// 1: 处理context.addApplicationListener() 方式注册的监听器，并将监听器注册到广播器中，</span></span><br><span class="line">  <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : <span class="built_in">this</span>.getApplicationListeners()) {</span><br><span class="line">    <span class="built_in">this</span>.getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2: 去Spring容器中获取监听器（处理扫描的或者register方式注册的）,同样也是添加到广播器中</span></span><br><span class="line">  String[] listenerBeanNames = <span class="built_in">this</span>.getBeanNamesForType(ApplicationListener.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) {</span><br><span class="line">    <span class="built_in">this</span>.getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>值得注意的是，IoC容器会扫描继承了<code>ApplicationListener</code>的监听器作为Bean并注册到容器中，但通过<code>@EventListener</code>方式注册的是一个方法，监听者应该是一个实例对象，那它是怎么被识别并注册呢？</p>
<h3 id="3-1-EventListener是如何工作的？"><a href="#3-1-EventListener是如何工作的？" class="headerlink" title="3.1 @EventListener是如何工作的？"></a>3.1 @EventListener是如何工作的？</h3><p>每次面对这种不同的注册方式时，适配器模式就要登场了。<code>@EventListener</code>的扫描和注册过程我觉得也很有参考意义，在此记录一下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException {</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    ..</span><br><span class="line">    <span class="comment">// 普通单例Bean的实例化</span></span><br><span class="line">    <span class="built_in">this</span>.finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> {</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 初始化非延迟加载的单例bean</span></span><br><span class="line">    beanFactory.preInstantiateSingletons();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException {</span><br><span class="line">    List&lt;String&gt; beanNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line">    <span class="comment">// 1: 完成bean的实例化</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) {</span><br><span class="line">        <span class="comment">// 调用BeanFactory尝试获取Bean，获取不到会创建Bean</span></span><br><span class="line">        getBean(beanName);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2: 调用bean的后置处理方法</span></span><br><span class="line">    <span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) {</span><br><span class="line">      <span class="comment">// singletonInstance instanceof SmartInitializingSingleton</span></span><br><span class="line">      smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>这里的<code>smartSingleton.afterSingletonsInstantiated()</code>会触发所有适用 bean 的回调：</p>
<p><img src="/../images/Spring-%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/image_9NiB6Gnaat.png"></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EventListenerMethodProcessor.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterSingletonsInstantiated</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) {</span><br><span class="line">        processBean(beanName, type);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Class&lt;?&gt; targetType)</span> {</span><br><span class="line">    <span class="comment">// 1: 解析bean上加了@EventListener的方法</span></span><br><span class="line">    Map&lt;Method, EventListener&gt; annotatedMethods = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        annotatedMethods = MethodIntrospector.selectMethods(targetType,</span><br><span class="line">                        (MethodIntrospector.MetadataLookup&lt;EventListener&gt;) method -&gt;</span><br><span class="line">        AnnotatedElementUtils.findMergedAnnotation(method, EventListener.class));</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 2: 遍历加了@EventListener的方法，注册为事件监听器</span></span><br><span class="line">    <span class="keyword">for</span> (Method method : annotatedMethods.keySet()) {</span><br><span class="line">        <span class="keyword">for</span> (EventListenerFactory factory : factories) {</span><br><span class="line">            <span class="keyword">if</span> (factory.supportsMethod(method)) {</span><br><span class="line">                <span class="type">Method</span> <span class="variable">methodToUse</span> <span class="operator">=</span> AopUtils.selectInvocableMethod(method, context.getType(beanName));</span><br><span class="line">                <span class="comment">// 2.1 通过EventListenerFactory，将方法创建为监听器实例(ApplicationListenerMethodAdapter)</span></span><br><span class="line">                ApplicationListener&lt;?&gt; applicationListener = factory.createApplicationListener(beanName, targetType, methodToUse);</span><br><span class="line">                <span class="keyword">if</span> (applicationListener <span class="keyword">instanceof</span> ApplicationListenerMethodAdapter) {</span><br><span class="line">                        ((ApplicationListenerMethodAdapter) applicationListener).init(context, <span class="built_in">this</span>.evaluator);</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 2.2 注册为ApplicationListener</span></span><br><span class="line">                context.addApplicationListener(applicationListener);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结一下流程：在容器中所有的bean实例化后，会再次遍历所有bean，调用<code>afterSingletonsInstantiated()</code>的方法，此时符合条件的<code>EventListenerMethodProcessor</code>就会被调用</p>
<p><img src="/../images/Spring-%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/image_qNXImWUpet.png"></p>
<blockquote>
<p>关于@EventListener标注方法的解析时机，笔者首先想到的应该和<code>@Bean</code>的处理时机一致，在扫描类的时候，就解析出来加了<code>@EventListener</code>的方法，抽象为BeanDefinition放到容器中，后面实例化时候，和正常扫描出来的bean是一样的实例化流程。但是查找下来发现Spring并没有这样处理，而是在bean初始化后回调阶段处理的。究其原因，大概是@Bean真的是需要托付给Spring管理，而<code>@EventListener</code>只是一个标识，无需放入放入容器，防止对完暴露所致吧。</p>
</blockquote>
<h2 id="4-Spring如何广播消息？"><a href="#4-Spring如何广播消息？" class="headerlink" title="4 Spring如何广播消息？"></a>4 Spring如何广播消息？</h2><p><code>ApplicationEventMulticaster</code>负责事件的分发，我们可以看一下它的具体实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SimpleApplicationEventMulticaster.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> {</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// getApplicationListeners 获取符合的监听器</span></span><br><span class="line">    <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) {</span><br><span class="line">        <span class="comment">// 执行每个监听器的逻辑</span></span><br><span class="line">         <span class="comment">// 注意，这里是同步的 </span></span><br><span class="line">        invokeListener(listener, event);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// invokeListener最后调用doInvokeListener</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doInvokeListener</span><span class="params">(ApplicationListener listener, ApplicationEvent event)</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      <span class="comment">// 调用监听器的onApplicationEvent方法进行处理</span></span><br><span class="line">      listener.onApplicationEvent(event);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>getApplicationListeners()</code>找到了所有匹配的监听器，我们继续跟踪看一下是如何进行事件匹配的：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Collection&lt;ApplicationListener&lt;?&gt;&gt; getApplicationListeners(</span><br><span class="line">      ApplicationEvent event, ResolvableType eventType) {</span><br><span class="line">   <span class="comment">// 省略缓存相关代码</span></span><br><span class="line">   <span class="keyword">return</span> retrieveApplicationListeners(eventType, sourceType, newRetriever);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Collection&lt;ApplicationListener&lt;?&gt;&gt; retrieveApplicationListeners(</span><br><span class="line">ResolvableType eventType, <span class="meta">@Nullable</span> Class&lt;?&gt; sourceType, <span class="meta">@Nullable</span> CachedListenerRetriever retriever) {</span><br><span class="line">    <span class="comment">// 1: 获取所有的ApplicationListener</span></span><br><span class="line">    Set&lt;ApplicationListener&lt;?&gt;&gt; listeners;</span><br><span class="line">    Set&lt;String&gt; listenerBeans;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.defaultRetriever) {</span><br><span class="line">        listeners = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="built_in">this</span>.defaultRetriever.applicationListeners);</span><br><span class="line">        listenerBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="built_in">this</span>.defaultRetriever.applicationListenerBeans);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : listeners) {</span><br><span class="line">        <span class="comment">// 2: 遍历判断是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> (supportsEvent(listener, eventType, sourceType)) {</span><br><span class="line">            <span class="keyword">if</span> (retriever != <span class="literal">null</span>) {</span><br><span class="line">                filteredListeners.add(listener);</span><br><span class="line">            }</span><br><span class="line">            allListeners.add(listener);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">supportsEvent</span><span class="params">(</span></span><br><span class="line"><span class="params">  ApplicationListener&lt;?&gt; listener, ResolvableType eventType, <span class="meta">@Nullable</span> Class&lt;?&gt; sourceType)</span> {</span><br><span class="line">  <span class="type">GenericApplicationListener</span> <span class="variable">smartListener</span> <span class="operator">=</span> (listener <span class="keyword">instanceof</span> GenericApplicationListener ?</span><br><span class="line">                                              (GenericApplicationListener) listener : <span class="keyword">new</span> <span class="title class_">GenericApplicationListenerAdapter</span>(listener));</span><br><span class="line">  <span class="comment">// supportsEventType 根据ApplicationListener的泛型, 和事件类型,看是否匹配</span></span><br><span class="line">  <span class="comment">// supportsSourceType 根据事件源类型，判断是否匹配</span></span><br><span class="line">  <span class="keyword">return</span> (smartListener.supportsEventType(eventType) &amp;&amp; smartListener.supportsSourceType(sourceType));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上就是<code>ApplicationEventMulticaster</code>分发事件的大致逻辑，本质上就是通过泛型查找到所有匹配的监听器，然后在一个for循环中调用监听器的事件处理方法</p>
<p>但是这里也有一个问题，这种方式事件的处理是同步的，可能会存在发布阻塞的问题，并且有性能问题。有没有办法能够使用异步机制来处理消息呢？</p>
<h2 id="5-异步处理事件"><a href="#5-异步处理事件" class="headerlink" title="5 异步处理事件"></a>5 异步处理事件</h2><p>Spring提供了两种异步处理事件的方式：</p>
<h3 id="5-1-给ApplicationEventMulticaster添加线程池"><a href="#5-1-给ApplicationEventMulticaster添加线程池" class="headerlink" title="5.1 给ApplicationEventMulticaster添加线程池"></a>5.1 给ApplicationEventMulticaster添加线程池</h3><p>通过<code>setTaskExecutor()</code>方法可以给<code>ApplicationEventMulticaster</code>设置线程池，这样的做法是全局生效的：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> {</span><br><span class="line">    <span class="comment">// 获取执行线程池</span></span><br><span class="line">    <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> getTaskExecutor();</span><br><span class="line">    <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) {</span><br><span class="line">        <span class="comment">// 如果存在线程池，使用线程池异步执行</span></span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="literal">null</span>) {</span><br><span class="line">            executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果不存在线程池，同步执行</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            invokeListener(listener, event);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTaskExecutor</span><span class="params">(<span class="meta">@Nullable</span> Executor taskExecutor)</span> {</span><br><span class="line">    <span class="built_in">this</span>.taskExecutor = taskExecutor;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="5-2-使用-Async"><a href="#5-2-使用-Async" class="headerlink" title="5.2 使用@Async"></a>5.2 使用<code>@Async</code></h3><p>还有一种方式是通过给监听者的<code>onApplicationEvent()</code>添加<code>@Async</code>注解使其变成异步的，这种方式只对单个方法生效，使用方式就跟我们平时定义的异步方法一样，这里就不多赘述了</p>
<h2 id="6-全局异常处理"><a href="#6-全局异常处理" class="headerlink" title="6 全局异常处理"></a>6 全局异常处理</h2><p><code>ApplicationEventMulticaster</code>分发事件的时候发生异常怎么办，后面的监听器还能执行吗？</p>
<p>Spring事件的处理，默认是同步依次执行。那如果前面的监听器出现了异常，并且没有处理异常，会对后续的监听器还能顺利接收该事件吗？其实不能的，因为异常中断了事件的发送了</p>
<p>如果设置了异步执行，因为不是一个线程执行，是不会互相影响的。</p>
<p>Spring提供了ErrorHandler来方便我们对消息处理异常进行统一处理：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationEventMulticaster</span> <span class="variable">multicaster</span> <span class="operator">=</span> context.getBean(AbstractApplicationContext.APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line">((SimpleApplicationEventMulticaster) multicaster).setErrorHandler(t -&gt; System.out.println(t));</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h2><p><strong>Spring事件机制存在什么问题？</strong></p>
<p>我认为主要的问题还是公共线程池造成的问题：</p>
<ol>
<li><p><strong>发布阻塞</strong></p>
<p> <strong>监听器的执行速度会互相影响、甚至会发生阻塞</strong>。假如某一个监听器执行的很慢，把线程池中线程都占用了，此时其他的事件虽然发布但没有资源执行，只能在缓存队列等待线程释放<br> 其实这里可以参考Netty的boss-work工作模型，广播器只负责分发事件，调度执行监听器的逻辑交给由具体的work线程负责会更合适。</p>
</li>
<li><p><strong>无法定制监听器执行线程池</strong></p>
<p> 由于每种事件产生的数量、处理逻辑、处理速度差异化可能很大，所以每个监听器都有适合自己场景的线程数，为每个监听器配置单独的线程池尤为重要。Spring事件机制无法单独为监听器设置线程池，只能共用线程池，无法做到精准控制，线程拥堵或者线程浪费出现的几率极大</p>
<p> 虽然我们也可以在接收到事件后使用自定义的线程池处理，但是我们更希望简单化配置就能支持</p>
</li>
</ol>
<hr>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7140849555607650335#heading-14">聊透Spring事件机制</a></li>
</ul>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>qing-wq</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://qing-wq.github.io/2024/08/11/Spring-%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/">https://qing-wq.github.io/2024/08/11/Spring-%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"># Spring源码阅读</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2024/08/25/LangChain4j-Spring-Bug/">🐛开源经历：LangChain4j-Spring Bug修复记录</a>
            
            
            <a class="next" rel="next" href="/2024/07/31/%E6%89%8B%E6%90%93%E4%B8%80%E4%B8%AA%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E5%99%A8/">😎手搓一个动态配置管理器</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© qing-wq | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>