<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Go语言基础</title>
    <url>/2023/09/01/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li><strong>GOPATH</strong>：代表 Go 语言项目的工作目录，在 Go Module 模式之前非常重要，现在基本上用来存放使用 go get 命令获取的项目。</li>
<li><strong>GOBIN</strong>：代表 Go 编译生成的程序的安装目录，比如通过 go install 命令，会把生成的 Go 程序安装到 GOBIN 目录下，以供你在终端使用。</li>
<li>Go代理：<code>GOPROXY=https://goproxy.cn</code></li>
</ul>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> GOROOT=/usr/local/go </span><br><span class="line"><span class="built_in">export</span> GOPATH=<span class="variable">$HOME</span>/MyDoucument/code/goProject</span><br><span class="line"><span class="built_in">export</span> GOBIN=<span class="variable">$GOPATH</span>/bin</span><br><span class="line"><span class="built_in">export</span> GO111MODULE=on</span><br></pre></td></tr></tbody></table></figure>

<h3 id="编译发布"><a href="#编译发布" class="headerlink" title="编译发布"></a>编译发布</h3><p><code>go build</code>编译生成可执行文件</p>
<p><code>go install</code>把它安装到 <code>$GOBIN</code> 目录或者任意位置</p>
<span id="more"></span>

<h3 id="跨平台编译"><a href="#跨平台编译" class="headerlink" title="跨平台编译"></a>跨平台编译</h3><p>Go 语言通过两个环境变量来控制跨平台编译，它们分别是 <code>GOOS</code> 和 <code>GOARCH</code> 。</p>
<ul>
<li><strong>GOOS</strong>：代表要编译的目标操作系统，常见的有 Linux、Windows、Darwin 等。</li>
<li><strong>GOARCH</strong>：代表要编译的目标处理器架构，常见的有 386、AMD64、ARM64 等。</li>
</ul>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">GOOS=linux GOARCH=amd64 go build ./ch01/main.go</span><br></pre></td></tr></tbody></table></figure>

<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><ul>
<li><strong>有符号整型</strong>：如 <code>int</code>、<code>int8</code>、<code>int16</code>、<code>int32</code> 和 <code>int64</code>。</li>
<li><strong>无符号整型</strong>：如 <code>uint</code>、<code>uint8</code>、<code>uint16</code>、<code>uint32</code> 和 <code>uint64</code>。</li>
</ul>
<p>除了有用“位”（bit）大小表示的整型外，还有 int 和 uint 这两个没有具体 bit 大小的整型，它们的大小可能是 32bit，也可能是 64bit，和硬件设备 CPU 有关。</p>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><ul>
<li><code>float32</code> </li>
<li><code>float64</code></li>
</ul>
<h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><ul>
<li><code>complex64</code></li>
<li><code>complex128</code></li>
</ul>
<p>复数有实部和虚部，<code>complex64</code>的实部和虚部为32位，<code>complex128</code>的实部和虚部为64位</p>
<h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p><code>bool</code></p>
<ul>
<li>布尔类型变量的默认值为false。</li>
<li>Go 语言中不允许将整型强制转换为布尔型.</li>
<li>布尔型无法参与数值运算，也无法与其他类型进行转换</li>
</ul>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>*** Go 语言里的字符串的内部实现使用UTF-8编码，每个字符串的底层都是byte数组***​</p>
<ul>
<li><em><strong>byte：相当于uint8</strong></em></li>
<li><em><strong>rune：相当于int32</strong></em><ul>
<li>Go 使用了特殊 <code>rune</code> 类型来处理 <code>Unicode</code>（复合字符，包括中文、日文等用多字节表示字符）</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//utf-8遍历</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str); i++ {</span><br><span class="line">    ch := str[i]</span><br><span class="line">    fmt.Printf(<span class="string">"%c \n"</span>, ch)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//Unicode遍历</span></span><br><span class="line"><span class="keyword">for</span> _, ch1 := <span class="keyword">range</span> str {</span><br><span class="line">    fmt.Printf(<span class="string">"%c \n"</span>, ch1)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="Array、Slice、Map"><a href="#Array、Slice、Map" class="headerlink" title="Array、Slice、Map"></a>Array、Slice、Map</h2><p><img src="/../images/image_hekea8NFLl.png"></p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">array1:=[<span class="number">5</span>]<span class="type">string</span>{<span class="number">1</span>:<span class="string">"b"</span>,<span class="number">3</span>:<span class="string">"d"</span>}</span><br><span class="line"></span><br><span class="line">slice:=array[start:end]</span><br><span class="line"></span><br><span class="line">slice1:=<span class="built_in">make</span>([]<span class="type">string</span>,<span class="number">4</span>,<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">slice2:=<span class="built_in">append</span>(slice1,<span class="string">"f"</span>)</span><br><span class="line"></span><br><span class="line">nameAgeMap:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">nameAgeMap:=<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>{<span class="string">"飞雪无情"</span>:<span class="number">20</span>}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>📌提示</p>
<p>在创建新切片的时候，最好要让新切片的长度和容量一样，这样在追加操作的时候就会生成新的底层数组，从而和原有数组分离，就不会因为共用底层数组导致修改内容的时候影响多个切片。</p>
</blockquote>
<h2 id="函数和方法"><a href="#函数和方法" class="headerlink" title="函数和方法"></a>函数和方法</h2><p>在 Go 语言中，方法和函数是两个概念，但又非常相似，不同点在于方法必须要有一个接收者，这个接收者是一个类型，这样方法就和这个类型绑定在一起，称为这个类型的方法。</p>
<ul>
<li>函数：正常的代码逻辑</li>
<li>方法：特定类型才有，相当于对象的方法</li>
</ul>
<h3 id="值类型接收者和指针类型接收者"><a href="#值类型接收者和指针类型接收者" class="headerlink" title="值类型接收者和指针类型接收者"></a>值类型接收者和指针类型接收者</h3><ul>
<li>值类型接收者：不会改变原来的对象，相当于操作对象的拷贝</li>
<li>指针类型接收者：通过指针可以获取对象地址，可以直接改变原来的对象</li>
</ul>
<blockquote>
<p>提示：在调用方法的时候，传递的接收者本质上都是副本，只不过一个是这个值的副本，一是指向这个值指针的副本。指针具有指向原有值的特性，所以修改了指针指向的值，也就修改了原有的值。<em><strong>我们可以简单地理解为值接收者使用的是值的副本来调用方法，而指针接收者使用实际的值来调用方法。</strong></em></p>
</blockquote>
<blockquote>
<p>📌值接受者方法不会改变原始结构体实例</p>
</blockquote>
<ul>
<li>如果使用一个值类型变量调用指针类型接收者的方法，Go 语言编译器会自动帮我们取指针调用，以满足指针接收者的要求。</li>
<li>同样的原理，如果使用一个指针类型变量调用值类型接收者的方法，Go 语言编译器会自动帮我们解引用调用，以满足值类型接收者的要求。</li>
</ul>
<h3 id="值类型调用者和指针类型调用者"><a href="#值类型调用者和指针类型调用者" class="headerlink" title="值类型调用者和指针类型调用者"></a>值类型调用者和指针类型调用者</h3><p>在官方effective go文档中，对两者区别描述如下：</p>
<ul>
<li><em><strong>值方法（value methods）可以通过指针和值调用，但是指针方法（pointer methods）只能通过指针来调用</strong></em>** <em>。</em>** ​</li>
<li>但有一个例外，如果某个值是可寻址的（addressable，或者说<em>左值</em>），那么编译器会在值调用指针方法时自动插入取地址符，使得在此情形下看起来像指针方法也可以通过值来调用。</li>
</ul>
<hr>
<p>总结：</p>
<ul>
<li>不管是普通对象还是指针，都可以调用他们的值方法和指针方法，因为编译器会自行处理（语法糖</li>
<li><strong>遇事不决请用pointer method！！！</strong></li>
</ul>
<h3 id="通过变量调用方法"><a href="#通过变量调用方法" class="headerlink" title="通过变量调用方法"></a>通过变量调用方法</h3><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">student := Student(<span class="string">"my name is xiaoming, I am "</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法赋值给变量</span></span><br><span class="line">sm := Student.stu</span><br><span class="line">sm2 := (*Student).stu2</span><br><span class="line">sm(student, <span class="number">2</span>)</span><br><span class="line">sm2(&amp;student)</span><br><span class="line">student.stu(<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="结构体和接口"><a href="#结构体和接口" class="headerlink" title="结构体和接口"></a>结构体和接口</h2><p>结构体定义：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">type Stu <span class="class"><span class="keyword">struct</span>{</span></span><br><span class="line">  name <span class="built_in">string</span></span><br><span class="line">  age <span class="type">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名结构体 变量 </span></span><br><span class="line">var stu <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">  name <span class="built_in">string</span></span><br><span class="line">  age <span class="type">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名结构体变量另一种写法</span></span><br><span class="line">newCar := <span class="keyword">struct</span> {</span><br><span class="line">  Make    <span class="built_in">string</span> `json:<span class="string">"make"</span>`</span><br><span class="line">  Model   <span class="built_in">string</span> `json:<span class="string">"model"</span>`</span><br><span class="line">  Mileage <span class="type">int</span>    `json:<span class="string">"mileage"</span>`</span><br><span class="line">}{}</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyStringer interface</span></span><br><span class="line">type MyStringer interface{</span><br><span class="line">  myString() <span class="built_in">string</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><em><strong>以指针类型接收者实现接口的时候，只有对应的指针类型实例才被认为实现了该接口。</strong></em></p>
<p><img src="/../images/Ciqc1F-yPMSAZ4k7AABU_GW4VxE080_J3w0-tF9PU.png"></p>
<h3 id="工厂函数（构造函数）"><a href="#工厂函数（构造函数）" class="headerlink" title="工厂函数（构造函数）"></a>工厂函数（构造函数）</h3><p>工厂函数一般用于创建自定义的结构体，便于使用者调用</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="type">string</span>)</span></span> *person {</span><br><span class="line">    <span class="keyword">return</span> &amp;person{name:name}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="继承和组合"><a href="#继承和组合" class="headerlink" title="继承和组合"></a>继承和组合</h3><p>在 Go 语言中没有继承的概念，所以结构、接口之间也没有父子关系，Go 语言提倡的是组合，利用组合达到代码复用的目的，这也更灵活。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 组合</span></span><br><span class="line">p:=person{</span><br><span class="line">    age:<span class="number">30</span>,</span><br><span class="line">    name:<span class="string">"飞雪无情"</span>,</span><br><span class="line">    address:address{</span><br><span class="line">        province: <span class="string">"北京"</span>,</span><br><span class="line">        city:     <span class="string">"北京"</span>,</span><br><span class="line">    },</span><br><span class="line">}</span><br><span class="line"><span class="comment">//像使用自己的字段一样，直接使用</span></span><br><span class="line">fmt.Println(p.province)</span><br></pre></td></tr></tbody></table></figure>

<p>类型组合后，外部类型不仅可以使用内部类型的字段，也可以使用内部类型的方法，就像使用自己的方法一样。<br><strong>方法覆写</strong>：如果外部类型定义了和内部类型同样的方法，那么外部类型的会覆盖内部类型，这就是。</p>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>类型断言用来判断一个接口的值是否是实现该接口的某个具体类型。</p>
<p>接口引用拥有断言能力，用于判断当前引用是否属于某个对象的实例</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 接口引用指向子类实例</span></span><br><span class="line"><span class="keyword">var</span> myInterface MyInterface = NewTest(<span class="string">"test"</span>, <span class="number">18</span>, <span class="string">"test"</span>)</span><br><span class="line"><span class="comment">// 判断myInterface是否是Test类型</span></span><br><span class="line"><span class="keyword">if</span> _, ok := myInterface.(*Test);!ok {</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">"myInterface 不是 Test实例"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>在类型断言的时候，同时完成了类型转换</strong></p>
<h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><p>在 Go 语言中，错误是通过内置的 error 接口表示的：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// error 定义</span></span><br><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> {</span><br><span class="line">   Error() <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂函数</span></span><br><span class="line">errors.New(<span class="string">"error"</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong>自定义异常</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> commonError <span class="keyword">struct</span> {</span><br><span class="line">  errorCode <span class="type">int</span>    <span class="comment">//错误码</span></span><br><span class="line">  errorMsg  <span class="type">string</span> <span class="comment">//错误信息</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 实现了Error()就是自定义异常 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ce *commonError)</span></span> Error() <span class="type">string</span> {</span><br><span class="line">  <span class="keyword">return</span> ce.errorMsg</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Error-Wrapping"><a href="#Error-Wrapping" class="headerlink" title="Error Wrapping"></a>Error Wrapping</h3><p>上述自定义异常可以满足我们的需求，但是非常烦琐，因为既要定义新的类型还要实现 error 接口。</p>
<p> Go 语言 1.13 版本开始，Go 标准库新增了 Error Wrapping 功能，让我们可以基于一个存在的 error 生成新的 error，并且可以保留原 error 信息。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// wrap</span></span><br><span class="line">e := errors.New(<span class="string">"原始错误e"</span>)</span><br><span class="line">w := fmt.Errorf(<span class="string">"Wrap了一个错误:%w"</span>, e)</span><br><span class="line">fmt.Println(w)   <span class="comment">// wrap了一个错误:原始错误e</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Unwrap</span></span><br><span class="line">fmt.Println(errors.Unwrap(w))   <span class="comment">// 原始错误e</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="errors-Is"><a href="#errors-Is" class="headerlink" title="errors.Is"></a>errors.Is</h3><p>有了 Error Wrapping 后，你会发现原来用的判断两个 error 是不是同一个 error 的方法失效了，比如 Go 语言标准库经常用到的如下代码中的方式：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">fmt.Println(errors.Is(w, e))  <span class="comment">// true</span></span><br><span class="line">fmt.Println(e == os.ErrExist) <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>errors.ls</code></p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Is</span><span class="params">(err, target <span class="type">error</span>)</span></span> <span class="type">bool</span></span><br></pre></td></tr></tbody></table></figure>

<p>以上就是errors.Is 函数的定义，可以解释为：</p>
<ul>
<li>如果 err 和 target 是同一个，那么返回 true。</li>
<li>如果 err 是一个 wrapping error，target 也包含在这个嵌套 error 链中的话，也返回 true。</li>
</ul>
<blockquote>
<p>📌可以简单地概括为，两个 error 相等或 err 包含 target 的情况下返回 true，其余返回 false。</p>
</blockquote>
<h3 id="errors-As"><a href="#errors-As" class="headerlink" title="errors.As"></a>errors.As</h3><p>同样的原因，有了 error 嵌套后，error 断言也不能用了，因为你不知道一个 error 是否被嵌套，又嵌套了几层。所以 Go 语言为解决这个问题提供了 errors.As 函数，比如前面 error 断言的例子，可以使用  errors.As 函数重写，效果是一样的，如下面的代码所示：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cm *commonError</span><br><span class="line"><span class="keyword">if</span> errors.As(err,&amp;cm){</span><br><span class="line">   fmt.Println(<span class="string">"错误代码为:"</span>,cm.errorCode,<span class="string">"，错误信息为："</span>,cm.errorMsg)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">   fmt.Println(sum)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Deferred"><a href="#Deferred" class="headerlink" title="Deferred"></a>Deferred</h3><p>defer 语句常被用于成对的操作，如文件的打开和关闭，加锁和释放锁，连接的建立和断开等。不管多么复杂的操作，都可以保证资源被正确地释放。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(filename <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) {</span><br><span class="line">   f, err := os.Open(filename)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">defer</span> f.Close()</span><br><span class="line">   <span class="comment">//省略无关代码</span></span><br><span class="line">   <span class="keyword">return</span> readAll(f, n)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>在一个方法或者函数中，可以有多个 defer 语句；</li>
<li>defer 有一个调用栈，多个 defer 语句的执行顺序依照<strong>后进先出</strong>的原则。</li>
</ol>
<h3 id="Panic"><a href="#Panic" class="headerlink" title="Panic"></a>Panic</h3><p>Go 语言是一门静态的强类型语言，很多问题都尽可能地在编译时捕获，但是有一些只能在运行时检查，比如数组越界访问、不相同的类型强制转换等，这类运行时的问题会引起 panic 异常。除了运行时可以产生 panic 外，我们自己也可以抛出 panic 异常。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panic</span><span class="params">(v <span class="keyword">interface</span>{})</span></span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p><code>interface{}</code> 是空接口的意思，在 Go 语言中代表任意类型。</p>
</blockquote>
<p>panic 异常是一种非常严重的情况，会让程序中断运行，使程序崩溃，所以<strong>如果是不影响程序运行的错误，不要使用 panic，使用普通错误 error 即可。</strong></p>
<h4 id="Recover-捕获-Panic-异常"><a href="#Recover-捕获-Panic-异常" class="headerlink" title="Recover 捕获 Panic 异常"></a>Recover 捕获 Panic 异常</h4><p>通常情况下，我们不对 panic 异常做任何处理，因为既然它是影响程序运行的异常，就让它直接崩溃即可。但是也的确有一些特例，比如<strong>在程序崩溃前做一些资源释放的处理</strong>，这时候就需要从 panic 异常中恢复，才能完成处理。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connectMySQL</span><span class="params">(ip, username, password <span class="type">string</span>)</span></span> {</span><br><span class="line">  <span class="keyword">if</span> ip == <span class="string">""</span> {</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"ip不能为空"</span>)</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//省略其他代码</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> {</span><br><span class="line">      fmt.Println(p)</span><br><span class="line">    }</span><br><span class="line">  }()</span><br><span class="line">  connectMySQL(<span class="string">""</span>, <span class="string">"root"</span>, <span class="string">"123456"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="并发基础"><a href="#并发基础" class="headerlink" title="并发基础"></a>并发基础</h1><h2 id="协程（Goroutine）"><a href="#协程（Goroutine）" class="headerlink" title="协程（Goroutine）"></a>协程（Goroutine）</h2><p>Go 语言中没有线程的概念，只有协程，也称为 goroutine。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> function()</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">ch:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>接收：获取 chan 中的值，操作符为<code> &lt;- chan</code>。</li>
<li>发送：向 chan 发送值，把值放在 chan 中，操作符为 <code>chan &lt;-</code>。</li>
</ol>
<h3 id="无缓冲-channel"><a href="#无缓冲-channel" class="headerlink" title="无缓冲 channel"></a><strong>无缓冲 channel</strong></h3><p>无缓冲 channel，它的容量是 0，不能存储任何数据。所以无缓冲 channel 只起到传输数据的作用，数据并不会在 channel 中做任何停留。这也意味着，无缓冲 channel 的发送和接收操作是同时进行的，它也可以称为同步 channel。</p>
<h3 id="有缓冲-channel"><a href="#有缓冲-channel" class="headerlink" title="有缓冲 channel"></a>有缓冲 channel</h3><p>有缓冲 channel 类似一个可阻塞的队列，内部的元素<em><strong>先进先出</strong></em>。通过 make 函数的第二个参数可以指定 channel 容量的大小，进而创建一个有缓冲 channel。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">cacheCh:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">5</span>)</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/../images/CgqCHl-7fzmAVLu0AACSjW-neAE188_KyDQkHLLjx.png"></p>
<p>一个有缓冲 channel 具备以下特点：</p>
<ol>
<li>有缓冲 channel 的内部有一个缓冲队列；</li>
<li>发送操作是向队列的尾部插入元素，如果队列已满，则阻塞等待，直到另一个 goroutine 执行，接收操作释放队列的空间；</li>
<li>接收操作是从队列的头部获取元素并把它从队列中删除，如果队列为空，则阻塞等待，直到另一个 goroutine 执行，发送操作插入新的元素。</li>
</ol>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 获取队列容量和元素个数：</span></span><br><span class="line">fmt.Println(<span class="string">"cacheCh容量为:"</span>,<span class="built_in">cap</span>(cacheCh),<span class="string">",元素个数为："</span>,<span class="built_in">len</span>(cacheCh))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭 channel</span></span><br><span class="line"><span class="built_in">close</span>(cacheCh)</span><br></pre></td></tr></tbody></table></figure>

<p>如果一个 channel 被关闭了，就不能向里面发送数据了，如果发送的话，会引起 painc 异常。但是还可以接收 channel 里的数据，如果 channel 里没有数据的话，接收的数据是元素类型的零值。</p>
<h3 id="单向-channel"><a href="#单向-channel" class="headerlink" title="单向 channel"></a>单向 channel</h3><p>有时候，我们有一些特殊的业务需求，比如限制一个 channel 只可以接收但是不能发送，或者限制一个 channel 只能发送但不能接收，这种 channel 称为单向 channel。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">onlySend := <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span><br><span class="line">onlyReceive:=<span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="select-多路复用"><a href="#select-多路复用" class="headerlink" title="select 多路复用"></a>select 多路复用</h3><blockquote>
<p>小提示：多路复用可以简单地理解为，N 个 channel 中，任意一个 channel 有数据产生，select 都可以监听到，然后执行相应的分支，接收数据并处理。</p>
</blockquote>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> {</span><br><span class="line">   <span class="keyword">case</span> i1 = &lt;-c1:</span><br><span class="line">     <span class="comment">//todo</span></span><br><span class="line">   <span class="keyword">case</span> c2 &lt;- i2:</span><br><span class="line">     <span class="comment">//todo</span></span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">     <span class="comment">// default todo</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="sync-包"><a href="#sync-包" class="headerlink" title="sync 包"></a>sync 包</h2><blockquote>
<p>小技巧：使用 go build、go run、go test 这些 Go 语言工具链提供的命令时，添加 <code>-race</code> 标识可以帮你检查 Go 语言代码是否存在资源竞争。</p>
</blockquote>
<h3 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a><strong>sync.Mutex</strong></h3><p>互斥锁，顾名思义，指的是在同一时刻只有一个协程执行某段代码，其他协程都要等待该协程执行完毕后才能继续执行。</p>
<p>Mutex 的 <code>Lock</code> 和 <code>Unlock</code> 方法总是成对出现，而且要确保 Lock 获得锁后，一定执行 UnLock 释放锁</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>(</span><br><span class="line">   sum <span class="type">int</span></span><br><span class="line">   mutex sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(i <span class="type">int</span>)</span></span> {</span><br><span class="line">   mutex.Lock()</span><br><span class="line">   sum += i</span><br><span class="line">   mutex.Unlock()</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>小提示：以上被加锁保护的 sum+=i 代码片段又称为<strong>临界区</strong>。在同步的程序设计中，临界区段指的是一个访问共享资源的程序片段，而这些共享资源又有无法同时被多个协程访问的特性。</p>
</blockquote>
<h3 id="sync-RWMutex"><a href="#sync-RWMutex" class="headerlink" title="sync.RWMutex"></a>sync.RWMutex</h3><p>go中的读写锁。使用：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mutex sync.RWMutex</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readSum</span><span class="params">()</span></span> <span class="type">int</span> {</span><br><span class="line"></span><br><span class="line">   <span class="comment">//只获取读锁</span></span><br><span class="line">   mutex.RLock()</span><br><span class="line">   <span class="keyword">defer</span> mutex.RUnlock()</span><br><span class="line">   b:=sum</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h3><p>相当于Java中的***<code>CountDownLatch</code>** *，用于最终完成的场景，关键点在于一定要等待所有协程都执行完毕。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">   <span class="comment">//因为要监控110个协程，所以设置计数器为110</span></span><br><span class="line">   wg.Add(<span class="number">110</span>)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ {</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">         <span class="comment">//计数器值减1</span></span><br><span class="line">         <span class="keyword">defer</span> wg.Done()</span><br><span class="line">         add(<span class="number">10</span>)</span><br><span class="line">      }()</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>;i++ {</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">         <span class="comment">//计数器值减1</span></span><br><span class="line">         <span class="keyword">defer</span> wg.Done()</span><br><span class="line">         fmt.Println(<span class="string">"和为:"</span>,readSum())</span><br><span class="line">      }()</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">//一直等待，直到计数器值为0</span></span><br><span class="line">   wg.Wait()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h3><p>让代码只执行一次，哪怕是在高并发的情况下，比如创建一个单例。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">   doOnce()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doOnce</span><span class="params">()</span></span> {</span><br><span class="line">   <span class="keyword">var</span> once sync.Once</span><br><span class="line">   onceBody := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">      fmt.Println(<span class="string">"Only once"</span>)</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">//用于等待协程执行完毕</span></span><br><span class="line">   done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//启动10个协程执行once.Do(onceBody)</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">         <span class="comment">//把要执行的函数(方法)作为参数传给once.Do方法即可</span></span><br><span class="line">         once.Do(onceBody)</span><br><span class="line">         done &lt;- <span class="literal">true</span></span><br><span class="line">      }()</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">      &lt;-done</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="sync-Cond"><a href="#sync-Cond" class="headerlink" title="sync.Cond"></a>sync.Cond</h3><p>sync.Cond 可以用于发号施令，一声令下所有协程都可以开始执行，关键点在于协程开始的时候是等待的，要等待 sync.Cond 唤醒才能执行。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//10个人赛跑，1个裁判发号施令</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">race</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">   cond :=sync.NewCond(&amp;sync.Mutex{})</span><br><span class="line">   <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">   wg.Add(<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>; i++ {</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(num <span class="type">int</span>)</span></span> {</span><br><span class="line">         <span class="keyword">defer</span>  wg.Done()</span><br><span class="line">         fmt.Println(num,<span class="string">"号已经就位"</span>)</span><br><span class="line">         cond.L.Lock()</span><br><span class="line">         cond.Wait()<span class="comment">//等待发令枪响</span></span><br><span class="line">         fmt.Println(num,<span class="string">"号开始跑……"</span>)</span><br><span class="line">         cond.L.Unlock()</span><br><span class="line">      }(i)</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">//等待所有goroutine都进入wait状态</span></span><br><span class="line">   time.Sleep(<span class="number">2</span>*time.Second)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">      <span class="keyword">defer</span>  wg.Done()</span><br><span class="line">      fmt.Println(<span class="string">"裁判已经就位，准备发令枪"</span>)</span><br><span class="line">      fmt.Println(<span class="string">"比赛开始，大家准备跑"</span>)</span><br><span class="line">      cond.Broadcast()<span class="comment">//发令枪响</span></span><br><span class="line">   }()</span><br><span class="line">   <span class="comment">//防止函数提前返回退出</span></span><br><span class="line">   wg.Wait()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><strong>Wait</strong>，阻塞当前协程，直到被其他协程调用 Broadcast 或者 Signal 方法唤醒，使用的时候需要加锁，使用 sync.Cond 中的锁即可，也就是 L 字段。</li>
<li><strong>Signal</strong>，唤醒一个等待时间最长的协程。</li>
<li><strong>Broadcast</strong>，唤醒所有等待的协程。</li>
</ol>
<blockquote>
<p>注意：在调用 Signal 或者 Broadcast 之前，要确保目标协程处于 Wait 阻塞状态，不然会出现死锁问题。</p>
</blockquote>
<p>如果你以前学过 Java，会发现 sync.Cond 和 Java 的等待唤醒机制很像，它的三个方法 Wait、Signal、Broadcast 就分别对应 Java 中的 wait、notify、notifyAll。</p>
<h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><blockquote>
<p>一个任务会有很多个协程协作完成，一次 HTTP 请求也会触发很多个协程的启动，而这些协程有可能会启动更多的子协程，并且无法预知有多少层协程、每一层有多少个协程。</p>
<p>如果因为某些原因导致任务终止了，HTTP 请求取消了，那么它们启动的协程怎么办？该如何取消呢？因为取消这些协程可以节约内存，提升性能，同时避免不可预料的 Bug。</p>
<p>Context 就是用来简化解决这些问题的，并且是并发安全的。Context 是一个接口，它具备手动、定时、超时发出取消信号、传值等功能，主要用于控制多个协程之间的协作，尤其是取消操作。一旦取消指令下达，那么被 Context 跟踪的这些协程都会收到取消信号，就可以做清理和退出操作。</p>
</blockquote>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> {</span><br><span class="line"></span><br><span class="line">   Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">   Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{}</span><br><span class="line">   Err() <span class="type">error</span></span><br><span class="line">   Value(key <span class="keyword">interface</span>{}) <span class="keyword">interface</span>{}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Context-树"><a href="#Context-树" class="headerlink" title="Context 树"></a>Context 树</h3><p>Go 语言提供了函数可以帮助我们生成不同的 Context，通过这些函数可以生成一颗 Context 树，这样 Context 才可以关联起来，父 Context 发出取消信号的时候，子 Context 也会发出，这样就可以控制不同层级的协程退出。</p>
<p>从使用功能上分，有四种实现好的 Context。</p>
<ol>
<li><strong>空 Context</strong>：不可取消，没有截止时间，主要用于 Context 树的根节点。</li>
<li><strong>可取消的 Context</strong>：用于发出取消信号，当取消的时候，它的子 Context 也会取消。</li>
<li><strong>可定时取消的 Context</strong>：多了一个定时的功能。</li>
<li><strong>值 Context</strong>：用于存储一个 key-value 键值对。</li>
</ol>
<p><img src="/../images/CgqCHl_EyHOARbBqAAKzKmhclWo807_A5KZtclRKo.png"></p>
<p><code> context.Background()</code>获取一个根节点 Context。</p>
<hr>
<p> Context 树要怎么生成呢？</p>
<ol>
<li>**<code>WithCancel(parent Context)</code>**：生成一个可取消的 Context。<ol>
<li>**<code>WithDeadline(parent Context, d time.Time)</code>**：生成一个可定时取消的 Context，参数 d 为定时取消的具体时间。<ol>
<li>**<code>WithTimeout(parent Context, timeout time.Duration)</code>**：生成一个可超时取消的 Context，参数 timeout 用于设置多久后取消</li>
</ol>
</li>
</ol>
</li>
<li>**<code>WithValue(parent Context, key, val interface{})</code>**：生成一个可携带 key-value 键值对的 Context。</li>
</ol>
<p>以上四个生成 Context 的函数中，前三个都属于可取消的 Context，它们是一类函数，最后一个是值 Context，用于存储一个 key-value 键值对。</p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    name:=<span class="string">"xiaoming"</span></span><br><span class="line">    <span class="keyword">var</span> nameP *<span class="type">string</span> = &amp;name</span><br><span class="line">    fmt.Println(*nameP)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>获取一个变量的指针非常容易，使用取地址符 &amp; 就可以</p>
</li>
<li><p>指针类型就是在对应的类型前加 * 号</p>
</li>
<li><p>指针类型非常廉价，只占用 4 个或者 8 个字节的内存大小。</p>
</li>
<li><p><em><strong>通过 var 声明的指针变量还没有分配内存</strong></em>，因为这时候它仅仅是个变量，是不能直接赋值和取值的，它的值是 nil </p>
<p><img src="/../images/image_t8e3mEYUbE.png" alt="直接赋值和取值" title="直接赋值和取值"></p>
<p>解决方法：将一块内存地址<code>&amp;m</code>赋值给指针变量<code>*p</code></p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> m <span class="type">int</span></span><br><span class="line">p = &amp;m</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>通过new创建的指针是存在内存地址的，可以直接赋值</p>
<ul>
<li><code>var intP *int = new(int)</code></li>
</ul>
</li>
</ul>
<h1 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h1><p><strong>严格来说，Go 语言没有引用类型</strong>，但是我们可以把 map、chan 称为引用类型，这样便于理解。除了 map、chan 之外，Go 语言中的函数、接口、slice 切片、指针都可以称为引用类型。</p>
<p><img src="/../images/image_trx0_Qi29q.png"></p>
<p>总结：</p>
<p>在 Go 语言中，<strong>函数的参数传递只有值传递</strong>，而且传递的实参都是原始数据的一份拷贝。</p>
<p>如果拷贝的内容是值类型的，那么在函数中就无法修改原始数据；</p>
<p>如果拷贝的内容是指针（或者可以理解为引用类型 map、chan 等），那么就可以在函数中修改原始数据。</p>
<h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1><ul>
<li>指针类型的变量如果没有分配内存，就默认是零值 nil，它没有指向的内存，所以无法使用，强行使用就会得到以上 nil 指针错误</li>
<li>对于值类型来说，即使只声明一个变量，没有对其初始化，该变量也会有分配好的内存。</li>
<li>两个关键函数：new和make</li>
</ul>
<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>new 函数只用于分配内存，并且把内存清零，也就是返回一个指向对应类型零值的指针。new 函数一般用于需要显式地返回指针的情况，不是太常用。</p>
<h2 id="make"><a href="#make" class="headerlink" title="make"></a>make</h2><p>make 函数只用于 slice、chan 和 map 这三种内置类型的创建和初始化，因为这三种类型的结构比较复杂，比如 slice 要提前初始化好内部元素的类型，slice 的长度和容量等，这样才可以更好地使用它们。</p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><ul>
<li><p><strong><code>reflect.Value</code></strong> 和**<code>reflect.Type</code>**</p>
<p>在 Go 语言的反射定义中，任何接口都由两部分组成：接口的具体类型，以及具体类型对应的值。比如 var i int = 3，因为 <code>interface{}</code> 可以表示任何类型，所以变量 i 可以转为 interface{}。其中 Value 为变量的值，即 3，而 Type 为变量的类型，即 int。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">i:=<span class="number">3</span></span><br><span class="line">iv:=reflect.ValueOf(i)</span><br><span class="line">it:=reflect.TypeOf(i)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>修改变量</p>
<p>要修改一个变量的值，有几个关键点：传递指针（可寻址），通过 Elem 方法获取指向的值，才可以保证值可以被修改，reflect.Value 为我们提供了 CanSet 方法判断是否可以修改该变量。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">ipv := reflect.ValueOf(&amp;i)</span><br><span class="line">ipv.Elem().SetInt(<span class="number">4</span>)</span><br><span class="line">fmt.Println(i)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>反射的三大定律</p>
<ol>
<li>任何接口值 <code>interface{}</code> 都可以反射出反射对象，也就是 reflect.Value 和 reflect.Type，通过函数 reflect.ValueOf 和 reflect.TypeOf 获得。</li>
<li>反射对象也可以还原为 interface{} 变量，也就是第 1 条定律的可逆性，通过 reflect.Value 结构体的 Interface 方法获得。</li>
<li>要修改反射的对象，该值必须可设置，也就是可寻址，参考上节课修改变量的值那一节的内容理解。</li>
</ol>
</li>
</ul>
<h1 id="SliceHeader"><a href="#SliceHeader" class="headerlink" title="SliceHeader"></a>SliceHeader</h1><ul>
<li><p>在 Go 语言中，切片其实是一个结构体，定义如下：</p>
<p><img src="/../images/image_X_Cyk8TKPo.png"></p>
<p>SliceHeader 是切片在运行时的表现形式，它有三个字段 Data、Len 和 Cap。</p>
<ol>
<li>Data 用来指向存储切片元素的数组。</li>
<li>Len 代表切片的长度。</li>
<li>Cap 代表切片的容量。</li>
</ol>
</li>
<li><p>优点</p>
<ol>
<li>支持动态扩容</li>
<li>切片的本质是 SliceHeader，又因为函数的参数是值传递，所以传递的是 SliceHeader 的副本，而不是底层数组的副本。这时候切片的优势就体现出来了，因为 SliceHeader 的副本内存占用非常少，即使是一个非常大的切片，也顶多占用 24 个字节的内存，这就解决了大数组在传参时内存浪费的问题。</li>
</ol>
</li>
</ul>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ul>
<li>测试文件以_test.go结尾</li>
<li>测试函数以Testxxx（xxx为测试函数名）开头</li>
</ul>
<p>假设编写的函数在<em>ch18/main.go</em>中：<code>go test -v ./ch18</code></p>
<hr>
<ul>
<li>go test -v –coverprofile=ch18.cover ./ch18：得到一个单元测试覆盖率文件</li>
</ul>
<h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h2><p>衡量代码的性能</p>
<ul>
<li><p>函数必须以 Benchmark 开头</p>
</li>
<li><p>函数的签名必须接收一个指向 testing.B 类型的指针，并且不能返回任何值；</p>
</li>
<li><p>最后的 for 循环很重要，被测试的代码要放到循环里；</p>
</li>
<li><p>b.N 是基准测试框架提供的，表示循环的次数，因为需要反复调用测试的代码，才可以评估性能。</p>
</li>
<li><p>运行：<code>go test -bench=. ./ch18</code></p>
<p><img src="/../images/image_JlVijZWatR.png"></p>
</li>
<li><p>计时方法</p>
<p><img src="/../images/image_01f3cRZXVK.png"></p>
</li>
<li><p>内存统计</p>
<p><img src="/../images/image_0VABPfND_h.png"></p>
</li>
<li><p>并发基准测试</p>
<p><img src="/../images/image_KLlXB9vavX.png"></p>
</li>
</ul>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>Go的泛型使用<code>interface</code>实现</p>
<ul>
<li>an approximation element <code>~T</code> restricts to all types whose underlying type is T: 代表底层类型是<code>T</code></li>
<li>a union element <code>T1 | T2 | ...</code> restricts to any of the listed elements: 代表<code>或</code>,类型列表之一。</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 任意类型 any</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span>[<span class="title">T1</span>, <span class="title">T2</span> <span class="title">any</span>]<span class="params">(x <span class="type">int</span>, y T1)</span></span> T2 {</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Integer <span class="keyword">interface</span> {</span><br><span class="line">  Signed | Unsigned</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Signed <span class="keyword">interface</span> {</span><br><span class="line">  ~<span class="type">int</span> | ~<span class="type">int8</span> | ~<span class="type">int16</span> | ~<span class="type">int32</span> | ~<span class="type">int64</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Unsigned <span class="keyword">interface</span> {</span><br><span class="line">  ~<span class="type">uint</span> | ~<span class="type">uint8</span> | ~<span class="type">uint16</span> | ~<span class="type">uint32</span> | ~<span class="type">uint64</span> | ~<span class="type">uintptr</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型抽象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span>[<span class="title">T</span> <span class="title">Integer</span>]<span class="params">(input T)</span></span> T {</span><br><span class="line">  <span class="keyword">if</span> input &lt; <span class="number">0</span> {</span><br><span class="line">    <span class="keyword">return</span> -input</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> input</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>📌 Bean的生命周期</title>
    <url>/2024/03/31/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p><img src="/../images/bean.svg"></p>
<p><em><strong><u>大致过程：实例化→属性注入→初始化→销毁</u></strong></em></p>
<h1 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h1><ol>
<li>Spring扫描所有的Bean（通过xml配置文件或者注解）得到BeanDefinition</li>
<li>根据得到的BeanDefinition去生成bean<ol>
<li>首先根据class推断构造方法</li>
<li>根据推断出来的构造方法，反射，得到一个对象（暂时叫做<strong>原始对象</strong>）</li>
</ol>
</li>
</ol>
<blockquote>
<p>总结：扫描Bean，获取构造方法并生成原始对象，分配内存空间</p>
</blockquote>
<h1 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h1><p>填充原始对象中的属性（即依赖注入）</p>
<span id="more"></span>

<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><ol>
<li><p><strong>实现了<code>ApplicationContextAware</code>接口</strong>  </p>
<p> 使用ApplicationContext来生成并管理Bean的话，才有此步；否则，没有。  </p>
<p> 如果这个Bean已经实现了ApplicationContextAware接口，会调用<code>setApplicationContext()</code>方法，传入Spring上下文（同样这个方式也可以实现上一步的内容，但比上一步更好，因为ApplicationContext是BeanFactory的子接口，有更多的实现方法）；</p>
</li>
<li><p><strong><code>BeanPostProcessors</code>的<code>ProcessBeforeInitialization()</code></strong></p>
<p> 如果有BeanPostProcessors和Bean关联，那么其<code>postProcessBeforeInitialization()</code>方法将被将被调用。</p>
</li>
<li><p><strong><code>@PostConstruct</code></strong></p>
<p> 这里插入一个不属于Spring的生命周期，但是实际项目中会经常用到的方法。它在执行依赖项注入后被执行，即<strong>构造函数之后，<code>init()</code>方法之前执行</strong></p>
</li>
<li><p><strong><code>initializingBean</code>的<code>afterPropertiesSet()</code></strong></p>
<p> 如果Bean类已实现InitializingBean接口，则执行他的<code>afterProPertiesSet()</code>方法。</p>
</li>
<li><p>Bean的<code>init-method</code>  </p>
</li>
<li><p><strong><code>BeanPostProcessors</code>的<code>ProcessaAfterInitialization()</code></strong></p>
<p> 容器中如果有实现BeanPostProcessors接口的实例，则Bean在初始化之前都会执行这个实例的<code>processAfterInitialization()</code>方法。</p>
</li>
<li><p>如果原始对象中的某个方法被AOP了，那么则需要根据原始对象生成一个代理对象</p>
</li>
<li><p>把最终生成的代理对象放入单例池（源码中叫做<code>singletonObjects</code>）中，下次getBean时就直接从单例池拿即可</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>JMM</title>
    <url>/2023/06/03/JMM/</url>
    <content><![CDATA[<p>JMM 实际上是 Java 定义的并发编程相关的一组规范</p>
<h3 id="JMM-是如何抽象线程和主内存之间的关系？"><a href="#JMM-是如何抽象线程和主内存之间的关系？" class="headerlink" title="JMM 是如何抽象线程和主内存之间的关系？"></a>JMM 是如何抽象线程和主内存之间的关系？</h3><p><img src="/../images/image.png" alt="img"></p>
<p><strong>什么是主内存？什么是本地内存？</strong></p>
<ul>
<li><strong>主内存</strong>：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量，还是局部变量，类信息、常量、静态变量都是放在主内存中。为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中。</li>
<li><strong>本地内存</strong>：每个线程都有一个私有的本地内存，本地内存存储了该线程以读 / 写共享变量的副本。每个线程只能操作自己本地内存中的变量，无法直接访问其他线程的本地内存。如果线程间需要通信，必须通过主内存来进行。本地内存是 JMM 抽象出来的一个概念，并不真实存在，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</li>
</ul>
<p><strong>关于JMM的一些同步的约定：</strong></p>
<p>1、线程解锁前，必须把共享变量<strong>立刻</strong>刷回主存；</p>
<p>2、线程加锁前，必须<strong>读取主存</strong>中的最新值到工作内存中；</p>
<span id="more"></span>

<h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>内存交互操作有8种，虚拟机实现必须保证每一个操作都是<strong>原子的</strong>，不可在分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许例外）</p>
<ul>
<li><strong>Read（读取）</strong>：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用；</li>
<li><strong>load（载入）</strong>：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中；</li>
<li><strong>Use（使用）</strong>：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令；</li>
<li><strong>assign（赋值）</strong>：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中；</li>
<li><strong>store（存储）</strong>：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用；</li>
<li><strong>write（写入）</strong>：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中；</li>
<li><strong>lock（锁定）</strong>：作用于主内存的变量，把一个变量标识为线程独占状态；</li>
<li><strong>unlock（解锁）</strong>：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定；</li>
</ul>
<p>即**<code>读-&gt;加载-&gt;使用-&gt;赋值（assign）-&gt;写-&gt;存储</code>**</p>
<p><strong>JMM对这八种指令的使用，制定了如下规则：</strong></p>
<ul>
<li><p>不允许read和load、store和write操作之一单独出现，必须成对使用。即使用了read必须load，使用了store必须write</p>
</li>
<li><p>不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存</p>
</li>
<li><p>不允许一个线程将没有assign的数据从工作内存同步回主内存  </p>
</li>
<li><p>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作</p>
</li>
<li><p>一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁</p>
</li>
<li><p>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值</p>
</li>
<li><p>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量对一个变量进行unlock操作之前，必须把此变量同步回主内存</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>JUC基础</title>
    <url>/2023/09/03/JUC%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>线程的生命周期分为五种状态：</p>
<ul>
<li>新生 <code>NEW</code></li>
<li>运行 <code>RUNNABLE</code></li>
<li>阻塞 <code>BLOCKED</code></li>
<li>等待 <code>WAITING</code></li>
<li>超时等待<code>TIME_WAITING</code></li>
<li>终止 <code>TERMINATED</code></li>
</ul>
<p>在操作系统层面，线程有 READY 和 RUNNING 状态；而在 JVM 层面，只能看到 RUNNABLE 状态</p>
<span id="more"></span>

<p><strong>为什么 JVM 没有区分这两种状态呢？</strong> </p>
<p> 现在的时分多任务操作系统架构通常都是用所谓的“时间分片”方式进行抢占式轮转调度。这个时间分片通常是很小的，一个线程一次最多只能在 CPU 上运行比如 10-20ms 的时间（此时处于 running 状态），也即大概只有 0.01 秒这一量级，时间片用后就要被切换下来放入调度队列的末尾等待再次调度。（也即回到 ready 状态）。<em>线程切换的如此之快，区分这两种状态就没什么意义了。</em></p>
<h2 id="wait-sleep"><a href="#wait-sleep" class="headerlink" title="wait/sleep"></a>wait/sleep</h2><p><strong>区别</strong>：</p>
<ul>
<li><p><strong><code>sleep()</code></strong>** 方法没有释放锁，而 <strong><strong><code>wait()</code></strong></strong> 方法释放了锁** 。这是因为<code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，不会操作对象锁，而<code>wait()</code> 则是 <code>Object</code> 类的本地方法，让获得对象锁的线程实现等待</p>
</li>
<li><p><code>wait()</code> 方法被调用后，<em>线程不会自动苏醒</em>，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</p>
</li>
</ul>
<p>因此，<code>wait()</code> 通常被用于线程间交互/通信，<code>sleep()</code>通常被用于暂停当前线程的执行。</p>
<p><strong>为什么 wait() 方法不定义在 Thread 中？</strong></p>
<p><code>wait()</code> 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入等待状态，自然是要操作对应的对象而非当前的线程。</p>
<h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><p><strong>公平锁：</strong> 十分公平，必须先来后到；</p>
<p><strong>非公平锁：</strong> 十分不公平，可以插队；**(默认)**</p>
<h2 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h2><p>lock三部曲</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1.</span> Lock lock=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> lock.lock() 加锁</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> <span class="keyword">finally</span>=&gt; 解锁：lock.unlock();</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Synchronized锁-与Lock锁-的区别"><a href="#Synchronized锁-与Lock锁-的区别" class="headerlink" title="Synchronized锁 与Lock锁 的区别"></a>Synchronized锁 与Lock锁 的区别</h2><ul>
<li>Synchronized 无法判断获取<strong>锁的状态</strong>，Lock可以判断</li>
<li>Synchronized 会<strong>自动释放锁</strong>，lock必须要手动加锁和手动释放锁！可能会遇到死锁</li>
<li>Synchronized 线程1(获得锁-&gt;阻塞)、线程2(等待)；lock就不一定会一直等待下去，lock会有一个<strong>trylock</strong>去尝试获取锁，不会造成长久的等待。</li>
<li>Synchronized <strong>是可重入锁</strong>，不可以中断的，<strong>非公平的</strong>；Lock是可重入的，可以判断锁，可以自己设置公平锁和非公平锁；</li>
<li>Synchronized 适合锁少量的代码同步问题，Lock适合锁大量的同步代码；</li>
</ul>
<h2 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h2><p>实现类：<code>FutureTask</code>，可以获取到线程执行完毕的结果</p>
<p><code>Callable</code>与<code>Runable</code>的区别：</p>
<ul>
<li><code>Callable</code>可以有返回值</li>
<li><code>Callable</code>可以抛出异常，而<code>Runnable</code>不能抛出被检查的异常</li>
<li>启动方法不同</li>
</ul>
<h2 id="线程安全类集合"><a href="#线程安全类集合" class="headerlink" title="线程安全类集合"></a>线程安全类集合</h2><h3 id="List类"><a href="#List类" class="headerlink" title="List类"></a>List类</h3><ul>
<li><p><code>Vector</code></p>
</li>
<li><p><code>Collections.synchronizedList()</code></p>
</li>
<li><p><code>CopyOnWriteArrayList</code></p>
<p>  适用于读多写少的场景</p>
<p>  核心思想是：如果有多个调用者同时要求相同的资源，他们会共同获取相同的指针指向相同的资源，直到某个调用者视图修改资源内容时，系统才会真正复制一份专用副本给该调用者，而其他调用者所见到的最初的资源仍然保持不变。</p>
<p>  读的时候不需要加锁，如果读的时候有多个线程正在向CopyOnWriteArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的CopyOnWriteArrayList。</p>
</li>
</ul>
<p>**<code>CopyOnWriteArrayList</code><strong>比</strong><code>Vector</code>**区别？</p>
<ul>
<li>**<code>Vector</code><strong>底层是使用</strong><code>synchronized</code>**关键字来实现的，效率低下</li>
<li>**<code>CopyOnWriteArrayList</code>**使用的是Lock锁，更加高效</li>
</ul>
<h3 id="Set类"><a href="#Set类" class="headerlink" title="Set类"></a>Set类</h3><ul>
<li><code>Collections.synchronizedSet()</code></li>
<li><code>CopyOnWriteArraySet</code></li>
</ul>
<h3 id="Map类"><a href="#Map类" class="headerlink" title="Map类"></a>Map类</h3><ul>
<li><code>Collections.synchronizedMap()</code></li>
<li><code>ConcurrentHashMap</code></li>
<li><code>HashTable</code></li>
</ul>
<h1 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h1><h2 id="生产者和消费者问题"><a href="#生产者和消费者问题" class="headerlink" title="生产者和消费者问题"></a>生产者和消费者问题</h2><p>这是一个经典的线程通信问题。两组线程共享一个缓冲区。生产者将数据放入缓冲区，消费者将数据从缓冲区取出</p>
<p>demo如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProviderConsumer</span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span>  <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断等待、业务、通知</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        }</span><br><span class="line">        num++;</span><br><span class="line">       System.out.println(Thread.currentThread().getName() + <span class="string">" increment num "</span> + num);</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        }</span><br><span class="line">        num--;</span><br><span class="line">       System.out.println(Thread.currentThread().getName() + <span class="string">" decrement num "</span> + num);</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ProviderConsumer</span> <span class="variable">providerConsumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProviderConsumer</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    providerConsumer.increment();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    providerConsumer.decrement();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"B"</span>).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong>虚假唤醒问题</strong></p>
<blockquote>
<p>当一定的条件触发时会唤醒很多在阻塞态的线程，但只有部分的线程唤醒是有用的，其余线程的唤醒是多余的。  </p>
</blockquote>
<p>  <a href="https://blog.csdn.net/weixin_45668482/article/details/117373700?ydreferer=aHR0cHM6Ly9jbi5iaW5nLmNvbS8=">https://blog.csdn.net/weixin_45668482/article/details/117373700?ydreferer=aHR0cHM6Ly9jbi5iaW5nLmNvbS8%3D</a></p>
<p>解决虚假唤醒问题：应该将唤醒放在循环中，不满足条件需要继续等待</p>
<p>换句话说：将if替换成while。当使用<code>notifyAll()</code>时，所有的线程都将被唤醒，如果使用的是if，不会再次进行条件判断，因此被唤醒的可能是消费者，也可能是生产者。而使用while的时候，会再次进行等待判断，从而避免虚假唤醒问题。</p>
<h3 id="Lock-Condition实现"><a href="#Lock-Condition实现" class="headerlink" title="Lock + Condition实现"></a>Lock + Condition实现</h3><p>Lock锁的Condition可以精准通知唤醒的线程，从而<strong>控制多个线程的执行顺序</strong></p>
<p>demo：多个线程轮流输出A B C</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestCondition</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition3</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 1A 2B 3C</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printA</span><span class="params">()</span> {</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 业务代码 判断 -&gt; 执行 -&gt; 通知</span></span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">1</span>) {</span><br><span class="line">                condition1.await();</span><br><span class="line">            }</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"==&gt; AAAA"</span> );</span><br><span class="line">            num = <span class="number">2</span>;</span><br><span class="line">            condition2.signal();</span><br><span class="line">        }<span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printB</span><span class="params">()</span> {</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">2</span>) {</span><br><span class="line">                condition2.await();</span><br><span class="line">            }</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"==&gt; BBBB"</span> );</span><br><span class="line">            num = <span class="number">3</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        }<span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printC</span><span class="params">()</span> {</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">3</span>) {</span><br><span class="line">                condition3.await();</span><br><span class="line">            }</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"==&gt; CCCC"</span> );</span><br><span class="line">            num = <span class="number">1</span>;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        }<span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h3 id="BlockingQueue实现生产者消费者问题"><a href="#BlockingQueue实现生产者消费者问题" class="headerlink" title="BlockingQueue实现生产者消费者问题"></a>BlockingQueue实现生产者消费者问题</h3><p>BlockingQueue是Java自带的阻塞队列，内部的原理也是使用了ReentrantLock + Condition实现</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    BlockingQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">producer</span> <span class="operator">=</span> () -&gt; {</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                queue.put(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(producer).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(producer).start();</span><br><span class="line">    </span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">consumer</span> <span class="operator">=</span> () -&gt; {</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                queue.take();</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(consumer).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(consumer).start();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="Java中的线程协作"><a href="#Java中的线程协作" class="headerlink" title="Java中的线程协作"></a>Java中的线程协作</h1><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>倒计数锁存器，可以用作一个<strong>简单的开/关锁存器，或者门</strong>：所有线程调用<code>await()</code>在门口等待，直到被调用<code>countDown()</code>的线程打开。</p>
<p>CountDownLatch一个有用的属性是，它不要求调用countDown线程等待计数到达零之前相互等待，它只是阻止任何线程通过await，直到所有线程可以通过。</p>
<p>常用方法：</p>
<ul>
<li>**<code>countDown()</code>**减一操作；</li>
<li><strong><code>await()</code></strong> 等待计数器归零</li>
</ul>
<h3 id="CyclickBarrier"><a href="#CyclickBarrier" class="headerlink" title="CyclickBarrier"></a>CyclickBarrier</h3><p>循环屏障，它允许一组线程全部等待彼此达到共同屏障点的同步辅助。循环阻塞在涉及固定大小的线程方的程序中很有用，这些线程必须偶尔等待彼此。屏障被称为循环，因为它可以在等待的线程被释放之后重新使用。</p>
<p>常用方法包括：</p>
<ul>
<li><strong><code>await()</code></strong>: 调用该方法的线程到达屏障点，并等待其他线程到达。如果是最后一个到达的线程，将执行可选的任务。</li>
<li><code>await(long timeout, TimeUnit unit)</code>: 调用该方法的线程到达屏障点，并等待其他线程到达，但最多等待指定的时间。</li>
<li><code>getParties()</code>: 返回需要到达屏障点的总线程数。</li>
<li><code>isBroken()</code>: 检查屏障是否被破坏（是否有线程等待超时）。</li>
</ul>
<p>**<code>CyclicBarrier </code>****与 ****<code>CountDownLatch </code>**<strong>区别</strong></p>
<ul>
<li><code>CountDownLatch</code>是一次性的，<code>CyclicBarrier</code> 是可以重用的</li>
<li><code>CountDownLatch</code>中有两个关键，一个是<code>countDown()</code>，一个是<code>awit()</code>，调用<code>awit()</code>的线程需要等待，调用<code>countDown()</code>的线程会将倒计时-1，不同的线程职责可能是不同的，被管理的是调用了<code>awit()</code>的线程，计数器可以是单独的逻辑。</li>
</ul>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>信号量，用于控制同时访问某个资源的线程数量。它可以用来限制并发访问的线程数，或者用于线程间的信号通知。</p>
<p><code>Semaphore</code> 维护了一组许可（permits），线程在访问资源之前必须先获得许可，如果许可数不足，则线程必须等待，直到有可用的许可为止。每个 <code>Semaphore</code> 对象都有一个初始许可数，表示可同时访问该资源的线程数。</p>
<p>假设信号量初始数量为sem：</p>
<p>  P 操作：申请一个许可，将 sem 减 1，相减后，如果 <code>sem &lt; 0</code>，则进程/线程进入阻塞等待，否则继续，表明 P 操作可能会阻塞；</p>
<p>  V 操作：释放一个许可，将 sem 加 1，相加后，如果<code> sem &lt;= 0</code>，唤醒一个等待中的进程/线程，表明 V 操作不会阻塞；</p>
<p>常用方法：</p>
<ul>
<li><strong><code>acquire()</code></strong>: 获取一个许可，如果没有可用许可，则线程会被阻塞，直到有可用许可。</li>
<li><strong><code>release()</code></strong>: 释放一个许可，将其返回给 <code>Semaphore</code>。</li>
<li><code>tryAcquire()</code>: 尝试获取一个许可，如果获取成功则返回 true，否则返回 false。</li>
<li><code>availablePermits()</code>: 返回当前可用的许可数。</li>
</ul>
<h2 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h2><p>读写锁，控制对共享资源访问的同步机制。它允许多个线程同时读取资源，但只允许一个线程独占写入资源。</p>
<p>ReadWriteLock的目的是在资源被读取的频率高于写入的情况下优化性能。通过允许并发读取，多个线程可以同时访问资源，这可以提高吞吐量并减少线程之间的竞争。然而，当一个线程希望修改资源时，它需要独占访问以确保一致性。</p>
<h2 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork/Join"></a>Fork/Join</h2><p>核心思想：<strong>分而治之</strong></p>
<p>Fork-Join模型的核心思想是关键概念是”fork”（分叉）和”join”（合并），即将一个大任务划分为若干个小任务，然后并行地执行这些小任务，最后将它们的结果组合起来得到最终的结果。这个过程可以递归地进行，即每个小任务也可以再次划分成更小的子任务，直到任务的规模足够小以至于可以被直接执行。</p>
<p>两个实现类：</p>
<ul>
<li><code>RecursiveTask</code>有返回值</li>
<li><code>RecursiveAction</code>没有返回值</li>
</ul>
<p>Fork/Join框架的优势在于它能够自动地将任务划分成合适的大小，并利用多核处理器上的并行性提高程序的性能。它也提供了一些优化技术，如<em><strong>工作窃取（work stealing）</strong></em>，可以确保各个线程在执行任务时能够充分利用系统资源。</p>
<h3 id="工作窃取原理"><a href="#工作窃取原理" class="headerlink" title="工作窃取原理"></a>工作窃取原理</h3><ol>
<li>每个工作线程都有一个本地的工作队列（<em>双端队列</em>），用于存储待执行的任务。使用双端队列作为本地工作队列的好处在于，工作线程可以高效地从队列的头部或尾部执行插入和删除操作。当工作线程执行任务时，它会从队列的头部获取任务并执行；而当工作线程尝试窃取任务时，它会从队列的尾部插入窃取到的任务。</li>
<li>当一个工作线程的本地工作队列为空时，它会尝试从其他工作线程的工作队列中窃取任务。这个窃取的目标通常是选择一个相对较繁忙的工作线程，即其工作队列中有更多任务等待执行。</li>
<li>工作线程可以从目标工作线程的工作队列的顶部（头部）或者底部（尾部）窃取任务。选择窃取的位置可以根据具体的实现策略来确定，不同的实现方式可能有所不同。</li>
<li>窃取任务的过程通常是通过线程间的原子操作来实现的，以确保并发的正确性。例如，可以使用CAS（Compare and Swap）操作来保证任务的窃取是原子的。</li>
<li>当一个工作线程成功地窃取到任务后，它会将任务添加到自己的本地工作队列中，并继续执行窃取到的任务。</li>
</ol>
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的四大函数式接口</title>
    <url>/2023/04/27/Java%E4%B8%AD%E7%9A%84%E5%9B%9B%E5%A4%A7%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="Function"><a href="#Function" class="headerlink" title="Function<T, R>"></a>Function&lt;T, R&gt;</h2><p>函数式接口 <code>Function&lt;T, R&gt;</code> 的泛型参数解释如下：</p>
<ul>
<li><code>T</code>：表示函数的<em><strong>输入类型</strong></em>，即参数类型。</li>
<li><code>R</code>：表示函数的<em><strong>输出类型</strong></em>，即返回值类型。</li>
</ul>
<span id="more"></span>

<h2 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h2><p>断定型接口，有一个输入参数，返回值为布尔值</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPredicate</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Predicate&lt;String&gt; predicate = String::isEmpty;</span><br><span class="line">        System.out.println(predicate.test(<span class="string">"str"</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Suppier"><a href="#Suppier" class="headerlink" title="Suppier"></a>Suppier</h2><p>供给型接口，没有参数，只有返回值</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSupplier</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Supplier&lt;String&gt; supplier = () -&gt; {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"ok"</span>;</span><br><span class="line">        };</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="Consummer"><a href="#Consummer" class="headerlink" title="Consummer"></a>Consummer</h2><p>消费型接口，只有输入，没有输出</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestConsumer</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Consumer&lt;Integer&gt; consumer = (s) -&gt; {</span><br><span class="line">            System.out.println(s.toString());</span><br><span class="line">        };</span><br><span class="line">        consumer.accept(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Go generic VS Java generic</title>
    <url>/2024/02/14/Go%20generic%20VS%20Java%20generic/</url>
    <content><![CDATA[<p>随着Go 1.18版本的发布，Go语言正式引入了泛型这一重要特性。本文将对Go泛型与Java泛型进行对比分析，探讨它们之间的异同。</p>
<h2 id="Go泛型概述"><a href="#Go泛型概述" class="headerlink" title="Go泛型概述"></a>Go泛型概述</h2><h3 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h3><h4 id="类型参数"><a href="#类型参数" class="headerlink" title="类型参数"></a>类型参数</h4><p>类型参数是泛型函数或类型中的占位符，表示一个未知的具体类型。类型参数使用方括号<code>[]</code>括起来，并放在函数名或类型名之后。例如，在<code>func MyFunc[T any](a T) {}</code>中，<code>T</code>就是一个类型参数。</p>
<h4 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h4><p>约束是用来限制类型参数的方式，指定了类型参数必须满足的条件。约束可以是接口类型或其他带有类型参数的类型。例如，<code>func MyFunc[T io.Reader](a T) {}</code>中的<code>io.Reader</code>就是一个约束，表示类型参数<code>T</code>必须实现<code>io.Reader</code>接口。</p>
<span id="more"></span>

<h4 id="预定义约束"><a href="#预定义约束" class="headerlink" title="预定义约束"></a>预定义约束</h4><p>Go 1.18提供了一些预定义的约束，用于表示常见的类型集合。例如，<code>any</code>约束表示任何类型，而<code>comparable</code>约束表示可比较的类型（支持<code>==</code>和<code>!=</code>操作符）。</p>
<h4 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h4><p>泛型函数是一种使用类型参数的函数，可以处理不同类型的参数。泛型函数的定义类似于普通函数，只是在函数名后面添加了类型参数列表。例如，<code>func MyFunc[T any](a, b T) T {}</code>。</p>
<h4 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h4><p>泛型类型是一种使用类型参数的类型，可以表示不同类型的数据结构。泛型类型的定义类似于普通类型，只是在类型名后面添加了类型参数列表。例如，<code>type MySlice[T any] []T</code>。</p>
<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><ul>
<li>匿名函数不支持泛型，但可以使用别处定义好的类型作为实参。</li>
<li>不支持泛型方法。</li>
</ul>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>Go的泛型使用<code>interface</code>实现</p>
<ul>
<li>an approximation element <code>~T</code> restricts to all types whose underlying type is T: 代表底层类型是<code>T</code></li>
<li>a union element <code>T1 | T2 | ...</code> restricts to any of the listed elements: 代表<code>或</code>,类型列表之一。</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 任意类型 any</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span>[<span class="title">T1</span>, <span class="title">T2</span> <span class="title">any</span>]<span class="params">(x <span class="type">int</span>, y T1)</span></span> T2 {</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Integer <span class="keyword">interface</span> {</span><br><span class="line">  Signed | Unsigned</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Signed <span class="keyword">interface</span> {</span><br><span class="line">  ~<span class="type">int</span> | ~<span class="type">int8</span> | ~<span class="type">int16</span> | ~<span class="type">int32</span> | ~<span class="type">int64</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Unsigned <span class="keyword">interface</span> {</span><br><span class="line">  ~<span class="type">uint</span> | ~<span class="type">uint8</span> | ~<span class="type">uint16</span> | ~<span class="type">uint32</span> | ~<span class="type">uint64</span> | ~<span class="type">uintptr</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型抽象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span>[<span class="title">T</span> <span class="title">Integer</span>]<span class="params">(input T)</span></span> T {</span><br><span class="line">  <span class="keyword">if</span> input &lt; <span class="number">0</span> {</span><br><span class="line">    <span class="keyword">return</span> -input</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> input</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Java泛型概述"><a href="#Java泛型概述" class="headerlink" title="Java泛型概述"></a>Java泛型概述</h2><p>Java的泛型是在JDK 5中引入的，它的设计目标是为了提高类型安全性和代码重用性。</p>
<h3 id="关键概念-1"><a href="#关键概念-1" class="headerlink" title="关键概念"></a>关键概念</h3><ul>
<li><strong>泛型类型</strong>：定义了一个类型参数，如<code>List&lt;T&gt;</code>。</li>
<li><strong>泛型方法</strong>：可以在方法级别使用类型参数，如<code>public &lt;T&gt; void method(T t)</code>。</li>
<li><strong>类型擦除</strong>：Java编译器会在编译阶段消除类型参数，替换为实际类型，这保证了向后兼容性。</li>
</ul>
<h3 id="限制-1"><a href="#限制-1" class="headerlink" title="限制"></a>限制</h3><ul>
<li>Java泛型支持泛型方法。</li>
<li>Java泛型有类型擦除的概念，这意味着在运行时无法获取类型参数的实际类型。</li>
</ul>
<h2 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h2><h3 id="泛型定义"><a href="#泛型定义" class="headerlink" title="泛型定义"></a>泛型定义</h3><ul>
<li><strong>Go</strong>：类型参数、约束和预定义约束提供了明确的类型约束机制。</li>
<li><strong>Java</strong>：类型参数和泛型方法提供了灵活的类型抽象。</li>
</ul>
<h3 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h3><ul>
<li><strong>Go</strong>：没有类型擦除，泛型类型在运行时保留类型信息。</li>
<li><strong>Java</strong>：存在类型擦除，编译后的字节码不包含类型参数信息。</li>
</ul>
<h3 id="其他特点"><a href="#其他特点" class="headerlink" title="其他特点"></a>其他特点</h3><ul>
<li><strong>Go</strong>：不支持泛型方法，匿名函数不支持泛型。</li>
<li><strong>Java</strong>：支持泛型方法，匿名内部类可以使用泛型。</li>
</ul>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://www.kunkkawu.com/archives/shen-ru-li-jie-golang-de-fan-xing">深入理解Go的泛型</a></li>
<li><a href="https://tonybai.com/2022/03/25/intro-generics/">Go 1.18 泛型入门</a></li>
</ul>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Java VS Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程池</title>
    <url>/2023/02/03/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h2 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h2><p>使用<code>Executors</code>创建线程池：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newSingleThreadExecutor(); <span class="comment">//单个线程</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool2</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>); <span class="comment">//创建一个固定的线程池的大小</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool3</span> <span class="operator">=</span> Executors.newCachedThreadPool(); <span class="comment">//可伸缩的线程池</span></span><br></pre></td></tr></tbody></table></figure>

<p>但是不建议使用<code>Executors</code>创建线程池，在阿里巴巴技术规范中写有：</p>
<p><img src="/../images/image-20240903160832255.png" alt="image-20240903160832255"></p>
<span id="more"></span>

<blockquote>
<p>使用<code>Executors</code>创建线程池的本质实际上也是调用了<code>ThreadPoolExecutor</code>创建线程池，但是创建的线程池默认配置不太合理？</p>
</blockquote>
<h2 id="TreadPoolExector"><a href="#TreadPoolExector" class="headerlink" title="TreadPoolExector"></a>TreadPoolExector</h2><p><code>ThreadPoolExecutor</code>的构造方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, </span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize, </span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime, </span></span><br><span class="line"><span class="params">                          TimeUnit unit, </span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue, </span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory, </span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>ThreadPoolExecutor</code>的构造函数具有以下七个参数，它们分别是：</p>
<ol>
<li><p><code>corePoolSize</code>（核心线程数）：</p>
<p> 它指定了线程池中保持活动状态的核心线程数量。核心线程是一直存活的线程，即使它们处于空闲状态也不会被回收。当有新任务提交时，核心线程会立即执行任务。如果使用的是无界队列，线程池中的线程数永远不会超过核心线程数。</p>
</li>
<li><p><code>maximumPoolSize</code>（最大线程数）：</p>
<p> 它定义了线程池中允许创建的最大线程数量。当工作队列已满且当前线程数小于最大线程数时，线程池会创建新的线程来执行任务。如果使用的是有界队列，当队列已满且线程数达到最大值时，新的任务会触发拒绝策略。</p>
</li>
<li><p><code>keepAliveTime</code>（线程空闲超时时间）：</p>
<p> 它表示非核心线程空闲的最大时间。当线程池中的线程数超过核心线程数，并且空闲时间超过该值时，多余的线程会被终止并从线程池中移除，以减少资源消耗。新任务到达时，如果线程池中的线程数小于核心线程数，可能会重新创建线程。</p>
</li>
<li><p><code>unit</code>（空闲超时时间的单位）：</p>
<p> 用于指定<code>keepAliveTime</code>参数的单位，可以是<code>TimeUnit.SECONDS</code>、<code>TimeUnit.MILLISECONDS</code>等。</p>
</li>
<li><p><code>workQueue</code>（工作队列）：</p>
<p> 它定义了用于保存待执行任务的阻塞队列。当任务提交到线程池时，如果线程数小于核心线程数，会创建新线程来执行任务。如果线程数达到核心线程数，而工作队列未满，则将任务放入队列中等待执行。工作队列可以是有界队列（如<code>ArrayBlockingQueue</code>）或无界队列（如<code>LinkedBlockingQueue</code>）。</p>
</li>
<li><p><code>threadFactory</code>（线程工厂，可选）：</p>
<p> 线程工厂指定创建线程的方式，用于创建新线程的工厂对象。线程工厂可以根据需要对线程进行自定义配置，例如设置线程名字、设置线程优先级等。如果未指定，将使用默认的<code>DefaultThreadFactory</code></p>
</li>
<li><p><code>handler</code>（拒绝策略，可选）：</p>
<p> 它定义了当线程池无法接受新任务时的处理方式。拒绝策略可以是预定义的几种策略，如抛出异常、丢弃任务、阻塞等。也可以根据需要自定义拒绝策略实现<code>RejectedExecutionHandler</code>接口。</p>
</li>
</ol>
<p>我们可以这样类比：</p>
<p><img src="/../images/image-20240903161026674.png" alt="image-20240903161026674"></p>
<h3 id="工作队列-BlockQueue"><a href="#工作队列-BlockQueue" class="headerlink" title="工作队列 BlockQueue"></a>工作队列 BlockQueue</h3><p>使用用<code>ThreadPoolExecutor</code>需要指定一个<code>BlockingQueue</code>任务等待队列。在<code>ThreadPoolExecutor</code>线程池的API文文档中，一共推荐了三种等待队列:</p>
<ol>
<li><code>SynchronousQueue</code> 同步队列</li>
<li><code>LinkedBlockingQueue</code></li>
<li><code>ArrayBlockingQueue</code></li>
</ol>
<p>BlockingQueue（阻塞队列）定义了一组用于插入、获取和检查元素的方法。与普通的队列不同，BlockingQueue在队列为空时，获取元素的操作会被阻塞，直到队列中有可用元素为止。同样地，当队列已满时，插入元素的操作也会被阻塞，直到队列有空闲空间为止。</p>
<p>BlockQueue有四组API：</p>
<p><img src="/../images/image-20240903161114544.png" alt="image-20240903161114544"></p>
<p>BlockingQueue提供了多个实现类，其中常用的有以下几种：</p>
<ol>
<li><code>ArrayBlockingQueue</code>：基于数组实现的有界阻塞队列。它在构造时需要指定队列的容量，并且在队列已满时会阻塞插入操作，直到有空闲空间。</li>
<li><code>LinkedBlockingQueue</code>：基于链表实现的可选有界或无界阻塞队列。如果构造时不指定容量，则队列大小默认为无限制。</li>
<li><code>PriorityBlockingQueue</code>：基于优先级堆实现的无界阻塞队列。元素按照优先级进行排序，可以自定义比较器。</li>
<li><code>SynchronousQueue</code>：同步队列。是一个没有容量的阻塞队列，任何一次插入操作的元素都要等待相对的删除/读取操作，否则进行行行插入操作的线程就要一直等待,反之亦然<ol>
<li>进去一个元素，必须等待取出来之后，才能再往里面放入一个元素</li>
<li>使用lock锁保证线程安全的</li>
</ol>
</li>
<li><code>DelayQueue</code>：基于优先级堆实现的延迟阻塞队列。其中的元素必须实现<code>Delayed</code>接口，只有经过一定时间后才能被取出。</li>
</ol>
<p><em><strong>BlockingQueue实现原理：ReentrantLock + Condition</strong></em></p>
<p><code>ArrayBlockingQueue</code>和<code>LinkedBlockingQueue</code>区别：</p>
<ul>
<li><code>ArrayBlockingQueue</code>使用数组作缓冲区，有界，生产者消费者之间使用<strong>独占锁</strong>，出队和入队不能同时进行</li>
<li><code>LinkedBlockingQueue</code>使用链表作缓冲区，无界，生产者消费者之间使用<strong>分离锁</strong>，出队和入队可以同时进行</li>
</ul>
<h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>  如上面介绍，拒绝策略需要实现<code>RejectedExecutionHandler</code>接口，<code>Executors</code>为我们提供了4种拒绝策略：</p>
<ul>
<li><code>AbortPolicy</code>（默认）：丢弃任务并抛出<code>RejectedExecutionException</code>异常</li>
<li><code>CallerRunsPolicy</code>：直接运行这个任务的run方法，但并非是由线程池处理，而是交由任务的调用线程处理</li>
<li><code>DiscardPolicy</code>：直接丢弃任务，不抛出任何异常</li>
<li><code>DiscardOldestPolicy</code>：将当前处于等待队列列头的等待任务强行取出，然后再试图将当前被拒绝的任务提交</li>
</ul>
<h2 id="Executors封装线程池"><a href="#Executors封装线程池" class="headerlink" title="Executors封装线程池"></a>Executors封装线程池</h2><p>三种线程池的特点：</p>
<ul>
<li><code>SingleThreadExecutor</code>单线程线程池<ul>
<li>特点：线程池只有一个线程</li>
<li>使用一个<code>LinkedBlockingQueue</code>作为工作队列，未指定容量（默认值<code>Integer.MAX_VALUE</code>）</li>
</ul>
</li>
<li><code>FixedThreadPool</code>固定线程池<ul>
<li>特点：最大线程数就是核心线程数</li>
<li><code>keepAliveTime=0</code>，但核心线程不会被回收或者销毁</li>
<li>无界队列：使用<code>LinkedBlockingQueue</code>作为工作队列，未指定容量（默认值<code>Integer.MAX_VALUE</code>）</li>
<li>适用于需要并发控制的场景</li>
</ul>
</li>
<li><code>CachedThreadPool</code>缓存线程池<ul>
<li>没有核心线程，普通线程数量无限</li>
<li>线程闲置60s后回收</li>
<li>使用<code>SynchronousQueue</code>作为工作队列，它不会保存任务，而是直接将任务交给空闲线程执行</li>
<li>适用用于任务量大但耗时低的场景</li>
</ul>
</li>
<li><code>ScheduledThreadPool</code>定时线程池<ul>
<li>指定核心线程数量，普通线程数量无限</li>
<li>任务队列为延时阻塞队列<code>DelayQueue</code></li>
<li>适用用于执行定时或周期性的任务</li>
</ul>
</li>
</ul>
<h2 id="线程池调优"><a href="#线程池调优" class="headerlink" title="线程池调优"></a>线程池调优</h2><p>在设置线程池大小时，可以考虑任务类型和系统资源的特点，以确定适当的线程池大小。具体而言，对于 CPU 密集型任务和 I/O 密集型任务，可以采取以下建议：</p>
<ul>
<li><strong>CPU 密集型任务</strong><ul>
<li>对于 CPU 密集型任务，线程数应与 CPU 核心数相近或稍多一些，以充分利用 CPU 资源，并避免过多的线程竞争和上下文切换开销。</li>
<li>可以通过 <code>Runtime.getRuntime().availableProcessors()</code> 获取当前系统的 CPU 核心数，作为线程池的核心线程数。</li>
<li>由于 CPU 密集型任务不涉及阻塞等待，可以选择较小的工作队列容量或使用 <code>SynchronousQueue</code>，使得任务提交后立即执行。</li>
</ul>
</li>
<li><strong>I/O 密集型任务</strong><ul>
<li>对于 I/O 密集型任务，一般建议将线程数设置为 CPU 核心数的几倍，例如 2 倍或 4 倍，以充分利用 I/O 操作的等待时间，提高系统的吞吐量。</li>
<li>由于 I/O 操作会涉及到阻塞等待，可以设置较大的工作队列容量，以处理可能的任务积压。</li>
</ul>
</li>
</ul>
<p>实际线程池大小的选择还取决于任务的具体特点和系统资源的限制。在实际应用中，可以通过测试和性能调优来确定最佳的线程池大小，确保任务能够高效执行并充分利用系统资源。</p>
]]></content>
  </entry>
  <entry>
    <title>🐛 LangChain4j-Spring Bug修复记录</title>
    <url>/2024/08/20/LangChain4j-Spring%20Bug/</url>
    <content><![CDATA[<p>起因：在使用langchain4j的过程中发现，项目默认只会扫描启动类下的带有<code>@AiService</code>的接口， 并且扫描的方式是通过<code>Reflections</code>扫描启动类所在的classPath而不是通过Spring自带的方法</p>
<p>如果使用<code>@ComponentScan</code>扫描特定的文件路径，那么特定路径下的<code>@AiService</code>接口将不会被扫描并被代理到，最后就导致了Bean无法注入的Bug _(:з」∠)_</p>
<h2 id="相关issue"><a href="#相关issue" class="headerlink" title="相关issue"></a>相关issue</h2><ul>
<li><a href="https://github.com/langchain4j/langchain4j/issues/1606">https://github.com/langchain4j/langchain4j/issues/1606</a></li>
<li><a href="https://github.com/langchain4j/langchain4j-spring/pull/35">https://github.com/langchain4j/langchain4j-spring/pull/35</a></li>
</ul>
<blockquote>
<p><em>Tips</em>：这也是我第一次参加开源，虽然只是做了一个微不足道的贡献，但是还是感觉收获很多吧…一直在担心自己的水平不够所以反复理解反复查资料，但是作者很热心帮我修改了代码并且很快就被处理接受了😃</p>
</blockquote>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>在Springboot中使用<code>context/beanFactory</code>获取带有<code>@AiService</code>的Bean，发现Springboot会自动忽略接口，原因在于<strong>Spring是不会扫描接口的，因为接口没有办法实例化</strong>，因此作者的做法为：</p>
<ol>
<li><code>Reflections</code>扫描当前启动类所在的classPath获取带有<code>@AiService</code>的接口</li>
<li>在<code>BeanFactoryPostProcessor</code>阶段（Bean加载完但还未创建任何Bean实例前），使用<code>AiServiceFactory</code>替换接口的BeanDefinition完成代理替换</li>
</ol>
<p>关键代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Set&lt;Class&lt;?&gt;&gt; findAiServices(ConfigurableListableBeanFactory beanFactory) {</span><br><span class="line">    String[] applicationBean = beanFactory.getBeanNamesForAnnotation(SpringBootApplication.class);</span><br><span class="line">    <span class="type">BeanDefinition</span> <span class="variable">applicationBeanDefinition</span> <span class="operator">=</span> beanFactory.getBeanDefinition(applicationBean[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">String</span> <span class="variable">basePackage</span> <span class="operator">=</span> applicationBeanDefinition.getResolvableType().resolve().getPackage().getName();</span><br><span class="line">    <span class="type">Reflections</span> <span class="variable">reflections</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reflections</span>((<span class="keyword">new</span> <span class="title class_">ConfigurationBuilder</span>()).forPackage(basePackage));</span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; classes = reflections.getTypesAnnotatedWith(AiService.class);</span><br><span class="line">    classes.removeIf(clazz -&gt; !clazz.getName().startsWith(basePackage));</span><br><span class="line">    <span class="keyword">return</span> classes;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>针对以上问题，我在PR中做的主要改动如下：</p>
<h2 id="改动1：获取所有的ComponentScan的basePackage并扫描"><a href="#改动1：获取所有的ComponentScan的basePackage并扫描" class="headerlink" title="改动1：获取所有的ComponentScan的basePackage并扫描"></a>改动1：获取所有的ComponentScan的basePackage并扫描</h2><p>既然需要扫描多个模块，扫描的方式也是通过<code>@ComponentScan</code>指定的，那么就获取所有的<code>@ComponentScan</code>指定的扫描路径进行扫描吧：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Set&lt;String&gt; <span class="title function_">getBasePackages</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> {</span><br><span class="line">  Set&lt;String&gt; basePackages = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  List&lt;String&gt; autoConfigPackages = AutoConfigurationPackages.get(beanFactory);</span><br><span class="line">  basePackages.addAll(autoConfigPackages);</span><br><span class="line">  </span><br><span class="line">  String[] beanNames = beanFactory.getBeanNamesForAnnotation(ComponentScan.class);</span><br><span class="line">  <span class="keyword">for</span> (String beanName : beanNames) {</span><br><span class="line">      Class&lt;?&gt; beanClass = beanFactory.getType(beanName);</span><br><span class="line">      <span class="keyword">if</span> (beanClass != <span class="literal">null</span>) {</span><br><span class="line">          <span class="type">ComponentScan</span> <span class="variable">componentScan</span> <span class="operator">=</span> beanClass.getAnnotation(ComponentScan.class);</span><br><span class="line">          <span class="keyword">if</span> (componentScan != <span class="literal">null</span>) {</span><br><span class="line">              Collections.addAll(basePackages, componentScan.value());</span><br><span class="line">              Collections.addAll(basePackages, componentScan.basePackages());</span><br><span class="line">              <span class="keyword">for</span> (Class&lt;?&gt; basePackageClass : componentScan.basePackageClasses()) {</span><br><span class="line">                  basePackages.add(ClassUtils.getPackageName(basePackageClass));</span><br><span class="line">              }</span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="改动2：自定义ClassPathBeanDefinitionScanner扫描接口"><a href="#改动2：自定义ClassPathBeanDefinitionScanner扫描接口" class="headerlink" title="改动2：自定义ClassPathBeanDefinitionScanner扫描接口"></a>改动2：自定义ClassPathBeanDefinitionScanner扫描接口</h2><p>如果是要与Spring集成的话肯定是使用Spring的方法更好，但是Spring自带的类扫描器会直接过滤接口，因此在这里自定义了一个专用于扫描接口的类扫描器</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassPathAiServiceScanner</span> <span class="keyword">extends</span> <span class="title class_">ClassPathBeanDefinitionScanner</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClassPathAiServiceScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="type">boolean</span> useDefaultFilters)</span> {</span><br><span class="line">        <span class="built_in">super</span>(registry, useDefaultFilters);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isCandidateComponent</span><span class="params">(AnnotatedBeanDefinition beanDefinition)</span> {</span><br><span class="line">        <span class="keyword">return</span> beanDefinition.getMetadata().isInterface() &amp;&amp; beanDefinition.getMetadata().isIndependent();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>那么问题来了，如何让Spring使用我们自定义的类扫描器呢？Spring自带的扫描器都是在<code>@ComponentScan</code>解析流程中创建出来的，我们又不能更改这个流程</p>
<p>但是我们可以在Spring的扫描流程结束后，再扫描一遍不就好了吗？于是这里在<code>postProcessBeanDefinitionRegistry</code>阶段重新进行了一次扫描：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AiServiceScannerProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException {</span><br><span class="line">        <span class="type">ClassPathAiServiceScanner</span> <span class="variable">classPathAiServiceScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathAiServiceScanner</span>(registry, <span class="literal">false</span>);</span><br><span class="line">        classPathAiServiceScanner.addIncludeFilter(<span class="keyword">new</span> <span class="title class_">AnnotationTypeFilter</span>(AiService.class));</span><br><span class="line">        Set&lt;String&gt; basePackages = getBasePackages((ConfigurableListableBeanFactory) registry);</span><br><span class="line">        classPathAiServiceScanner.scan(StringUtils.toStringArray(basePackages));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里的解决方案其实也参考了MyBatis的实现：MyBatis通过<code>@Mapper</code>即可将类注入到Spring中，原理正是在于使用了自定义类扫描器<code>ClassPathMapperScanner</code>扫描所有带有<code>@Mapper</code>和<code>@MapperScan</code>指定的路径，详细过程可以参考 <a href="./Mybatis%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8Cbean%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F.md">Mybatis实现动态注册bean的两种方式</a></p>
<hr>
<p>参考：</p>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1962431">https://cloud.tencent.com/developer/article/1962431</a></li>
<li><a href="https://blog.csdn.net/qq_31086797/article/details/124488829">https://blog.csdn.net/qq_31086797/article/details/124488829</a></li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>langchain4j</tag>
      </tags>
  </entry>
  <entry>
    <title>LangChain入门笔记</title>
    <url>/2024/03/27/LangChain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>基本架构</p>
<p><img src="/../images/langchain_stack_dark_NdLaDhZn28.svg"></p>
<span id="more"></span>

<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>LangChain是一个用于开发由语言模型驱动的应用程序的框架。</p>
<p>主要功能：</p>
<ul>
<li><p>调用语言模型</p>
</li>
<li><p>将不同数据源接入到语言模型的交互中</p>
</li>
<li><p>允许语言模型与运行环境交互</p>
</li>
</ul>
<p>LangChain中提供的模块</p>
<ul>
<li><p>Modules：支持的模型类型和集成。</p>
</li>
<li><p>Prompt：提示词管理、优化和序列化。</p>
</li>
<li><p>Memory：内存是指在链/代理调用之间持续存在的状态。</p>
</li>
<li><p>Indexes：当语言模型与特定于应用程序的数据相结合时，会变得更加强大-此模块包含用于加载、查询和更新外部数据的接口和集成。</p>
</li>
<li><p>Chain：链是结构化的调用序列（对LLM或其他实用程序）。</p>
</li>
<li><p>Agents：代理是一个链，其中LLM在给定高级指令和一组工具的情况下，反复决定操作，执行操作并观察结果，直到高级指令完成。</p>
</li>
<li><p>Callbacks：回调允许您记录和流式传输任何链的中间步骤，从而轻松观察、调试和评估应用<br>程序的内部。</p>
</li>
</ul>
</blockquote>
<p>应用场景：</p>
<ul>
<li>文档问答</li>
<li>个人助理</li>
<li>查询数据表格（CSV、SQL、DataFrame等）</li>
<li>与API交互</li>
<li>信息提取</li>
<li>文档总结</li>
</ul>
<h1 id="Model-I-O"><a href="#Model-I-O" class="headerlink" title="Model I/O"></a>Model I/O</h1><p>四个核心组件：</p>
<ul>
<li>Prompts 提示词</li>
<li>Chat Models 聊天模型<ul>
<li>擅长对话</li>
</ul>
</li>
<li>LLMs 纯文本模型<ul>
<li>擅长理解和合成文本方面，例如总结文档、PDF、概念页面等</li>
</ul>
</li>
<li>Output parsers 输出转换器</li>
</ul>
<blockquote>
<p>📌Chat Models 和 LLMs 的区别：</p>
<p>Chat models和LLMs都是LangChain中的语言模型抽象，但是LLMs是纯语言模型，Chat models是针对对话做了优化的聊天模型</p>
</blockquote>
<h1 id="Agents"><a href="#Agents" class="headerlink" title="Agents"></a>Agents</h1><blockquote>
<p>大型语言模型（LLMs）非常强大，但它们缺乏“最笨”的计算机程序可以轻松处理的特定能力。LLM 对逻辑推理、计算和检索外部信息的能力较弱，这与最简单的计算机程序形成对比。例如，语言模型无法准确回答简单的计算问题，还有当询问最近发生的事件时，其回答也可能过时或错误，因为无法主动获取<br>最新信息。这是由于当前语言模型仅依赖预训练数据，与外界“断开”。要克服这一缺陷， LangChain 框<br>架提出了 “代理”(Agent) 的解决方案。</p>
</blockquote>
<p>Agent作为语言模型的外部模块，可提供计算、逻辑、检索等功能的支持，使语言模型获得异常强大的推理和获取信息的超能力。</p>
<hr>
<p>Agents的核心思想是使用语言模型来选择要采取的一系列Action</p>
<p>在langchain中，一系列Action被硬编码（在代码中）。</p>
<p>在Agents中，语言模型被用作推理引擎来确定要采取哪些操作以及按什么顺序。</p>
<p>不同Agents的区别：不同的推理提示风格、不同的编码输入方式以及不同的解析输出方式。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h3><p>构建代理的核心组件</p>
<ul>
<li><code>AgentAction</code> 即Action，表示代理执行的操作，通常表示调用tools<ul>
<li>我们将想让对Agents的操作封装成Action（tools），再让Agents在被调用时选择应该使用哪些tools</li>
<li>在<code>AgentAction</code>中有两个属性：<code>tool</code>和<code>tool_input</code>，分别代表工具的名字和工具输入</li>
</ul>
</li>
<li><code>AgentFinish</code>  Agents返回的最终结果</li>
<li><code>Intermediate Steps</code> 中间步骤。代表<code>AgentAction</code>以及当前Agents运行的相应输出</li>
</ul>
<h3 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h3><ul>
<li><code>Agent Inputs</code> Agents的输入，键值对类型<ul>
<li>required：<code>intermediate_steps</code></li>
</ul>
</li>
<li><code>Agent Outputs</code> Agents的响应，分为<code>Union[AgentAction, List[AgentAction], AgentFinish]</code><ul>
<li>输出解析器负责获取原始 LLM 输出并将其转换为这三种类型之一</li>
</ul>
</li>
</ul>
<p>demo：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">agent = (</span><br><span class="line">    {</span><br><span class="line">        <span class="string">"input"</span>: <span class="keyword">lambda</span> x: x[<span class="string">"input"</span>],</span><br><span class="line">        <span class="string">"agent_scratchpad"</span>: <span class="keyword">lambda</span> x: format_to_openai_tool_messages(</span><br><span class="line">            x[<span class="string">"intermediate_steps"</span>]</span><br><span class="line">        ),</span><br><span class="line">    }</span><br><span class="line">    | prompt</span><br><span class="line">    | llm_with_tools</span><br><span class="line">    | OpenAIToolsAgentOutputParser()</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>

<h4 id="Agents-API"><a href="#Agents-API" class="headerlink" title="Agents API"></a>Agents API</h4><ul>
<li><code>AgentExecutor</code> 重复调用Agents并执行工具<ul>
<li>封装了各种错误处理、日志等</li>
</ul>
</li>
</ul>
<h3 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h3><p>工具是代理可以调用​​的功能。 <code>Tool</code> 抽象由两个组件组成：</p>
<p>工具 API 的目标是比使用通用文本完成或聊天 API 更可靠地返回有效且有用的工具调用。</p>
<ul>
<li>schema</li>
<li>function</li>
</ul>
<p>设计Agents的关键：</p>
<ul>
<li>让Agents正确的使用tools</li>
<li>以对代理最有帮助的方式描述工具</li>
</ul>
<h2 id="Agent-Type"><a href="#Agent-Type" class="headerlink" title="Agent Type"></a>Agent Type</h2><p>介绍几个常用的Agent Type</p>
<p>ReAct：LLM 可以循环进行 Reasoning 和 Action 步骤的过程。它启用了一个多步骤的过程来识别答案。</p>
<h1 id="Prompt"><a href="#Prompt" class="headerlink" title="Prompt"></a>Prompt</h1><p>提示词工程和模型微调的区别：</p>
<ul>
<li><p>微调</p>
<ul>
<li>定义：针对预先训练的语言模型，在特定任务的少量数据集上对其进行进一步训练</li>
<li>适用场景：当任务或域定义明确，并且有足够的标记数据可供训练时，通常使用微调过程</li>
</ul>
</li>
<li><p>提示词工程</p>
<ul>
<li>涉及设计自然语言提示或指令，可以指导语言模型执行特定任务</li>
<li>最适合需要高精度和明确输出的任务。提示工程可用于制作引发所需输出的查询</li>
</ul>
</li>
</ul>
<h1 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h1><p><img src="/../images/memory_diagram-0627c68230aa438f9b5419064d63cbbc_eZ.png"></p>
<p>四种主要储存模块：</p>
<ul>
<li><code>ConversationBufferMemory</code>对话缓存</li>
<li><code>ConversationTokenBufferMemory</code>按窗口缓存</li>
<li><code>ConversationTokenBufferMemory</code>按令牌缓存</li>
<li><code>ConversationSummaryBufferMemory</code>按摘要缓存</li>
</ul>
<p>最常见的内存类型之一涉及返回聊天消息列表。这些可以作为单个字符串返回，全部连接在一起（当它们被传递到 LLMs 时有用）或 ChatMessages 列表（当传递到 ChatModels 时有用）。</p>
<p>默认情况下，它们作为单个字符串返回。为了作为消息列表返回，您可以设置 <code>return_messages=True</code></p>
<p><img src="/../images/image_96cXegtOz-.png"></p>
<h1 id="Chains"><a href="#Chains" class="headerlink" title="Chains"></a>Chains</h1><p>链是指调用序列 - 即 LLM、Tools还是数据预处理步骤的先后顺序。主要支持的方法是使用 LCEL。</p>
<h2 id="LCEL-Chains"><a href="#LCEL-Chains" class="headerlink" title="LCEL Chains"></a>LCEL Chains</h2><p>LangChain Expression Language（LCEL）可以轻松地从基本组件构建复杂的链，并支持开箱即用的功能，例如流式传输、并行性和日志记录，最基本和常见的用例是将Prompt和LLM链接在一起。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">chain = prompt | model | output_parser</span><br></pre></td></tr></tbody></table></figure>

<p><a href="https://python.langchain.com/v0.1/docs/expression_language/get_started/" title="https://python.langchain.com/v0.1/docs/expression_language/get_started/">https://python.langchain.com/v0.1/docs/expression_language/get_started/</a></p>
<p>意义：组合大模型调用中不相关的部分，让开发者省去胶水代码</p>
<p>下面举一些简单的栗子：</p>
<p>模型调用：</p>
<p><img src="/../images/image_tamQ_03vHR.png"></p>
<p>Stream流：</p>
<p><img src="/../images/image_UPmDNoWd_p.png"></p>
<p>Batch批处理：</p>
<p><img src="/../images/image_JliK3KA3oM.png"></p>
<p>异步调用：</p>
<p><img src="/../images/image_Gf01np9mh3.png"></p>
<h1 id="RAG"><a href="#RAG" class="headerlink" title="RAG"></a>RAG</h1><p>全称Retrieval Augmented Generation (RAG)</p>
<p><img src="/../images/data_connection-95ff2033a8faa5f3ba41376c0f6dd32a_P.jpg"></p>
<p>核心组件：</p>
<ul>
<li><strong>Document loaders</strong>文档加载器</li>
<li>Text Splitting文本分割器，将大文档分割（或分块）为更小的块。</li>
<li>Text Embedding models嵌入模型，用于将文档嵌入到Vector stores中，主要有两种常用方式：<ul>
<li>text2vector</li>
<li>llm</li>
</ul>
</li>
<li>Retrievers检索器，用于在数据源中检索相关信息</li>
<li>Indexing数据库索引，用于检索</li>
</ul>
<h2 id="Retrievers检索"><a href="#Retrievers检索" class="headerlink" title="Retrievers检索"></a>Retrievers检索</h2><p>相关算法：</p>
<ul>
<li><p>基本语义相似度（Basicsemanticsimilarity)</p>
</li>
<li><p>最大边际相关性（Maximummarginalrelevance，MMR)</p>
</li>
<li><p>过滤元数据</p>
</li>
<li><p>LLM辅助检索 SelfQueryRetriever</p>
</li>
<li><p>压缩 ContextualCompressionRetriever</p>
<ul>
<li>工作原理：先使用标准向量检索获得候选文档，然后基于查询语句的语义，使用语言模型压缩这些文档,只保留与问题相关的部分<br><img src="/../images/image_cehTwhXkXE.png"></li>
</ul>
</li>
</ul>
<p>其他类型的检索：</p>
<p>vetordb 并不是唯一一种检索文档的工具。 LangChain 还提供了其他检索文档的方式，例如： TF-IDF 或 SVM 。</p>
<h2 id="对话检索链"><a href="#对话检索链" class="headerlink" title="对话检索链"></a>对话检索链</h2><h3 id="检索链类型"><a href="#检索链类型" class="headerlink" title="检索链类型"></a>检索链类型</h3><p>通过LangChain创建一个检索问答链，对检索到的文档进行问题回答。检索问答链的输入包含以下</p>
<ul>
<li>llm大语言模型</li>
<li><code>chain_type</code>指定传入链（用于将文档传递到 LLM 的上下文窗口中）类型<ul>
<li><strong>Stuff</strong>：只需将所有文档“塞”到一个提示中即可，这是最简单的方法<ul>
<li>API：create_stuff_documents_chain</li>
</ul>
</li>
<li><strong>Map-reduce</strong>：将所有块与问题一起传递给语言模型，获取回复，使用另一个语言模型调用将所有单独的回复总结成最终答案，它可以在任意数量的文档上运行。可以并行处理单个问题，同时也需要更多的调用。它将所有文档视为独立的<ul>
<li>MapReduceDocumentsChain</li>
</ul>
</li>
<li><strong>Refine</strong><ul>
<li>循环许多文档，实际上是迭代的，建立在先前文档的答案之上，非常适合前后因果信息并随时间逐步构建答案，依赖于先前调用的结果。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/../images/summarization_use_case_2-f2a4d5d60980a79140085fb7f.png" alt="Stuff和MapReduce区别" title="Stuff和MapReduce区别"></p>
<p><img src="/../images/image_kuqREZwJrr.png"></p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.chains.combine_documents.stuff <span class="keyword">import</span> StuffDocumentsChain</span><br><span class="line"><span class="keyword">from</span> langchain.chains.llm <span class="keyword">import</span> LLMChain</span><br><span class="line"><span class="keyword">from</span> langchain_core.prompts <span class="keyword">import</span> PromptTemplate</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define prompt</span></span><br><span class="line">prompt_template = <span class="string">"""Write a concise summary of the following:</span></span><br><span class="line"><span class="string">"{text}"</span></span><br><span class="line"><span class="string">CONCISE SUMMARY:"""</span></span><br><span class="line">prompt = PromptTemplate.from_template(prompt_template)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define LLM chain</span></span><br><span class="line">llm = ChatOpenAI(temperature=<span class="number">0</span>, model_name=<span class="string">"gpt-3.5-turbo-16k"</span>)</span><br><span class="line">llm_chain = LLMChain(llm=llm, prompt=prompt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define StuffDocumentsChain</span></span><br><span class="line">stuff_chain = StuffDocumentsChain(llm_chain=llm_chain, document_variable_name=<span class="string">"text"</span>)</span><br><span class="line"></span><br><span class="line">docs = loader.load()</span><br><span class="line"><span class="built_in">print</span>(stuff_chain.run(docs))</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>LLM</category>
      </categories>
      <tags>
        <tag>langchain</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis实现动态注册bean的两种方式</title>
    <url>/2024/03/26/Mybatis%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8Cbean%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>我们都知道MyBatis可以通过<code>@MapperScanner</code>和<code>@Mapper</code>两种方法将Mapper注入到Spring容器中，本文介绍MyBatis如何实现动态注册Bean的两种方式的实现原理，以便在其他类似的场景作为参考。</p>
<h2 id="MyBatis代理DAO接口类过程"><a href="#MyBatis代理DAO接口类过程" class="headerlink" title="MyBatis代理DAO接口类过程"></a>MyBatis代理DAO接口类过程</h2><p>先看一下MyBatis代理Bean的过程：</p>
<ul>
<li><code>MapperScannerConfigurer</code>核心配置类<ul>
<li><code>MapperScannerConfigurer#postProcessBeanDefinitionRegistry</code>负责在Bean注册后扫描调用<code>ClassPathMapperScanner</code>全部的Mapper</li>
</ul>
</li>
<li><code>ClassPathMapperScanner</code>类扫描器，继承自<code>ClassPathBeanDefinitionScanner</code>，负责在classPath中扫描所有的继承了Mapper的DAO接口，对扫描到的Mapper接口进行封装<ul>
<li>封装方式：使用<code>MapperFactoryBean</code>替换接口的<code>BeanDefinition</code>，会把<code>sqlSessionFactory</code>，<code>sqlSessionTemplate</code>等参数传递给<code>MapperFactoryBean</code>，从而创建<code>SqlSession</code>(<code>SqlSessionTemplate</code>)，通过<code>getObject()</code>返回代理类</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="动态注册Bean"><a href="#动态注册Bean" class="headerlink" title="动态注册Bean"></a>动态注册Bean</h2><p>那么<code>MapperScannerConfigurer</code>扫描的路径、参数、是否懒加载等配置是在什么时候注入的呢？不同的MyBatis使用姿势实现的方式不同：</p>
<ul>
<li><code>@MapperScan</code><ul>
<li>通过<code>ImportBeanDefinitionRegistrar</code>注入<code>MapperScannerRegistrar</code>，其中<code>ImportBeanDefinitionRegistrar</code>也是Spring官方动态注册bean的常用套路</li>
<li><code>MapperScannerRegistrar</code>中构造了<code>MapperScannerConfigurer</code>，配置了<code>MapperScannerConfigurer</code>的基本属性，如basePackage、annotationClass等等</li>
</ul>
</li>
<li><code>@Mapper</code><ul>
<li><code>@Mapper</code>的扫描逻辑在<code>AutoConfiguredMapperScannerRegistrar</code>（通过自动装配注入），在不使用<code>@MapperScanner</code>指定扫描路径的情况下只会扫描启动类所在的classPath</li>
<li>同上，<code>AutoConfiguredMapperScannerRegistrar</code>中构造了<code>MapperScannerConfigurer</code>并进行属性注入</li>
</ul>
</li>
</ul>
<hr>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/qq_31086797/article/details/124488829">https://blog.csdn.net/qq_31086797/article/details/124488829</a></li>
<li><a href="https://cofcool.github.io/tech/2018/06/20/mybatis-sourcecode-1#11-mapper%E6%89%AB%E6%8F%8F">https://cofcool.github.io/tech/2018/06/20/mybatis-sourcecode-1</a></li>
</ul>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
  </entry>
  <entry>
    <title>MyBatis学习笔记</title>
    <url>/2022/07/26/Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>MyBatis，原名 iBatis，Java常用ORM矿建，原来是Apache下的一个开源项目，2010 年迁移到 Google code，改名 MyBatis。2013 年迁移到 Github。</p>
<p><strong>官方文档</strong>： <a href="https://mybatis.org/mybatis-3/zh" title="mybatis – MyBatis 3 | Introduction">mybatis – MyBatis 3 | Introduction</a></p>
<h2 id="1-MyBatis使用步骤"><a href="#1-MyBatis使用步骤" class="headerlink" title="1 MyBatis使用步骤"></a>1 MyBatis使用步骤</h2><h3 id="1-1-导入依赖"><a href="#1-1-导入依赖" class="headerlink" title="1.1 导入依赖"></a>1.1 导入依赖</h3><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.26<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<span id="more"></span>

<h3 id="1-2-创建SqlSession"><a href="#1-2-创建SqlSession" class="headerlink" title="1.2 创建SqlSession"></a>1.2 创建SqlSession</h3><p>SqlSession是MyBatis用于执行Sql的关键API</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// MyBatis工具类：用于获取sqlSessionFactory -&gt; sqlSession</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisUtil</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 1.获取sqlSessionFactory对象</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取sqlSession对象</span></span><br><span class="line">    <span class="comment">// sqlSession中完全包含了面向数据库执行sql命令所需的所有方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title function_">getSqlSession</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession(<span class="literal">true</span>);   <span class="comment">// 设置为true表示默认开启事务</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="1-3-XML-配置"><a href="#1-3-XML-配置" class="headerlink" title="1.3 XML 配置"></a>1.3 XML 配置</h3><p><code>mybatis-config.xml</code> 核心配置文件</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">  <span class="string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"${driver}"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"${url}"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"${username}"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"${password}"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"org/mybatis/example/BlogMapper.xml"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>每一个mapper文件都需要在 <code>mybatis-config.xml</code> 中注册</p>
<h3 id="1-4-编写Mapper文件"><a href="#1-4-编写Mapper文件" class="headerlink" title="1.4 编写Mapper文件"></a>1.4 编写Mapper文件</h3><p>定义一个 Mapper 接口，执行数据库的查询操作</p>
<p><code>PersonMapper.xml</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonMapper</span> {</span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">getPersonById</span><span class="params">(Integer personId)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.qing.TestMyBatis.mapper.PersonMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getPersonById"</span> <span class="attr">resultType</span>=<span class="string">"com.qing.TestMyBatis.entity.Person"</span> <span class="attr">parameterType</span>=<span class="string">"Integer"</span>&gt;</span></span><br><span class="line">        select * from person where personId = #{personId}</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>namespace</code> 用于绑定一个 Mapper 接口，<code>id</code> 对应原来方法名</p>
<p><code>resultMap,resultType</code> 返回的结果集，前者返回多个，后者返回单个，值为实体类(集合也是)，注意路径</p>
<p><code>parameterType</code> 输入的参数类型，<code>#{personId}</code> 表示输入的参数，跟方法的参数名对应</p>
<p>原来需要实现 Mapper 接口，现在只需要在 xml 文件中配置即可</p>
<h2 id="2-万能-Map"><a href="#2-万能-Map" class="headerlink" title="2 万能 Map"></a>2 万能 Map</h2><p>给 Dao 传参的时候，如果 <code>parameterType</code> 是一个实体类，就必须要构造完整的对象作为参数，或者写不同的构造方法，Map类型很贴心的解决了这一难题。</p>
<p>简单应用</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addPerson</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtil.getSqlSession();</span><br><span class="line">    <span class="type">PersonMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(PersonMapper.class);</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"id"</span>, <span class="number">6</span>);    <span class="comment">// map中的键可以随意设置名字，可以不需要一一对应</span></span><br><span class="line">    map.put(<span class="string">"hometown"</span>, <span class="string">"shandong"</span>);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> mapper.save(map);</span><br><span class="line">    sqlSession.commit();</span><br><span class="line">    sqlSession.close();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"save"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">    insert bank.person(personId, address) VALUE (#{id},#{hometown})</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>当实体类的属性过多，可以考虑使用 map</p>
<h2 id="3-模糊查询"><a href="#3-模糊查询" class="headerlink" title="3 模糊查询"></a>3 模糊查询</h2><p>方式一：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">"getPersonLike"</span> resultType=<span class="string">"com.qing.TestMyBatis.entity.Person"</span>&gt;</span><br><span class="line">    select * from person where name like <span class="title function_">concat</span><span class="params">(<span class="string">'%'</span>,#{name},<span class="string">'%'</span>)</span></span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>方式二：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">List&lt;Person&gt; list = mapper.getPersonLike(<span class="string">"%q%"</span>);</span><br></pre></td></tr></tbody></table></figure>

<h2 id="4-MyBatis-XML配置文件"><a href="#4-MyBatis-XML配置文件" class="headerlink" title="4 MyBatis XML配置文件"></a>4 MyBatis XML配置文件</h2><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">  <span class="string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"${driver}"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"${url}"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"${username}"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"${password}"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"org/mybatis/example/BlogMapper.xml"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p><code>environment</code> 环境</p>
<p>MyBatis 可以配置成适应多种环境，但每个 SqlSessionFactory 实例只能选择一种环境</p>
</li>
<li><p><code>transactionManager</code> 事务管理器</p>
<p>MyBatis 默认事务管理器是 JDBC</p>
</li>
<li><p><code>dataSource</code> 数据源</p>
<p>使用 properties 属性来实现引用配置文件</p>
</li>
</ul>
<p>在实际开发中，我们一般会将数据库的配置单独房子啊<code>db.properties</code>中，然后引入到<code>mybatis-config.xml</code>中</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">driver=com.mysql.cj.jdbc.Driver</span><br><span class="line">url=jdbc:mysql://localhost:3306/{table_name}?useSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">username=xxxxx</span><br><span class="line">password=xxxxx</span><br></pre></td></tr></tbody></table></figure>

<p>然后在<code>mybatis-config.xml</code>添加：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"db.properties"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="4-2-类型别名"><a href="#4-2-类型别名" class="headerlink" title="4.2 类型别名"></a>4.2 类型别名</h3><p>类型别名是为 Java 类型设置的一个短的名字。它之和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">"com.qing.TestMyBatis.entity.Person"</span> <span class="attr">alias</span>=<span class="string">"Person"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>注意：</p>
<ul>
<li>XML 文件有严格的顺序</li>
<li>别名写在 <code>mybatis-config.xml</code> 中</li>
</ul>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.qing.TestMyBatis.entity"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>使用包名映射，可以扫描到包下的所有实体类，别名默认为类名首字母小写</p>
<h3 id="4-3-映射器"><a href="#4-3-映射器" class="headerlink" title="4.3 映射器"></a>4.3 映射器</h3><p>使用不同映射器进行注入绑定；</p>
<p>第一种：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"com/qing/TestMyBatis/mapper/PerMapper.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>第二种：使用 class 文件绑定注册</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"com.qing.TestMyBatis.mapper.PersonMapper"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>class属性的注意点：</p>
<ul>
<li>接口和他的 Mapper 文件必须同名</li>
<li>接口和他的 Mapper 配置文件必须在同一个包下</li>
</ul>
<p>第三种：使用包扫描进行注册绑定</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.qing.TestMyBatis.mapper.PersonMapper"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>注意点与第二种相同</p>
<h3 id="4-4-ResultMap"><a href="#4-4-ResultMap" class="headerlink" title="4.4 ResultMap"></a>4.4 ResultMap</h3><blockquote>
<p>ResultMap 元素是 MyBatis 中最重要最强大的元素</p>
</blockquote>
<p>当Mapper文件中实体类的属性名和表中的字段名不一致时，就会发生读取错误</p>
<p><strong>因为 MyBatis 是根据字段名去查找对应的<code>getter()</code>和<code>setter()</code>方法，找不到就会返回 null</strong></p>
<p><strong>解决属性名和字段名不一致的问题</strong></p>
<p>解决办法：</p>
<ol>
<li>给字段起别名</li>
<li><code>ResultMap</code></li>
</ol>
<p><code>ResultMap</code>：结果集映射</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"Person"</span> <span class="attr">type</span>=<span class="string">"com.qing.TestMyBatis.entity.Person"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"personId"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"address"</span> <span class="attr">property</span>=<span class="string">"add"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getPersonById"</span> <span class="attr">resultType</span>=<span class="string">"Person"</span> <span class="attr">parameterType</span>=<span class="string">"Integer"</span>&gt;</span></span><br><span class="line">    select * from person where personId = #{id}</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>需要注意，<code>ResultMap</code> 中的 <code>column</code> 和 <code>property</code> 不要用混了！！！**<code>column</code> 代表的是数据库列名，而 <code>property</code> 是实体类的属性名**</p>
<h2 id="7-日志"><a href="#7-日志" class="headerlink" title="7 日志"></a>7 日志</h2><p>如果数据库出现异常，我们需要排错。日志就是最好的助手</p>
<h3 id="7-1-STDOUT-LOGGING"><a href="#7-1-STDOUT-LOGGING" class="headerlink" title="7.1 STDOUT_LOGGING"></a>7.1 STDOUT_LOGGING</h3><p>MyBatis官方自带的日志框架。在核心配置文件中配置该日志：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"STDOUT_LOGGING"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="7-2-Log4j"><a href="#7-2-Log4j" class="headerlink" title="7.2 Log4j"></a>7.2 Log4j</h3><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line">#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码</span><br><span class="line">log4j.rootLogger=DEBUG,console,file</span><br><span class="line"></span><br><span class="line">#控制台输出的相关设置</span><br><span class="line">log4j.appender.console = org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.console.Target = System.out</span><br><span class="line">log4j.appender.console.Threshold=DEBUG</span><br><span class="line">log4j.appender.console.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.console.layout.ConversionPattern=[%c]-%m%n</span><br><span class="line"></span><br><span class="line">#文件输出的相关设置</span><br><span class="line">log4j.appender.file = org.apache.log4j.RollingFileAppender</span><br><span class="line">log4j.appender.file.File=./log/qing.log</span><br><span class="line">log4j.appender.file.MaxFileSize=10mb</span><br><span class="line">log4j.appender.file.Threshold=DEBUG</span><br><span class="line">log4j.appender.file.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n</span><br><span class="line"></span><br><span class="line">#日志输出级别</span><br><span class="line">log4j.logger.org.mybatis=DEBUG</span><br><span class="line">log4j.logger.java.sql=DEBUG</span><br><span class="line">log4j.logger.java.sql.Statement=DEBUG</span><br><span class="line">log4j.logger.java.sql.ResultSet=DEBUG</span><br><span class="line">log4j.logger.java.sql.PreparedStatement=DEBUG</span><br></pre></td></tr></tbody></table></figure>

<p>核心配置文件：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"Log4j"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src="/../images/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image_MkQjlNyeuN.png"></p>
<h2 id="8-使用注解开发"><a href="#8-使用注解开发" class="headerlink" title="8 使用注解开发"></a>8 使用注解开发</h2><p>注解使用条件：</p>
<ul>
<li>接口与 XML 配置文件必须同名</li>
<li>映射器使用 class</li>
</ul>
<p><code>@Param()</code></p>
<ul>
<li>基本类型前都要加上该注解</li>
<li>引用类型不用加</li>
</ul>
<p><strong>CRUD</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Select("select * from person where name = #{name}")</span></span><br><span class="line">List&lt;Person&gt; <span class="title function_">getPerByName</span><span class="params">(<span class="meta">@Param("name")</span>String name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Delete("delete from person where personId = #{id}")</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">deletePerson</span><span class="params">(<span class="meta">@Param("id")</span> <span class="type">int</span> id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Update("update Person set name = #{name},address = #{add} where personId = #{id}")</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">UpdatePerson</span><span class="params">(Person person)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Insert("insert into person(personId,name,address) value(#{id},#{name},#{add})")</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">addPerson</span><span class="params">(Person person)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>Tips</strong>：<code>#{}</code> 和 <code>${}</code> 的区别</p>
<p><code>#{}</code> 可以防止 sql 注入，能用则用，类似于 <code>PrepareStatement</code></p>
<p><code>${}</code> 不可以防止 sql 注入，早期使用</p>
<h2 id="9-多表查询"><a href="#9-多表查询" class="headerlink" title="9 多表查询"></a>9 多表查询</h2><p><strong>[回顾]MySQL 多表查询</strong></p>
<ul>
<li>子查询</li>
<li>联表查询</li>
</ul>
<p>MyBatis 多表查询</p>
<p><strong>关键字</strong></p>
<ul>
<li><code>column</code> 对应数据库中表的字段</li>
<li><code>property</code> 对应实体类中的属性</li>
<li><code>association</code> 当属性为引用类型时使用，表示对象<ul>
<li><code>javaType</code> 表示属性对应的引用类型</li>
</ul>
</li>
<li><code>collection</code> 当属性为集合时使用，表示集合<ul>
<li><code>ofType</code> 表示集合的泛型信息</li>
</ul>
</li>
</ul>
<p>这里引入两张表：<code>teacher&amp;student</code></p>
<p><img src="/../images/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image_46ggW4rKS0.png"></p>
<p>其中 <code>student</code> 的 id 与 <code>teacher</code> 的 id 互为外键</p>
<h3 id="9-1-多对一"><a href="#9-1-多对一" class="headerlink" title="9.1 多对一"></a>9.1 多对一</h3><p>实例引入：多个学生对应一个老师</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Teacher teacher;     <span class="comment">// 实体类中含有对象</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>按照查询嵌套处理(类似于子查询)</strong></p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getStudent"</span> <span class="attr">resultMap</span>=<span class="string">"sonSelect"</span>&gt;</span></span><br><span class="line">    select * from student</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"sonSelect"</span> <span class="attr">type</span>=<span class="string">"com.qing.TestMyBatis.entity.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"teacher"</span> <span class="attr">column</span>=<span class="string">"tid"</span> <span class="attr">select</span>=<span class="string">"getTeacher"</span> <span class="attr">javaType</span>=<span class="string">"com.qing.TestMyBatis.entity.Teacher"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getTeacher"</span> <span class="attr">resultType</span>=<span class="string">"com.qing.TestMyBatis.entity.Teacher"</span>&gt;</span></span><br><span class="line">    select * from teacher where id = #{tid}</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>按照结果嵌套处理(类似于联表查询)</strong></p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getStudent"</span> <span class="attr">resultMap</span>=<span class="string">"join"</span>&gt;</span></span><br><span class="line">    select s.id,s.name,s.tid,t.name tname,t.id tid from student s,teacher t where t.id = s.tid</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"join"</span> <span class="attr">type</span>=<span class="string">"com.qing.TestMyBatis.entity.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"teacher"</span> <span class="attr">javaType</span>=<span class="string">"com.qing.TestMyBatis.entity.Teacher"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"tname"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"tid"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>resultMap</code> 用于处理 teacher 属性</p>
<p>查询结果</p>
<p><img src="/../images/image-20240905155202694.png" alt="image-20240905155202694"></p>
<p>注意：列起别名一定之后 <code>column="tname"</code> 要用别名，列名冲突也可以使用别名解决</p>
<h3 id="9-2-一对多"><a href="#9-2-一对多" class="headerlink" title="9.2 一对多"></a>9.2 一对多</h3><p>实例引入：一个老师对多个学生</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    List&lt;Student&gt; students;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>按照结果嵌套处理(类似于联表查询)</strong></p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getTeacher"</span> <span class="attr">resultMap</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">    select s.id sid,s.name sname,t.id tid,t.name tname,s.tid stid</span><br><span class="line">    from student s,teacher t</span><br><span class="line">    where s.tid = t.id and  t.id = #{id}</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"map"</span> <span class="attr">type</span>=<span class="string">"Teacher"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"tid"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"tname"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"students"</span> <span class="attr">ofType</span>=<span class="string">"Student"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"sid"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"sname"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"stid"</span> <span class="attr">property</span>=<span class="string">"tid"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>resultMap</code> 用于处理 students 属性</p>
<p><strong>踩坑：column 中写列名或列名的别名，property 中写属性名，二者别搞混了！</strong></p>
<p><strong>按照查询嵌套处理(类似于子查询)</strong></p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getTeacher"</span> <span class="attr">resultMap</span>=<span class="string">"Teach"</span>&gt;</span></span><br><span class="line">    select * from teacher where id = #{id}</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"Teach"</span> <span class="attr">type</span>=<span class="string">"Teacher"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        通过查询到的teacher的id去查student的tid--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"students"</span> <span class="attr">javaType</span>=<span class="string">"ArrayList"</span> <span class="attr">select</span>=<span class="string">"getStudentByTeacherId"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getStudentByTeacherId"</span> <span class="attr">resultType</span>=<span class="string">"Student"</span>&gt;</span></span><br><span class="line">    select * from student where tid = #{tid}</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>注意 <code>collection</code> 中的 <code>javaType</code> 为<strong>ArrayList</strong></p>
<p>查询结果</p>
<p><img src="/../images/image-20240905155136614.png" alt="image-20240905155136614"></p>
<p>查询出来的 teacher 的 id 是异常的</p>
<p>总结：</p>
<ul>
<li><code>association</code> 表示一个复杂的联合，用于多对一；</li>
<li><code>collection</code> 表示一个复杂的集合，用于一对多；</li>
</ul>
<h2 id="10-动态-SQL"><a href="#10-动态-SQL" class="headerlink" title="10 动态 SQL"></a>10 动态 SQL</h2><p>什么是动态 SQL？动态 SQL 就是根据不同的条件生成不同的 SQL 语句</p>
<p>可以看一下官方解释：</p>
<blockquote>
<p>动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。</p>
</blockquote>
<p><strong>小技巧</strong>：<strong>UUID</strong></p>
<p>在实际业务中，数据库中表的 ID 并不是按顺序生成的，而是使用 UUID 随机生成的，这样就可以保证唯一性。因为若是按顺序生成，那么删掉一个数之后顺序就打乱了，这是 innodb慢的原因。</p>
<p><strong><code>mapUnderscoreToCamelCase</code></strong></p>
<p>是否开启自动驼峰命名规则映射，即从经典数据库列名到经典 Java 名的类似映射</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"mapUnderscoreToCamelCase"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="10-1-常用标签"><a href="#10-1-常用标签" class="headerlink" title="10.1 常用标签"></a>10.1 常用标签</h3><p>编写实体类</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Blog</span> {</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> views;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="10-2-IF"><a href="#10-2-IF" class="headerlink" title="10.2 IF"></a>10.2 IF</h3><p>需求：查找 Blog，将传入的参数全部用于查找</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryBlogIF"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span> <span class="attr">resultType</span>=<span class="string">"com.qing.TestMyBatis.entity.Blog"</span>&gt;</span></span><br><span class="line">    select * from blog where 1=1</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"title != null"</span>&gt;</span></span><br><span class="line">        and title = #{title}</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"author != null"</span>&gt;</span></span><br><span class="line">        and author = #{author}    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>优化</p>
<p>在上面的 sql 代码中，我们添加了一行 <code>where 1=1</code>，这看起来十分别扭，有没有更好的解决办法？</p>
<h3 id="10-3-where"><a href="#10-3-where" class="headerlink" title="10.3 where"></a>10.3 where</h3><p>MyBatis 提供了一个简单且适合大多数场景的解决办法：where 标签</p>
<blockquote>
<p><em>where</em> 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，<em>where</em> 元素也会将它们去除。</p>
</blockquote>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryBlogIF"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span> <span class="attr">resultType</span>=<span class="string">"com.qing.TestMyBatis.entity.Blog"</span>&gt;</span></span><br><span class="line">    select * from blog</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"title != null"</span>&gt;</span></span><br><span class="line">            and title = #{title}</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"author != null"</span>&gt;</span></span><br><span class="line">            and author = #{author}</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>与 <code>where</code> 作用类似的还有 <code>set</code> 关键字</p>
<h3 id="10-4-set"><a href="#10-4-set" class="headerlink" title="10.4 set"></a>10.4 set</h3><blockquote>
<p><em>set</em> 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）</p>
</blockquote>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateBlog"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">    update Blog</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"title != null"</span>&gt;</span></span><br><span class="line">            title = #{title},</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"author != null"</span>&gt;</span></span><br><span class="line">            author = #{author},</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"views!=null"</span>&gt;</span></span><br><span class="line">            views = #{views},</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where id = #{id}</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="10-5-trim"><a href="#10-5-trim" class="headerlink" title="10.5 trim"></a>10.5 trim</h3><p>trim 元素可以自定义类似于 <em>where</em> 元素功能的标签</p>
<p>和 <em>where</em> 元素等价的自定义 trim 元素为：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"WHERE"</span> <span class="attr">prefixOverrides</span>=<span class="string">"AND |OR "</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><em>prefixOverrides</em> 属性会忽略通过管道符分隔的文本序列（注意此例中的空格是必要的）。上述例子会移除所有 <em>prefixOverrides</em> 属性中指定的内容，并且插入 <em>prefix</em> 属性中指定的内容。</p>
<p>suffixOverrides 表示后缀</p>
<h3 id="10-6-choose，when，otherwise"><a href="#10-6-choose，when，otherwise" class="headerlink" title="10.6 choose，when，otherwise"></a>10.6 choose，when，otherwise</h3><p>类似于 Java 中的 switch</p>
<p>需求：传入了 “title” 就按 “title” 查找，传入了 “author” 就按 “author” 查找</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"testChoose"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span> <span class="attr">resultType</span>=<span class="string">"com.qing.TestMyBatis.entity.Blog"</span>&gt;</span></span><br><span class="line">    select * from blog</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"title != null"</span>&gt;</span></span><br><span class="line">                title like #{title}</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"author!=null"</span>&gt;</span></span><br><span class="line">                author like #{author}</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"views!=null"</span>&gt;</span></span><br><span class="line">                views = #{views}</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">                views &gt; 5000</span><br><span class="line">            <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>所谓的动态 SQL，本质还是 SQL 语句，只是我们可以在 sql 层面去执行一些逻辑代码</strong></p>
<h3 id="10-7-foreach"><a href="#10-7-foreach" class="headerlink" title="10.7 foreach"></a>10.7 foreach</h3><p>动态 SQL 的另一个常用操作需求是对一个集合进行遍历，通常在构建 IN 条件语句的时候</p>
<p>语法：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectPostIn"</span> <span class="attr">resultType</span>=<span class="string">"domain.blog.Post"</span>&gt;</span></span><br><span class="line">  SELECT *</span><br><span class="line">  FROM POST P</span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">collection</span>=<span class="string">"list"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">open</span>=<span class="string">"ID in ("</span> <span class="attr">separator</span>=<span class="string">","</span> <span class="attr">close</span>=<span class="string">")"</span> <span class="attr">nullable</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">          #{item}</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span> </span><br></pre></td></tr></tbody></table></figure>

<p>其中，<code>collection="list</code> 的 list 属性可以用 map 作映射</p>
<p>sql：<code>select * from blog where ID in (item1,item2,item3)</code></p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"TestForEach"</span> <span class="attr">resultType</span>=<span class="string">"com.qing.TestMyBatis.entity.Blog"</span>&gt;</span></span><br><span class="line">    select * from blog</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">open</span>=<span class="string">"ID in ("</span> <span class="attr">separator</span>=<span class="string">","</span> <span class="attr">close</span>=<span class="string">")"</span>&gt;</span></span><br><span class="line">            #{item}</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="10-8-SQL-片段"><a href="#10-8-SQL-片段" class="headerlink" title="10.8 SQL 片段"></a>10.8 SQL 片段</h3><p>SQL 片段就是将 sql 语句中的公共部分提取出来，方便复用</p>
<p>语法：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"if-title-author"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"title != null"</span>&gt;</span></span><br><span class="line">        and title = #{title}</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"author != null"</span>&gt;</span></span><br><span class="line">        and author = #{author}</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryBlogIF"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span> <span class="attr">resultType</span>=<span class="string">"com.qing.TestMyBatis.entity.Blog"</span>&gt;</span></span><br><span class="line">    select * from blog</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"if-title-author"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>注意事项：</p>
<ul>
<li>最好基于单表来定义 SQL 片段，因为某些关键字并不是所有表都支持</li>
<li>不要存在 where 标签</li>
</ul>
<h2 id="11-缓存"><a href="#11-缓存" class="headerlink" title="11 缓存"></a>11 缓存</h2><ul>
<li>什么是缓存<ul>
<li>存在内存中的临时数据</li>
<li>将用户经常查询的数据放在内存中，用户查询数据就可以直接从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题</li>
</ul>
</li>
<li>为什么要使用缓存<ul>
<li>减少和数据库的交互，减少系统开销。</li>
</ul>
</li>
<li>什么样的数据使用缓存<ul>
<li>经常查询并且不经常改变的数据</li>
</ul>
</li>
</ul>
<p>MyBatis缓存原理：</p>
<ol>
<li>先看二级缓存中有没有想要的数据</li>
<li>再去一级缓存中查找</li>
<li>再去数据库中查找</li>
</ol>
<h3 id="11-1-一级缓存"><a href="#11-1-一级缓存" class="headerlink" title="11.1 一级缓存"></a>11.1 一级缓存</h3><ul>
<li>一级缓存也叫本地缓存，与数据库同一次会话期间查询到的数据会放在本地缓存中</li>
<li>MyBatis 默认开启一级缓存</li>
</ul>
<p><strong>一次会话的作用域：开启 SqlSession 到关闭</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtil.getSqlSession();</span><br><span class="line">        <span class="type">BlogMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(BlogMapper.class);</span><br><span class="line">        <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> mapper.getBlog(<span class="string">"%MyBatis%"</span>);</span><br><span class="line">        System.out.println(blog);</span><br><span class="line"></span><br><span class="line">        <span class="type">Blog</span> <span class="variable">blog2</span> <span class="operator">=</span> mapper.getBlog(<span class="string">"%MyBatis%"</span>);</span><br><span class="line">        System.out.println(blog == blog2);</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/../images/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image_3PtJDMySrr.png"></p>
<p>上面的代码做了两次查询，但实际只从数据库中查了一次</p>
<p>缓存失效的情况：</p>
<ul>
<li>执行增删改操作，可能会改变原来的数据，所以一定会刷新缓存</li>
<li>查询不同的 Mapper.xml</li>
<li>手动清理缓存<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">sqlSession.clearCache();</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p>select 标签中还有一个属性 <code>useCache</code> 表示该元素是否使用缓存，<code>flushCache</code> 属性表示是否刷新缓存</p>
<h3 id="11-2-二级缓存"><a href="#11-2-二级缓存" class="headerlink" title="11.2 二级缓存"></a>11.2 二级缓存</h3><ul>
<li>二级缓存也称为全局缓存，是基于 <code>namespace</code> 级别的缓存</li>
<li>二级缓存的工作机制：<ul>
<li>一个会话查询一条数据，这个数据就会被放在一级缓存当中</li>
<li>如果当前会话关闭了，这个会话对应的一级缓存关闭，一级缓存中的数据就会保存到二级缓存当中</li>
<li>新的会话查询信息，就可以从二级缓存中获取内容</li>
</ul>
</li>
</ul>
<p>二级缓存的开启十分简单，只需要在 mapper.xml 中加上</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>这个简单语句的效果如下:</p>
<ul>
<li>映射语句文件中的所有 select 语句的结果将会被缓存。</li>
<li>映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。</li>
<li>缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存。</li>
<li>缓存不会定时进行刷新（也就是说，没有刷新间隔）。</li>
<li>缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。</li>
<li>缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。</li>
</ul>
<p>我们也可以自定义缓存</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span></span></span><br><span class="line"><span class="tag">  <span class="attr">eviction</span>=<span class="string">"FIFO"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">flushInterval</span>=<span class="string">"60000"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">size</span>=<span class="string">"512"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">readOnly</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>eviction</code> 表示清除策略，可用的清除策略有：</p>
<ul>
<li><code>LRU</code> – 最近最少使用：移除最长时间不被使用的对象。</li>
<li><code>FIFO</code> – 先进先出：按对象进入缓存的顺序来移除它们。</li>
<li><code>SOFT</code> – 软引用：基于垃圾回收器状态和软引用规则移除对象。</li>
<li><code>WEAK</code> – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。</li>
</ul>
<p><code>flushInterval</code> 表示刷新间隔，单位是毫秒</p>
<p><code>size</code> 表示缓存对象可以占用的内存资源</p>
<p><code>readOnly</code> 表示只读属性。只读的缓存会给所有调用者返回缓存对象的相同实例。 因此这些对象不能被修改。这就提供了可观的性能提升。而可读写的缓存会（通过序列化）返回缓存对象的拷贝。 速度上会慢一些，但是更安全，因此默认值是 false。</p>
<p><strong>注意：使用二级缓存的实体类必须实现 <strong><strong><code>Serializable</code></strong></strong> 接口</strong></p>
<p>来看下面一个例子：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtil.getSqlSession();</span><br><span class="line">        <span class="type">BlogMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(BlogMapper.class);</span><br><span class="line">        <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> mapper.getBlog(<span class="string">"%MyBatis%"</span>);</span><br><span class="line">        System.out.println(blog);</span><br><span class="line">        sqlSession.close();</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession1</span> <span class="operator">=</span> MyBatisUtil.getSqlSession();</span><br><span class="line">        <span class="type">BlogMapper</span> <span class="variable">mapper1</span> <span class="operator">=</span> sqlSession1.getMapper(BlogMapper.class);</span><br><span class="line">        <span class="type">Blog</span> <span class="variable">blog1</span> <span class="operator">=</span> mapper1.getBlog(<span class="string">"%MyBatis%"</span>);</span><br><span class="line">        System.out.println(blog1);</span><br><span class="line">        System.out.println(blog == blog1);</span><br><span class="line">        sqlSession1.close();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/../images/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image_rkuGDtwrcZ.png"></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test2</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtil.getSqlSession();</span><br><span class="line">        <span class="type">BlogMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(BlogMapper.class);</span><br><span class="line">        <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> mapper.getBlog(<span class="string">"%MyBatis%"</span>);</span><br><span class="line">        System.out.println(blog);</span><br><span class="line"></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession1</span> <span class="operator">=</span> MyBatisUtil.getSqlSession();</span><br><span class="line">        <span class="type">BlogMapper</span> <span class="variable">mapper1</span> <span class="operator">=</span> sqlSession1.getMapper(BlogMapper.class);</span><br><span class="line">        <span class="type">Blog</span> <span class="variable">blog1</span> <span class="operator">=</span> mapper1.getBlog(<span class="string">"%MyBatis%"</span>);</span><br><span class="line">        System.out.println(blog1);</span><br><span class="line">        System.out.println(blog == blog1);</span><br><span class="line">        sqlSession.close();</span><br><span class="line">        sqlSession1.close();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/../images/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image_EiFHuKpTUZ.png"></p>
<p>可以看到 Mybaitis 查询了两次，可见第一个 sqlSession 中的数据在会话关闭之前并没有被放进二级缓存中。并且，使用二级缓存查询出来的两个对象地址并不相等，而一级缓存是相等的。</p>
<p>总结：</p>
<ul>
<li>只要开启了二级缓存，在同一个 Mapper 下就有效</li>
<li>select 的数据会先放在一级缓存中，只有当一级缓存提交或者回滚时才会将数据放在二级缓存当中</li>
</ul>
<h2 id="12-常见-Bug"><a href="#12-常见-Bug" class="headerlink" title="12 常见 Bug"></a>12 常见 Bug</h2><p><img src="/../images/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6523C60C4B66B4DA1C512EF1397AA555_2DWEdkXWkb.gif"></p>
<p>遇到的报错：</p>
<p><img src="/../images/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image_459aZ2uDF4.png"></p>
<p>或 <code>java.lang.ExceptionInInitializerError</code> 初始化错误<strong>【最常见】</strong></p>
<p>原因：<strong>由于 Maven 的约定大于配置，xml 文件被过滤</strong></p>
<p>解决：在pom.xml中添加以下代码</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
  </entry>
  <entry>
    <title>Spingboot3.0 升级记录</title>
    <url>/2024/06/21/Spingboot3.0%20%E5%8D%87%E7%BA%A7%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<blockquote>
<p><strong>背景</strong>：在原来一个基于 Spring Boot 2.6.11 的项目中，引入了一个第三方库后，发现无法正常加载其自动装配的 Bean。经过排查，发现第三方库基于 Spring Boot 3.2.4 版本开发，存在依赖注入方式上的差异。为了兼容性，决定将原项目升级至 Spring Boot 3.2.4。鉴于 Spring Boot 3.0 的重大变化，本文详细记录了迁移过程中遇到的关键改动及解决方案。</p>
</blockquote>
<h2 id="Spring-Boot-3-0-主要改动"><a href="#Spring-Boot-3-0-主要改动" class="headerlink" title="Spring Boot 3.0 主要改动"></a>Spring Boot 3.0 主要改动</h2><p>以下是 Spring Boot 3.0 中最重要的变动：</p>
<ul>
<li><strong>最低 Java 版本要求</strong>：升级至 Java 17。</li>
<li><strong>移除内置配置</strong>：例如，MySQL 驱动等配置被移除，官方提供迁移工具协助升级：</li>
</ul>
<span id="more"></span>

<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-properties-migrator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>Jakarta EE 替代 Java EE</strong>：所有 <code>javax</code> 包被替换为 <code>jakarta</code> 包：</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">javax.persistence.*   -&gt; jakarta.persistence.*</span><br><span class="line">javax.validation.*    -&gt; jakarta.validation.*</span><br><span class="line">javax.servlet.*       -&gt; jakarta.servlet.*</span><br><span class="line">javax.annotation.*    -&gt; jakarta.annotation.*</span><br><span class="line">javax.transaction.*   -&gt; jakarta.transaction.*</span><br></pre></td></tr></tbody></table></figure>

<p>更多改动详情，参考官方文档：<a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Release-Notes">Spring Boot 3.0 发布说明</a></p>
<h2 id="项目迁移中发现的问题"><a href="#项目迁移中发现的问题" class="headerlink" title="项目迁移中发现的问题"></a>项目迁移中发现的问题</h2><h3 id="自定义-Starter-不兼容"><a href="#自定义-Starter-不兼容" class="headerlink" title="自定义 Starter 不兼容"></a>自定义 Starter 不兼容</h3><p>原版本中自定义 Starter 的方式为：在扫描类上使用 <code>@Configuration</code> 注解，并在 <code>META-INF/spring.factories</code> 文件中声明该扫描类：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">{{启动类路径}}</span><br></pre></td></tr></tbody></table></figure>

<p>新版中，自定义 Starter 应采用 <code>@AutoConfiguration</code> 注解，并在 <code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code> 文件中声明扫描类：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">{{启动类路径}}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Mybatis-兼容性问题"><a href="#Mybatis-兼容性问题" class="headerlink" title="Mybatis 兼容性问题"></a>Mybatis 兼容性问题</h3><p><img src="/../images/Secure2%20Image.png" alt="Secure2 Image"></p>
<p><strong>原因</strong>：Mybatis 旧版本与 Spring Boot 3.0 不兼容，需升级至 Mybatis 3.x 版本或更高。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Spring Environment体系</title>
    <url>/2024/06/21/Spring%20Environment%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><ul>
<li><code>PropertySource</code>：管理各种配置源的抽象类，即属性源</li>
<li><code>PropertySources</code>：用于统一管理和访问多个 PropertySource 实例</li>
<li><code>PropertyResolver</code>：通用属性解析<ul>
<li><code>Environment</code>：应用环境表示，提供属性访问，支持profile。</li>
<li><code>ConfigurablePropertyResolver</code>：属性解析配置，支持占位符解析。</li>
</ul>
</li>
<li><code>Binder</code>：配置绑定工具</li>
</ul>
<p>大致关系图：</p>
<p><img src="/../images/image_98WWM6BQwA.png"></p>
<span id="more"></span>

<blockquote>
<p>图片来自<a href="https://www.apolloconfig.com/#/zh/design/apollo-design?id=_31-%E5%92%8Cspring%E9%9B%86%E6%88%90%E7%9A%84%E5%8E%9F%E7%90%86" title="https://www.apolloconfig.com/#/zh/design/apollo-design?id=_31-和spring集成的原理">https://www.apolloconfig.com/#/zh/design/apollo-design?id=_31-和spring集成的原理</a></p>
</blockquote>
<h2 id="PropertySource"><a href="#PropertySource" class="headerlink" title="PropertySource"></a>PropertySource</h2><p><img src="/../images/image_eZgD5dC_Ym.png"></p>
<p>PropertySource是 Spring 框架中的一个关键抽象类，封装了一个属性源，属性源可以是一个<code>Map</code>、<code>Resource</code>对象、系统变量等等</p>
<h2 id="PropertySources"><a href="#PropertySources" class="headerlink" title="PropertySources"></a>PropertySources</h2><p><code>PropertySources</code> 是一个Spring框架中的接口，用于表示和管理一组属性源（<code>PropertySource</code>），这些属性源包含了应用程序环境中的配置数据。该接口提供了一系列方法来检索、添加、替换和删除这些属性源，允许开发者以统一的方式访问不同来源的配置信息，如环境变量、系统属性、配置文件等。</p>
<h2 id="PropertyResolver"><a href="#PropertyResolver" class="headerlink" title="PropertyResolver"></a>PropertyResolver</h2><p><code>PropertyResolver</code>是一个顶层接口，提供了一套灵活且强大的机制来处理应用程序配置属性。它定义了一些获取属性值，以及解析占位符的方法，用于访问和操纵来自各种源的属性值。</p>
<p><img src="/../images/image_TL0vgbMjbo.png"></p>
<h3 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h3><p><code>Environment</code> 接口是 Spring 框架中的一个核心部分，它提供了一个统一的方式来访问各种外部化的配置数据（继承自<code>PropertyResolver</code>）；支持配置文件（Profiles）的概念，可以在不同环境下进行条件性的配置，管理多个属性源。</p>
<p>可以看到<code>Environment</code>是继承了<code>PropertyResolver</code>接口的，<strong>只是增加了一些环境信息方法(profile)</strong></p>
<p>其中<code>Environment</code>实例关于<code>PropertyResolver</code>接口的方法是通过组合模式实现的，内部持有一个<code>PropertySourcesPropertyResolver</code>实例。</p>
<h3 id="ConfigurablePropertyResolver"><a href="#ConfigurablePropertyResolver" class="headerlink" title="ConfigurablePropertyResolver"></a>ConfigurablePropertyResolver</h3><p><code>ConfigurablePropertyResolver</code> 接口则增加了一些配置方法，在Spring中关键作用是提供灵活的配置属性解析。它支持<strong>占位符解析</strong>，并解析这些占位符为实际的配置值，提升配置的动态性和灵活性。</p>
<h3 id="其他实现"><a href="#其他实现" class="headerlink" title="其他实现"></a>其他实现</h3><ul>
<li><code>ConfigurableEnvironment</code>，增加了一些配置的方法，以及可以获取到内部的<code>PropertySource</code>列表。</li>
<li><code>StandardEnvironment</code>，非web上下文使用的环境实例。</li>
<li><code>StandardServletEnvironment</code>，web上下文使用的环境实例。</li>
</ul>
<h2 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h2><p>Spring提供了一个很强大的工具类<code>Binder</code>，可以将<code>Environment</code>或者<code>ConfigurationPropertySource</code>中的属性绑定到一个Java对象中，且支持占位符，类型转换，宽松绑定。Binder的使用可以参考</p>
<h3 id="ConfigurationProperties实现原理"><a href="#ConfigurationProperties实现原理" class="headerlink" title="@ConfigurationProperties实现原理"></a>@ConfigurationProperties实现原理</h3><p><code>@ConfigurationProperties</code>注解在Spring Boot中常用来绑定属性到Java Bean中，不难猜出内部原理便是使用上面所介绍的<code>Binder</code>类来实现的。</p>
<p>使用该注解时常常搭配<code>@EnableConfigurationProperties</code>注解一起使用，<code>@EnableConfigurationProperties</code>的主要作用就是注册了一个<code>ConfigurationPropertiesBindingPostProcessor</code></p>
<p>绑定的核心逻辑在<code>ConfigurationPropertiesBindingPostProcessor</code>中</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException {</span><br><span class="line">  <span class="keyword">if</span> (!hasBoundValueObject(beanName)) {</span><br><span class="line">    bind(ConfigurationPropertiesBean.get(<span class="built_in">this</span>.applicationContext, bean, beanName));</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> bean;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(ConfigurationPropertiesBean bean)</span> {</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    <span class="built_in">this</span>.binder.bind(bean);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConfigurationPropertiesBindException</span>(bean, ex);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">BindResult&lt;?&gt; bind(ConfigurationPropertiesBean propertiesBean) {</span><br><span class="line">    Bindable&lt;?&gt; target = propertiesBean.asBindTarget();</span><br><span class="line">    <span class="type">ConfigurationProperties</span> <span class="variable">annotation</span> <span class="operator">=</span> propertiesBean.getAnnotation();</span><br><span class="line">    <span class="type">BindHandler</span> <span class="variable">bindHandler</span> <span class="operator">=</span> getBindHandler(target, annotation);</span><br><span class="line">     <span class="keyword">return</span> getBinder().bind(annotation.prefix(), target, bindHandler); </span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<p>关键点在于Binder将<code>ConfigurationProperties</code>的前缀和实际的Bean对象绑定在了一起，实现配置的注入</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="https://www.cnblogs.com/wt20/p/17588895.html" title="https://www.cnblogs.com/wt20/p/17588895.html">https://www.cnblogs.com/wt20/p/17588895.html</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2023/06/18/230618-SpringBoot%E4%B9%8B%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%B1%9E%E6%80%A7%E7%BB%91%E5%AE%9ABinder/" title="https://spring.hhui.top/spring-blog/2023/06/18/230618-SpringBoot之编程式属性绑定Binder/">https://spring.hhui.top/spring-blog/2023/06/18/230618-SpringBoot之编程式属性绑定Binder/</a></li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring Environment</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 事务体系</title>
    <url>/2024/09/08/Spring-%E4%BA%8B%E5%8A%A1%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<p>最近了解到，Spring中的事务是由AOP实现的（当然这里说的是声明式事务），至于里面具体的逻辑是怎么样的，今天花了一天的时间看代码，总算弄是明白了大概流程😎，至于里面很多技术细节还没去深挖，先这样吧╮(╯_╰)╭</p>
<h2 id="Spring-事务相关的API"><a href="#Spring-事务相关的API" class="headerlink" title="Spring 事务相关的API"></a>Spring 事务相关的API</h2><p>先看看概念：</p>
<p><strong>事务操作相关的API</strong></p>
<ul>
<li><code>@Transactional</code> - Spring事务注解</li>
<li><code>@EnableTranSactionManagement</code> - Spring事务模块驱动</li>
</ul>
<p><strong>事务抽象相关的API</strong></p>
<ul>
<li><strong><code>PlatformTransactionManager</code></strong> - Spring平台事务管理器，负责执行事务的关键类</li>
<li><code>TransactionStatus</code> - Spring事务状态</li>
<li><code>TransactionDefinition</code> - Spring事务定义</li>
<li><strong><code>ProxyTransactionManagementConfiguration</code></strong> - Spring事务代理配置类</li>
</ul>
<p><strong>AOP相关的API</strong></p>
<ul>
<li><strong><code>BeanFactoryTransactionAttrubuteSourceAdvisor</code></strong> - Spring事务PointcutAdvisor实现</li>
<li><strong><code>TransactionInterceptor</code></strong> - 事务执行切面，负责事务执行的核心类</li>
<li><strong><code>TransactionAttributeSource</code></strong> - Spring事务属性源</li>
<li><strong><code>TransactionAnnotationParser</code></strong> - 解析器，负责扫描并解析所有的带有@Transactional的方法或类，并将数据封装为<code>TransactionAttributeSource</code></li>
<li><code>TransactionSynchronizationAdapter</code> - 事务同步器，感知事务是成功还是失败，在事务提交前后通知，这个在做一些需要监听事务状态的业务需求估计会比较有用吧🤨</li>
</ul>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p><code>ProxyTransactionManagementConfiguration</code>是通过<code>@EnableTranSactionManagement</code>注入的核心配置类，内部实际注册了三个Bean，这三个Bean其实是AOP的三部分：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line"><span class="meta">@ImportRuntimeHints(TransactionRuntimeHints.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTransactionManagementConfiguration</span> <span class="keyword">extends</span> <span class="title class_">AbstractTransactionManagementConfiguration</span> {</span><br><span class="line"></span><br><span class="line">  <span class="comment">// AOP的PointcutAdvisor</span></span><br><span class="line">  <span class="comment">// PointcutAdvisor = PointCut + Advice</span></span><br><span class="line">  <span class="meta">@Bean(name = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME)</span></span><br><span class="line">  <span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line">  <span class="keyword">public</span> BeanFactoryTransactionAttributeSourceAdvisor <span class="title function_">transactionAdvisor</span><span class="params">(</span></span><br><span class="line"><span class="params">      TransactionAttributeSource transactionAttributeSource, TransactionInterceptor transactionInterceptor)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="type">BeanFactoryTransactionAttributeSourceAdvisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanFactoryTransactionAttributeSourceAdvisor</span>();</span><br><span class="line">    advisor.setTransactionAttributeSource(transactionAttributeSource);</span><br><span class="line">    advisor.setAdvice(transactionInterceptor);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.enableTx != <span class="literal">null</span>) {</span><br><span class="line">      advisor.setOrder(<span class="built_in">this</span>.enableTx.&lt;Integer&gt;getNumber(<span class="string">"order"</span>));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> advisor;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PointCut</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line">  <span class="keyword">public</span> TransactionAttributeSource <span class="title function_">transactionAttributeSource</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// Accept protected @Transactional methods on CGLIB proxies, as of 6.0.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnnotationTransactionAttributeSource</span>(<span class="literal">false</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Advice</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line">  <span class="keyword">public</span> TransactionInterceptor <span class="title function_">transactionInterceptor</span><span class="params">(TransactionAttributeSource transactionAttributeSource)</span> {</span><br><span class="line">    <span class="type">TransactionInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionInterceptor</span>();</span><br><span class="line">    interceptor.setTransactionAttributeSource(transactionAttributeSource);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.txManager != <span class="literal">null</span>) {</span><br><span class="line">      interceptor.setTransactionManager(<span class="built_in">this</span>.txManager);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> interceptor;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中<code>BeanFactoryTransactionAttributeSourceAdvisor</code>负责将<code>PointCut</code>和<code>Advice</code>注入到AOP中，没有什么复杂的逻辑</p>
<p>下面介绍一下<code>TransactionAttributeSource</code>和<code>TransactionInterceptor</code></p>
<h3 id="TransactionAttributeSource"><a href="#TransactionAttributeSource" class="headerlink" title="TransactionAttributeSource"></a>TransactionAttributeSource</h3><p>上面注入了一个<code>AnnotationTransactionAttributeSource</code>，我们来看看这个Bean做了什么</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 添加解析器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationTransactionAttributeSource</span><span class="params">(<span class="type">boolean</span> publicMethodsOnly)</span> {</span><br><span class="line">  <span class="built_in">this</span>.publicMethodsOnly = publicMethodsOnly;</span><br><span class="line">  <span class="keyword">if</span> (jta12Present || ejb3Present) {</span><br><span class="line">    <span class="built_in">this</span>.annotationParsers = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">this</span>.annotationParsers.add(<span class="keyword">new</span> <span class="title class_">SpringTransactionAnnotationParser</span>());</span><br><span class="line">    <span class="keyword">if</span> (jta12Present) {</span><br><span class="line">      <span class="built_in">this</span>.annotationParsers.add(<span class="keyword">new</span> <span class="title class_">JtaTransactionAnnotationParser</span>());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (ejb3Present) {</span><br><span class="line">      <span class="built_in">this</span>.annotationParsers.add(<span class="keyword">new</span> <span class="title class_">Ejb3TransactionAnnotationParser</span>());</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span> {</span><br><span class="line">    <span class="built_in">this</span>.annotationParsers = Collections.singleton(<span class="keyword">new</span> <span class="title class_">SpringTransactionAnnotationParser</span>());</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> TransactionAttribute <span class="title function_">findTransactionAttribute</span><span class="params">(Method method)</span> {</span><br><span class="line">  <span class="keyword">return</span> determineTransactionAttribute(method);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析方法上的Transactional注解</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> TransactionAttribute <span class="title function_">determineTransactionAttribute</span><span class="params">(AnnotatedElement element)</span> {</span><br><span class="line">  <span class="keyword">for</span> (TransactionAnnotationParser parser : <span class="built_in">this</span>.annotationParsers) {</span><br><span class="line">    <span class="type">TransactionAttribute</span> <span class="variable">attr</span> <span class="operator">=</span> parser.parseTransactionAnnotation(element);</span><br><span class="line">    <span class="keyword">if</span> (attr != <span class="literal">null</span>) {</span><br><span class="line">      <span class="keyword">return</span> attr;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>所以这个类的作用大概就是解析所有方法上的Transactional注解然后封装为<code>TransactionAttributeSource</code>，最后担任<code>PointCut</code>角色</p>
<h3 id="TransactionInterceptor"><a href="#TransactionInterceptor" class="headerlink" title="TransactionInterceptor"></a>TransactionInterceptor</h3><p>执行事务的核心方法，这个方法很长很复杂没有耐心看了🥲，看了网上的博客大概是这么说的：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">invokeWithinTransaction</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass,</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> InvocationCallback invocation)</span> <span class="keyword">throws</span> Throwable {</span><br><span class="line"></span><br><span class="line">  <span class="type">TransactionAttributeSource</span> <span class="variable">tas</span> <span class="operator">=</span> getTransactionAttributeSource();</span><br><span class="line">  <span class="keyword">final</span> <span class="type">TransactionAttribute</span> <span class="variable">txAttr</span> <span class="operator">=</span> (tas != <span class="literal">null</span> ? tas.getTransactionAttribute(method, targetClass) : <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">final</span> <span class="type">PlatformTransactionManager</span> <span class="variable">tm</span> <span class="operator">=</span> determineTransactionManager(txAttr);</span><br><span class="line">  <span class="keyword">final</span> <span class="type">String</span> <span class="variable">joinpointIdentification</span> <span class="operator">=</span> methodIdentification(method, targetClass, txAttr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取事务</span></span><br><span class="line">  <span class="type">TransactionInfo</span> <span class="variable">txInfo</span> <span class="operator">=</span> createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line">  <span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    <span class="comment">//执行目标方法crud</span></span><br><span class="line">    retVal = invocation.proceedWithInvocation();</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">    <span class="comment">// crud执行异常回滚事务</span></span><br><span class="line">    completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">finally</span> {</span><br><span class="line">    cleanupTransactionInfo(txInfo);</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//提交事务</span></span><br><span class="line">  commitTransactionAfterReturning(txInfo);</span><br><span class="line">  <span class="keyword">return</span> retVal;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中调用了<code>PlatformTransactionManager</code>去执行物理事务，是负责执行增强任务的<code>Advice</code></p>
<h3 id="PlatformTransactionManager"><a href="#PlatformTransactionManager" class="headerlink" title="PlatformTransactionManager"></a>PlatformTransactionManager</h3><p>PlatformTransactionManager是Spring对于事务模型的抽象，它代表事务的整体执行过程。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PlatformTransactionManager</span> {</span><br><span class="line">    <span class="comment">// 获取事务的执行状态</span></span><br><span class="line">    TransactionStatus <span class="title function_">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">    <span class="comment">// 提交事务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">    <span class="comment">// 回滚事务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="其他的一些知识点"><a href="#其他的一些知识点" class="headerlink" title="其他的一些知识点"></a>其他的一些知识点</h2><h3 id="Spring中事务的传播行为"><a href="#Spring中事务的传播行为" class="headerlink" title="Spring中事务的传播行为"></a>Spring中事务的传播行为</h3><p>Spring中事务的传播模式有以下几种：</p>
<p><img src="https://secure2.wostatic.cn/static/61zGW88xH5tJp295rNnPZK/image.png?auth_key=1725729579-qRD23BugtXZMZyh2zXT4X5-0-89b62df33d491f188b7e4a2ae5843ac0"></p>
<p>事务分为逻辑事务和物理事务：</p>
<ul>
<li>逻辑事务是指代码中事务的操作，即表面的业务逻辑</li>
<li>物理事务是数据库层面的操作，即从获取数据库连接到数据库执行事务完毕整个过程</li>
</ul>
<h3 id="事务失效的几种场景"><a href="#事务失效的几种场景" class="headerlink" title="事务失效的几种场景"></a>事务失效的几种场景</h3><p>这个部分也是根据网上的博客总结出来的😎</p>
<ol>
<li>方法为<code>private</code>：事务代理类要求被代理方法必须是<code>public</code>的，否则不进行代理<ol>
<li>从 Spring 6.0 开始，<code>protected</code>方法可以被 CGLIB 代理</li>
</ol>
</li>
<li>方法用<code>final</code>修饰：Spring事务底层是基于AOP的，被final修饰的方法无法被代理类重写</li>
<li>方法内部调用：同理，代理类根据<code>@Transactional</code>代理方法，方法内部调用会绕过代理</li>
<li>多线程调用、异常捕获不对（默认捕获<code>RunningTimeError</code>）、未被Spring管理等等</li>
</ol>
<hr>
<p>参考：</p>
<ul>
<li><a href="https://juejin.cn/post/7106158883055353870">深入浅出Spring事务的实现原理</a></li>
<li><a href="https://juejin.cn/post/7003949263281455112?share_token=1c6f49e0-3d47-4380-af8d-de4d2b72a783">Spring事务不生效的12中场景</a></li>
<li><a href="https://juejin.cn/post/7212142580708802615?from=search-suggest">女朋友不懂Spring事务原理，今天给她讲清楚了！</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1808649">从 AbstractPointcutAdvisor 开始： Spring AOP 之 Advisor、PointcutAdvisor 介绍</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>SpringBoot实现GitHub第三方登录</title>
    <url>/2023/05/14/SpringBoot%E5%AE%9E%E7%8E%B0GitHub%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<h2 id="Github登录原理"><a href="#Github登录原理" class="headerlink" title="Github登录原理"></a>Github登录原理</h2><p>Github登录的原理是借助OAuth 2.0协议来实现，具体的流程是：首先用户被重定向到GitHub的授权页面，证明自己的身份并同意授权后获取一个授权码，然后客户端拿着授权码请求授权服务器获得一个Access Token</p>
<p>之后客户端就可以通过Access Token来与资源服务器进行交互，这个token是长期有效的，也可以服务端自行留存。服务端拿着这个token就可以请求GitHub并获得用户信息</p>
<p><img src="/../images/SpringBoot%E5%AE%9E%E7%8E%B0GitHub%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/image_u3kxu-6By6.png"></p>
<p>我们常见的单点登录平台，如Casdoor、logto等等，他们会在保存授权后获得的Access Token，并作为授权服务器提供服务。利用这些平台我们能更方便的管理账号系统，不用再去对不同的第三方平台做不同的授权实</p>
<span id="more"></span>

<p><img src="/../images/SpringBoot%E5%AE%9E%E7%8E%B0GitHub%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/2760332-20220412195835959-694117279_q0bggeLtdi.gif"></p>
<h1 id="SpringBoot实现GitHub登录"><a href="#SpringBoot实现GitHub登录" class="headerlink" title="SpringBoot实现GitHub登录"></a>SpringBoot实现GitHub登录</h1><p>首先，你需要在GitHub上创建一个<a href="https://github.com/settings/applications/new" title="Application">Application</a>，将我们的应用注册到GitHub</p>
<p><img src="/../images/SpringBoot%E5%AE%9E%E7%8E%B0GitHub%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/image_FUKgEjhTXM.png"></p>
<p>注意这个回调地址，它是用户授权后GitHub重定向用户的地址</p>
<p>注册完成后，将<code>client_id</code>和<code>client_secret</code>配置到SpringBoot应用中：</p>
<p><img src="/../images/SpringBoot%E5%AE%9E%E7%8E%B0GitHub%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/image_qoOfOfER8X.png"></p>
<p>下面是Demo：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(path = "oauth")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OAuthController</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value("${github.client.id}")</span></span><br><span class="line">    <span class="keyword">private</span> String clientId;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Value("${github.client.secret}")</span></span><br><span class="line">    <span class="keyword">private</span> String clientSecret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跳转到授权页面</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(path = "github")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">auth</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="type">String</span> <span class="variable">authorizeUri</span> <span class="operator">=</span> <span class="string">"https://github.com/login/oauth/authorize"</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">redirectUri</span> <span class="operator">=</span> <span class="string">"http://localhost:8080/oauth/redirect"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> authorizeUri </span><br><span class="line">                + <span class="string">"?client_id="</span> + githubClientProperties.getClientId()</span><br><span class="line">                + <span class="string">"&amp;redirect_uri="</span> + redirectUri;</span><br><span class="line">        response.sendRedirect(url);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Github回调接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestToken 授权码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(path = "redirect")</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleRedirect</span><span class="params">(<span class="meta">@RequestParam("code")</span> String requestToken, HttpServletResponse response)</span> {</span><br><span class="line">        <span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取Token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">tokenUrl</span> <span class="operator">=</span> <span class="string">"https://github.com/login/oauth/access_token"</span></span><br><span class="line">                + <span class="string">"?client_id="</span> + githubClientProperties.getClientId()</span><br><span class="line">                + <span class="string">"&amp;client_secret="</span> + githubClientProperties.getClientSecret()</span><br><span class="line">                + <span class="string">"&amp;code="</span> + requestToken;</span><br><span class="line"></span><br><span class="line">        <span class="type">AccessTokenResponse</span> <span class="variable">tokenResponse</span> <span class="operator">=</span> restTemplate.postForObject(tokenUrl, <span class="literal">null</span>, AccessTokenResponse.class);</span><br><span class="line">        <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> tokenResponse.getAccessToken();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取用户信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">apiUrl</span> <span class="operator">=</span> <span class="string">"https://api.github.com/user"</span>;</span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">        headers.set(<span class="string">"Authorization"</span>, <span class="string">"Bearer "</span> + accessToken);</span><br><span class="line">        HttpEntity&lt;String&gt; entity = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;&gt;(<span class="string">"parameters"</span>, headers);</span><br><span class="line">        ResponseEntity&lt;String&gt; resp = restTemplate.exchange(apiUrl, HttpMethod.GET, entity, String.class);</span><br><span class="line">        <span class="type">String</span> <span class="variable">userData</span> <span class="operator">=</span> resp.getBody();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将token返回给客户端</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">githubToken</span> <span class="operator">=</span> newCookie(<span class="string">"github_token"</span>, accessToken, <span class="string">"/"</span>, COOKIE_AGE);</span><br><span class="line">        response.addCookie(githubToken);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ResVo.ok(userData);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Cookie <span class="title function_">newCookie</span><span class="params">(String key, String session, String path, <span class="type">int</span> maxAge)</span> {</span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(key, session);</span><br><span class="line">        cookie.setPath(path);</span><br><span class="line">        cookie.setMaxAge(maxAge);</span><br><span class="line">        <span class="keyword">return</span> cookie;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<p>相关文档：</p>
<ul>
<li><a href="https://docs.github.com/zh/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps#web-application-flow" title="https://docs.github.com/zh/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps#web-application-flow">https://docs.github.com/zh/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps#web-application-flow</a></li>
<li><a href="https://casdoor.org/docs/overview" title="https://casdoor.org/docs/overview">https://casdoor.org/docs/overview</a></li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>oauth</tag>
      </tags>
  </entry>
  <entry>
    <title>✍🏻 Spring源码阅读记录</title>
    <url>/2024/05/31/Spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<blockquote>
<p>标记的表示已读</p>
</blockquote>
<h1 id="Spring-Core"><a href="#Spring-Core" class="headerlink" title="Spring Core"></a>Spring Core</h1><h2 id="资源加载与访问"><a href="#资源加载与访问" class="headerlink" title="资源加载与访问"></a>资源加载与访问</h2><ul>
<li>Resource：抽象接口，表示文件、类路径等，用于访问不同来源的资源。</li>
<li>ResourceLoader：资源获取核心接口，实现统一加载不同位置资源的策略。</li>
<li>ResourcePatternResolver：资源模式解析接口，用于灵活加载应用中的多种资源。</li>
<li>DocumentLoader：XML文档加载解析核心接口，支持后台自动配置Spring应用。</li>
</ul>
<h2 id="元数据与过滤"><a href="#元数据与过滤" class="headerlink" title="元数据与过滤"></a>元数据与过滤</h2><ul>
<li>MetadataReader：类元数据获取核心，支持组件扫描、条件化注解、AOP等高级功能。</li>
<li>AnnotationMetadata：动态获取和操作运行时类注解信息。</li>
<li>TypeFilter：组件扫描时自定义类筛选，支持复杂条件和精确过滤。</li>
<li>Condition：条件判断，决定Bean创建和配置的灵活机制。</li>
</ul>
<h2 id="验证、数据绑定和类型转换"><a href="#验证、数据绑定和类型转换" class="headerlink" title="验证、数据绑定和类型转换"></a>验证、数据绑定和类型转换</h2><ul>
<li>Validator：提供自定义数据验证逻辑，确保模型对象满足业务规则。</li>
<li>PropertyEditor：自定义JavaBean属性的转换逻辑，处理属性类型转换。</li>
<li>Converter：用于不同类型间的转换，定义简单的源至目标类型转换规则。</li>
<li>ConverterFactory：创建针对特定源类型的转换器，用于类型转换。</li>
<li>GenericConverter：更复杂的转换器，支持多种源和目标类型转换。</li>
<li>ConditionalConverter：根据条件选择是否执行转换的转换器。</li>
<li>ConversionService：提供统一的类型转换服务接口，管理转换器。</li>
<li>Printer：用于将对象格式化为文本，专注于格式化输出。</li>
<li>Parser：用于将文本解析为对象，专注于解析逻辑。</li>
</ul>
<h2 id="Spring-表达式语言（SpEL）"><a href="#Spring-表达式语言（SpEL）" class="headerlink" title="Spring 表达式语言（SpEL）"></a>Spring 表达式语言（SpEL）</h2><ul>
<li>ExpressionParser: 解析字符串形式的 SpEL 表达式，创建并返回 Expression 实例。</li>
<li>Expression: 对表达式字符串进行求值的功能，支持类型转换、获取原始字符串等操作。</li>
<li>EvaluationContext: 管理SpEL表达式的上下文信息。</li>
<li>PropertyAccessor: 用于读取和写入对象的属性，可用于实现自定义的属性访问逻辑。</li>
<li>ConstructorResolver: 解析构造函数确定bean的实例化方式。</li>
<li>MethodResolver: 解析类方法，确保正确调用，处理重载和参数匹配。</li>
<li>BeanResolver: 解析bean定义，包括依赖、属性设置，实例化并返回。</li>
<li>TypeLocator: 动态查找类，返回Class对象，在表达式解析、类型转换等。</li>
<li>TypeConverter: 类型转换功能，将表达式中的数据从一种类型转换为另一种类型。</li>
<li>TypeComparator: 类型比较功能，定义了比较两个对象是否相等的方法。</li>
<li>OperatorOverloader: 运算符重载功能，对表达式中的运算符进行自定义操作的方法。</li>
</ul>
<h2 id="Bean定义与注册"><a href="#Bean定义与注册" class="headerlink" title="Bean定义与注册"></a>Bean定义与注册</h2><ul>
<li><u>BeanDefinition</u>：详细描述Bean，支持依赖注入、AOP、作用域控制等核心功能。</li>
<li>BeanDefinitionHolder：管理和操作BeanDefinition的关键类。</li>
<li><u>BeanDefinitionRegistry</u>：Bean定义注册管理关键接口，处理Bean元数据。</li>
</ul>
<h2 id="Bean定义读取与扫描"><a href="#Bean定义读取与扫描" class="headerlink" title="Bean定义读取与扫描"></a>Bean定义读取与扫描</h2><ul>
<li>XmlBeanDefinitionReader：加载解析XML配置，构建IOC容器，注册Bean定义。</li>
<li>PropertiesBeanDefinitionReader：属性文件加载，解析为Bean定义。</li>
<li>GroovyBeanDefinitionReader：Groovy脚本解析为Bean定义。</li>
<li>AnnotatedBeanDefinitionReader：注解配置，自动扫描注册Spring组件，简化Bean定义配置。</li>
<li><u>ClassPathBeanDefinitionScanner</u>：类路径扫描注册Spring Bean，支持自动装配。</li>
</ul>
<h2 id="Bean工厂"><a href="#Bean工厂" class="headerlink" title="Bean工厂"></a>Bean工厂</h2><ul>
<li>BeanFactory：Spring的核心接口，提供对Bean的配置、创建、管理的基本功能。</li>
<li>ListableBeanFactory：支持按类型获取Bean的集合。</li>
<li>HierarchicalBeanFactory：支持父子容器关系，实现Bean定义的层次结构。</li>
<li>ConfigurableBeanFactory：提供对BeanFactory配置的扩展，如属性编辑器、作用域等。</li>
<li>AutowireCapableBeanFactory：Bean创建、初始化、注入、销毁的核心功能接口。</li>
<li><u>ConfigurableListableBeanFactory</u>：支持配置和列表操作的可配置Bean工厂接口。</li>
</ul>
<h2 id="容器上下文"><a href="#容器上下文" class="headerlink" title="容器上下文"></a>容器上下文</h2><ul>
<li>ClassPathXmlApplicationContext：类路径（classpath）加载 XML 配置文件的上下文。</li>
<li>AnnotationConfigApplicationContext：注解配置类中加载配置信息的上下文。</li>
<li>GenericApplicationContext：支持多种配置方式，XML、注解、手动注册的上下文。</li>
</ul>
<h2 id="Bean定义导入与组合"><a href="#Bean定义导入与组合" class="headerlink" title="Bean定义导入与组合"></a>Bean定义导入与组合</h2><ul>
<li><u>ImportBeanDefinitionRegistrar</u>：运行时动态注册 Bean，实现灵活配置，扩展配置类功能。</li>
<li>ImportSelector：运行时动态导入配置类，实现条件选择和灵活配置。</li>
<li>DeferredImportSelector：运行时动态导入配置，支持条件选择和按组别延迟加载。</li>
</ul>
<h2 id="Bean生命周期"><a href="#Bean生命周期" class="headerlink" title="Bean生命周期"></a>Bean生命周期</h2><ul>
<li><u>Bean的定义注册过程</u>：加载与解析配置文件，注册解析Bean定义，类名、作用域、属性等。</li>
<li><u>Bean的初始化过程</u>：实例化、属性注入、Aware回调、后置处理器、初始化方法调用。</li>
<li><u>Bean的依赖解析过程</u>：声明依赖，查找依赖，注入依赖，处理循环依赖，延迟依赖解析。</li>
<li><u>Bean的销毁过程</u>：销毁方法调用，接口回调，后处理清理，通知触发，GC回收资源。</li>
</ul>
<h2 id="属性解析和环境配置"><a href="#属性解析和环境配置" class="headerlink" title="属性解析和环境配置"></a>属性解析和环境配置</h2><blockquote>
<p><a href="/2024/06/21/Spring%20Environment%E4%BD%93%E7%B3%BB/">Spring Environment体系</a></p>
</blockquote>
<ul>
<li><u>PropertySource</u>：管理各种配置源的抽象类，支持灵活地加载和访问应用配置。</li>
<li><u>PropertySources</u>：用于统一管理和访问多个 PropertySource 实例，简化配置数据的处理。</li>
<li><u>PropertyResolver</u>：通用属性解析，获取配置值，处理属性缺失，简便灵活。</li>
<li><u>ConfigurablePropertyResolver</u>：属性解析配置，占位符设置，适应不同配置需求。</li>
<li><u>Environment</u>：应用环境表示，提供属性访问，支持配置文件，实现动态配置。</li>
<li><u>ConfigurableEnvironment</u>：动态配置应用环境，激活、默认配置，提升应用灵活性。</li>
</ul>
<h2 id="Bean初始化与扩展点"><a href="#Bean初始化与扩展点" class="headerlink" title="Bean初始化与扩展点"></a>Bean初始化与扩展点</h2><ul>
<li><u>InitializingBean</u>：提供Bean初始化时执行自定义逻辑的接口。</li>
<li>DisposableBean：定义Bean销毁前执行清理操作的接口。</li>
<li><u>BeanDefinitionRegistryPostProcessor</u>：在容器启动时，对BeanDefinition动态修改或添加。</li>
<li><u>BeanFactoryPostProcessor</u>：在Bean实例化前，对BeanFactory进行全局修改或配置。</li>
<li><u>BeanPostProcessor</u>：在Bean初始化前后，进行自定义处理，可影响所有Bean。</li>
<li>InstantiationAwareBeanPostProcessor：提供更深层次的实例化和属性注入控制。</li>
<li>DestructionAwareBeanPostProcessor： 允许在Bean销毁前进行额外的清理操作。</li>
<li>MergedBeanDefinitionPostProcessor：在合并Bean定义时对BeanDefinition进行处理。</li>
<li>SmartInstantiationAwareBeanPostProcessor：提供更智能的实例化控制。</li>
<li>SmartInitializingSingleton：在所有单例Bean初始化完成后，执行自定义逻辑。</li>
</ul>
<h2 id="Aware接口系列"><a href="#Aware接口系列" class="headerlink" title="Aware接口系列"></a>Aware接口系列</h2><ul>
<li>BeanNameAware：让Bean获取自身在容器中的名字。</li>
<li>BeanClassLoaderAware：允许Bean获取其类加载器。</li>
<li>BeanFactoryAware：提供Bean获取所属的BeanFactory。</li>
<li><u>EnvironmentAware</u>：允许Bean获取应用程序环境配置。</li>
<li>EmbeddedValueResolverAware：允许Bean解析嵌入式值占位符。</li>
<li>ResourceLoaderAware：允许Bean获取资源加载器。</li>
<li>ApplicationEventPublisherAware：允许Bean发布应用程序事件。</li>
<li>MessageSourceAware：允许Bean获取消息源。</li>
<li><u>ApplicationContextAware</u>：允许Bean获取应用程序上下文。</li>
<li>ImportAware：允许被导入的配置类获取导入它的类的信息。</li>
</ul>
<h2 id="核心注解"><a href="#核心注解" class="headerlink" title="核心注解"></a>核心注解</h2><ul>
<li><u>@Configuration</u>：声明类为配置类，定义Bean和Bean之间的依赖关系。</li>
<li><u>@ComponentScan</u>：启用组件扫描，自动发现并注册标记为组件的类。</li>
<li>@Bean：在配置类中声明方法，返回Bean实例。</li>
<li>@Import：引入其他配置类，将其Bean定义合并到当前容器。</li>
<li>@PropertySource：指定属性文件，加载外部配置到环境中。</li>
<li>@DependsOn：指定Bean的依赖顺序，确保特定Bean在其他Bean之前初始化。</li>
<li>@Conditional：根据条件决定是否创建Bean。</li>
<li>@Lazy：指定Bean的延迟初始化，只有在首次使用时才创建。</li>
<li>@Value：注入简单值或表达式到Bean的字段或方法参数。</li>
<li>@Autowired：自动装配Bean依赖。</li>
<li>@Primary：指定在多个候选Bean中优先选择的首选Bean。</li>
<li>@Description：为Bean提供描述性信息。</li>
<li>@Role：为Bean提供角色提示，用于区分相似类型的Bean。</li>
<li>@Indexed： 标记Bean用于索引。</li>
<li>@Order：指定Bean的加载顺序。</li>
</ul>
<h2 id="JSR规范"><a href="#JSR规范" class="headerlink" title="JSR规范"></a>JSR规范</h2><ul>
<li>@Inject：JSR-330标准的依赖注入注解。</li>
<li>@Named：JSR-330标准的命名注解。</li>
<li>@Resource：Java EE标准的资源注入注解。</li>
<li>@Qualifier：用于限定注入的Bean。</li>
<li>@Scope：指定Bean的作用域。</li>
<li>@Singleton：指定Bean为单例。</li>
<li>@PostConstruct：指定初始化方法。</li>
<li>@PreDestroy：指定销毁方法。</li>
<li>Provider：Java标准库提供的通用Bean工厂接口。</li>
</ul>
<h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><ul>
<li>JDK动态代理：接口实现，动态生成代理类，处理方法调用，统一横切关注点。</li>
<li>Cglib动态代理：基于字节码生成的库，无需接口，可拦截类方法并进行增强。</li>
<li>ClassFilter：确定类是否匹配拦截条件。</li>
<li>MethodMatcher：确定方法是否匹配拦截条件。</li>
<li>Pointcut：定义切入点，匹配被拦截的方法。</li>
<li>Advice：AOP中定义各种通知类型行为的核心接口。</li>
<li>MethodInterceptor：拦截方法执行，允许在前后添加额外逻辑。</li>
<li>MethodBeforeAdvice：允许在方法调用之前插入自定义逻辑。</li>
<li>AfterReturningAdvice：允许在方法调用之后插入自定义逻辑。&lt;</li>
<li>ThrowsAdvice：异常通知，捕获方法抛出的异常，执行额外逻辑。</li>
<li>IntroductionInterceptor：动态地向目标对象引入新的功能或属性。</li>
<li>Advisor：用于将通知和切点结合，实现切面编程的横切关注点。</li>
<li>Advised：配置AOP代理的通知、通知器、目标等。</li>
<li>ProxyFactory：一种便捷的方式来创建代理对象。</li>
<li>AopProxyFactory：创建AOP代理工厂，支持JDK和CGLIB。</li>
<li>AopProxy：创建和管理AOP代理对象。</li>
<li>AdvisorChainFactory：创建Advisor链的工厂接口。</li>
<li>AdvisorAdapterRegistry：适配各种Advice到AOP拦截器，注册和管理Advisor适配器。</li>
<li>AdvisorAdapter：适配不同类型通知到拦截器链。</li>
<li>ProxyMethodInvocation：AOP方法调用代理，处理拦截器链和方法调用。</li>
<li>@EnableAspectJAutoProxy：启用AspectJ切面自动代理。</li>
<li>AnnotationAwareAspectJAutoProxyCreator：创建AOP代理以应用AspectJ风格的切面。</li>
<li>BeanFactoryAdvisorRetrievalHelper：帮助检索并管理Spring AOP 中的 Advisor Beans。</li>
<li>BeanFactoryAspectJAdvisorsBuilder：构建@AspectJ注解切面，生成Spring AOP Advisors。</li>
<li>AspectInstanceFactory：创建切面实例，支持多种实现方式。</li>
<li>MetadataAwareAspectInstanceFactory：管理切面实例和元数据，支持多种实例化策略。</li>
<li>AspectJAdvisorFactory：创建AspectJ通知器实例，管理切面通知的创建和配置。</li>
<li>TargetSource：管理AOP代理对象的获取与释放。</li>
<li>TargetSourceCreator：创建特殊的目标源，定制代理对象的创建和管理。</li>
<li>AopContext：获取Spring AOP代理对象的工具。</li>
<li>ExposeInvocationInterceptor：暴露Spring AOP方法调用上下文的拦截器。</li>
<li>@EnableLoadTimeWeaving：启用Spring加载时编织。</li>
</ul>
<h2 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h2><blockquote>
<p><a href="/2024/09/08/Spring-%E4%BA%8B%E5%8A%A1%E4%BD%93%E7%B3%BB/">Spring 事务体系</a></p>
</blockquote>
<ul>
<li>Connection：管理数据库连接，执行SQL，处理事务。</li>
<li>DataSource：提供高效管理数据库连接的接口。</li>
<li>DriverManager：管理和建立数据库连接的核心类。</li>
<li>JdbcTemplate：简化了JDBC操作，提供了方便的数据库访问抽象。</li>
<li>TransactionDefinition：定义事务的传播行为和隔离级别。</li>
<li><u>TransactionAttributeSource</u>：用于获取事务属性的策略接口。</li>
<li><u>PlatformTransactionManager</u>：用于管理和协调事务的生命周期和执行。</li>
<li>TransactionTemplate：简化事务管理，支持编程式事务控制与异常处理。</li>
<li><u>SpringTransactionAnnotationParser</u>：解析 @Transactional注解并转换为事务配置。</li>
<li><u>TransactionInterceptor</u>：事务拦截器，用于管理方法级别的事务处理。</li>
<li><u>EnableTransactionManagement</u>：启用Spring的注解驱动事务管理。</li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Spring Lazy-init 踩坑记录</title>
    <url>/2023/11/01/Spring%20Lazy-init%20%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<blockquote>
<p>起因：在写一个Springboot项目时，队友将项目加载方式改为<code>lazy-init</code>，理由是能加快重启的速度，但是导致了Bug</p>
</blockquote>
<span id="more"></span>

<p><img src="/../images/289b54f1b37819da340708c7cfb9e261_rfYNVwE36_.png"></p>
<p><img src="/../images/1551908c7fb3dddbbc2d3b1e90a48cf1_gLwVbcWEG6.png"></p>
<p>Spring在Bean初始化阶段会对所有继承了<code>ApplicationContextAware</code>接口的类注入<code>ApplicationContext</code></p>
<p>但是如果设置了<code>lazy-init</code>，bean加载顺序变了，<code>setApplicationContext</code>就不执行了</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>📌 Spring实现自定义配置注入&amp;动态更新</title>
    <url>/2024/07/31/Spring%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>最近又在我的论坛项目中造轮子，场景是由于一些业务原因，比如接入了ChatGPT，openai_key可能会频繁的更新，或者添加新的敏感词等等都会造成项目中配置的变化，每次变动都需要修改配置文件并重新部署应用，这样是非常不方便的，动态的更新这些内存中的配置是需要解决的问题。</p>
<p>常见的做法是接入一个配置中心，如Apollo、ZK等等，但是目前项目中是没有用到这些中间件的，接入这些配置中心可能会给项目带来一些风险，况且我这是个单体项目，用这些复杂的配置中心有点大材小用了，再说直接拿来就用没什么意思</p>
<p>鉴于此，我参考了网上和Apollo配置中心的一些技术方案，实现了一个非常实用的配置拓展，支持从自定义数据源中获取配置，并注入到Environment中，且优先级最高，同时也支持配置的动态刷新</p>
<span id="more"></span>

<blockquote>
<p>为了更好的理解本文的逻辑，你可能需要以下前置知识点：<a href="/2024/06/21/Spring%20Environment%E4%BD%93%E7%B3%BB/">Spring Environment体系</a></p>
</blockquote>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><strong>直接说思路</strong>：<u>借助Mysql，维护一个配置表<code>global_config</code>，原因是方便构造自定义数据源和持久化用户配置，在Spring启动时读取数据库中的数据构造为我们自定义的属性源，并设置为首要，再利用<code>Binder</code>更新内存中的<code>ConfigurationProperties</code>对象和 <code>@Value</code>标记的字段，这样就可以实现覆盖<code>properties</code>文件中的配置</u></p>
<blockquote>
<p>其实这里存在一个问题，就是如果能在<code>PropertySourcesPropertyResolver</code>的配置解析阶段就将自定义的属性源注入，那么初始化后的<code>ConfigurationProperties</code>对象和 <code>@Value</code>标记的字段本身就是我们自定义数据源中的配置，但我尝试后发现无论如何都无法在解析前将自定义数据源注入到Environment中，于是只能在项目完全启动后刷新所有配置<br><img src="/../images/image_Secure2_Image.png"></p>
</blockquote>
<h2 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h2><p>我的项目中配置的使用姿势主要分两种：</p>
<ol>
<li>通过<code>@ConfigurationProperties</code>注入的<code>Property</code>对象</li>
<li>通过<code>@Value</code>注入的配置字段</li>
</ol>
<p>两个部分需要不同的更新方式，因此配置的更新方式分为两部分：</p>
<h3 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a><code>@ConfigurationProperties</code></h3><ul>
<li>在初始化阶段：读取数据库中的配置表 → 生成自定义<code>MapPropertySource</code> →** 将自定义****<code>MapPropertySource</code>**<strong>添加到Environment中并设置为最高优先级</strong></li>
<li>监听到配置变更：检查DB中的数据库与当前缓存中的<code>MapPropertySource</code>是否一致 ，如果不一致就调用refresh方法刷新Environment中的<code>MapPropertySource</code>。refresh方法的逻辑其实就是<strong>重新使用Binder绑定内存中的<code>ConfigurationProperties</code></strong></li>
</ul>
<h3 id="Value"><a href="#Value" class="headerlink" title="@Value"></a><code>@Value</code></h3><p>这部分的配置更新参考了<strong>Apollo</strong>的实现：利用一个<strong>括号匹配</strong>算法，在<code>BeanPostProcessor</code>阶段扫描所有带<code>@Value</code>占位符的Bean，包括表达式、占位符等等，连带对应的Bean引用全部存起来</p>
<p>当有相关的key变化时，通过Bean的引用反射更新对应的Bean字段，你也可以使用观察者模式监听对应的key的变化，就可以做到当配置变化后自动触发对应Bean字段的更新</p>
<blockquote>
<p><a href="https://github.com/apolloconfig/apollo/pull/972">https://github.com/apolloconfig/apollo/pull/972</a></p>
</blockquote>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>这部分的代码具体实现其实也参考了<code>ConfigurationProperties</code>的注入原理——<code>ConfigurationPropertiesBindingPostProcessor</code>的实现。为了缩减篇幅删除了一些非核心逻辑：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义的动态配置工厂类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> qing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024/8/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicConfigContainer</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span>, InitializingBean, EnvironmentAware, CommandLineRunner {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConfigurableEnvironment environment;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储db中的全局配置，优先级最高</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DynamicConfigBinder binder;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        cache = Maps.newHashMap();</span><br><span class="line">        <span class="built_in">this</span>.binder = <span class="keyword">new</span> <span class="title class_">DynamicConfigBinder</span>(<span class="built_in">this</span>.applicationContext, environment.getPropertySources());</span><br><span class="line">        bindBeansFromLocalCache(<span class="string">"dbConfig"</span>, cache);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从db中获取全量的配置信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 表示有信息变更; false 表示无信息变更</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">loadAllConfigFromDb</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">"select `key`, `value` from global_conf where deleted = 0"</span>;</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; list = applicationContext.getBean(JdbcTemplate.class).queryForList(sql);</span><br><span class="line">        Map&lt;String, Object&gt; val = Maps.newHashMapWithExpectedSize(list.size());</span><br><span class="line">        <span class="keyword">for</span> (Map&lt;String, Object&gt; conf : list) {</span><br><span class="line">            val.put(conf.get(<span class="string">"key"</span>).toString(), conf.get(<span class="string">"value"</span>).toString());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (val.equals(cache)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        cache.clear();</span><br><span class="line">        cache.putAll(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bindBeansFromLocalCache</span><span class="params">(String namespace, Map&lt;String, Object&gt; cache)</span> {</span><br><span class="line">        <span class="comment">// 将内存的配置信息设置为最高优先级</span></span><br><span class="line">        <span class="type">MapPropertySource</span> <span class="variable">propertySource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapPropertySource</span>(namespace, cache);</span><br><span class="line">        environment.getPropertySources().addFirst(propertySource);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Bindable bindable)</span> {</span><br><span class="line">        binder.bind(bindable);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听配置的变更</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reloadConfig</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">before</span> <span class="operator">=</span> JsonUtil.toStr(cache);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">toRefresh</span> <span class="operator">=</span> loadAllConfigFromDb();</span><br><span class="line">        <span class="keyword">if</span> (toRefresh) {</span><br><span class="line">            refreshConfig();</span><br><span class="line">            log.info(<span class="string">"config update! Old:{}, New:{}"</span>, before, JsonUtil.toStr(cache));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持配置的动态刷新</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">refreshConfig</span><span class="params">()</span> {</span><br><span class="line">        applicationContext.getBeansWithAnnotation(ConfigurationProperties.class).values().forEach(bean -&gt; {</span><br><span class="line">            Bindable&lt;?&gt; target = Bindable.ofInstance(bean).withAnnotations(AnnotationUtils.findAnnotation(bean.getClass(), ConfigurationProperties.class));</span><br><span class="line">            bind(target);</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 应用启动之后，执行的动态配置初始化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        reloadConfig();</span><br><span class="line">        <span class="comment">// SpringValueRegistry.updateAll();</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicConfigBinder</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PropertySources propertySources;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Binder binder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicConfigBinder</span><span class="params">(ApplicationContext applicationContext, PropertySources propertySources)</span> {</span><br><span class="line">        <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">        <span class="built_in">this</span>.propertySources = propertySources;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Bindable&lt;T&gt; bindable)</span> {</span><br><span class="line">        <span class="type">ConfigurationProperties</span> <span class="variable">propertiesAno</span> <span class="operator">=</span> bindable.getAnnotation(ConfigurationProperties.class);</span><br><span class="line">        <span class="keyword">if</span> (propertiesAno != <span class="literal">null</span>) {</span><br><span class="line">            <span class="type">BindHandler</span> <span class="variable">bindHandler</span> <span class="operator">=</span> getBindHandler(propertiesAno);</span><br><span class="line">            getBinder().bind(propertiesAno.prefix(), bindable, bindHandler);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(String prefix, Bindable&lt;T&gt; bindable, BindHandler bindHandler)</span> {</span><br><span class="line">        getBinder().bind(prefix, bindable, bindHandler);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BindHandler <span class="title function_">getBindHandler</span><span class="params">(ConfigurationProperties annotation)</span> {</span><br><span class="line">        <span class="type">BindHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IgnoreTopLevelConverterNotFoundBindHandler</span>();</span><br><span class="line">        <span class="keyword">if</span> (annotation.ignoreInvalidFields()) {</span><br><span class="line">            handler = <span class="keyword">new</span> <span class="title class_">IgnoreErrorsBindHandler</span>(handler);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!annotation.ignoreUnknownFields()) {</span><br><span class="line">            <span class="type">UnboundElementsSourceFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnboundElementsSourceFilter</span>();</span><br><span class="line">            handler = <span class="keyword">new</span> <span class="title class_">NoUnboundElementsBindHandler</span>(handler, filter);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参考ConfigurationPropertiesBindingPostProcessor</span></span><br><span class="line">    <span class="keyword">private</span> Binder <span class="title function_">getBinder</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.binder == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) {</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.binder == <span class="literal">null</span>) {</span><br><span class="line">                    <span class="built_in">this</span>.binder = <span class="keyword">new</span> <span class="title class_">Binder</span>(getConfigurationPropertySources(),</span><br><span class="line">                            getPropertySourcesPlaceholdersResolver(), getConversionService(),</span><br><span class="line">                            getPropertyEditorInitializer());</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.binder;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><img src="/../images/image_Spring%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E9%85%8D%E7%BD%AE.png"></p>
<p>这里就可以看到我们自定义的属性源<code>dbConfig</code>已经被注入成功啦😃</p>
<p>除此之外，当监听到对应的配置更新时，除了更新数据库，还需要推送对应的消息，在这里由于我项目中使用的是Spring Event实现的消息机制，因此监听者的操作如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ConfigRefreshEvent event)</span> {</span><br><span class="line">    dynamicConfigContainer.reloadConfig();</span><br><span class="line">    <span class="comment">// SpringValueRegistry.updateValue(event.getKey());</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>至于<code>@Value</code>的部分，代码比较多就不贴了，具体可以参考在<a href="https://github.com/qing-wq/SAI-Forum-backend/tree/rabbitmq/sai-core/src/main/java/ink/whi/core/autoconf/apollo">https://github.com/qing-wq/SAI-Forum-backend/tree/rabbitmq/sai-core/src/main/java/ink/whi/core/autoconf/apollo</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring Environment</tag>
      </tags>
  </entry>
  <entry>
    <title>Go GC VS Java GC</title>
    <url>/2024/01/03/Go-GC-Vs-Java-GC/</url>
    <content><![CDATA[<p>之前面试的时候被面试官问到过这个问题，但是当时对Go的GC一点也不了解。于是后来整理了一下，发现Go的GC算法真有意思。本文对比了Java和Go在GC算法上的的区别：</p>
<h1 id="Java-GC"><a href="#Java-GC" class="headerlink" title="Java GC"></a>Java GC</h1><p>Java的GC使用<strong>分代回收算法</strong>，将堆内存划分为新生代和老年代，一般情况下在<strong>新生代使用标记-复制算法，老年代使用标记-清除或标记-整理算法</strong></p>
<p>分代GC依赖分代假设，即GC将主要的回收目标放在新创建的对象上（存活时间短，更倾向于被回收），而非频繁检查所有对象。</p>
<p>在Java中，不同的垃圾回收器使用的垃圾回收算法不同：</p>
<ul>
<li>JDK 8：Parallel Scavenge</li>
<li>JDK 9 ~ JDK20: G1</li>
</ul>
<span id="more"></span>

<p><strong>特点：</strong></p>
<ul>
<li>都会造成STW，这是影响性能最主要的因素</li>
<li>部分算法还会产生大量空间碎片</li>
</ul>
<p>介绍一下Java中比较经典的垃圾回收器：</p>
<h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p><strong>以获取最短回收停顿时间为目标</strong>，使用了<strong>标记-清除</strong> 算法，<strong>第一次实现了让垃圾收集线程与用户线程（基本上）同时工作</strong></p>
<ul>
<li>主要优点：<strong>并发收集、低停顿</strong></li>
<li>缺点：<strong>对 CPU 资源敏感</strong>，<strong>会产生大量空间碎片</strong></li>
</ul>
<h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p>G1 收集器在后台维护了一个<strong>优先列表</strong>，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 <strong>Garbage-First</strong> 的由来) 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率）。</p>
<p>G1使用<strong>标记-整理</strong>算法</p>
<h1 id="Go-GC"><a href="#Go-GC" class="headerlink" title="Go GC"></a>Go GC</h1><p>Golang的垃圾回收算法使用的是<em><strong>无分代、不整理、并发</strong>的</em><em>三色标记清扫算法</em>**。原因在于：</p>
<ul>
<li>Go 运行时的分配算法基于<code>tcmalloc</code>，<strong>基本上没有碎片问题</strong>，对对象进行整理不会带来实质性的性能提升。</li>
<li>Go 的编译器会通过<strong>逃逸分析</strong>将大部分新生对象存储在栈上，只有那些需要长期存在的对象才会被分配到需要进行垃圾回收的堆中。也就是说，分代<code>GC</code>回收的那些存活时间短的对象在 Go 中是直接被分配到栈上，当<code>goroutine</code>死亡后栈也会被直接回收，不需要<code>GC</code>的参与，进而分代假设并没有带来直接优势。</li>
<li>引入了<strong>混合屏障机制</strong>，能够让Go 的垃圾回收器部分阶段与用户代码并发执行，大大缩短了STW的时间</li>
</ul>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Java VS Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring中几个关键的后置处理器以及执行顺序</title>
    <url>/2024/05/26/Spring%E4%B8%AD%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E7%9A%84%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BB%A5%E5%8F%8A%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="BeanDefinitionRegistryPostProcessor"><a href="#BeanDefinitionRegistryPostProcessor" class="headerlink" title="BeanDefinitionRegistryPostProcessor"></a>BeanDefinitionRegistryPostProcessor</h2><p>作用时机：<strong>在所有 BeanDefinition被加载后执行，但在<code>BeanFactoryPostProcessor</code>之前</strong>。 </p>
<p>常见应用: 动态注册新的 bean 定义、修改或移除已有的 BeanDefinition。</p>
<h2 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h2><p>BeanFactory标准初始化之后，所有的BeanDefinition已经被加载，但标准Bean的实例还没被创建（不包括<code>BeanFactoryPostProcessor</code>类型）。该方法通常用于修改BeanDefinition，Bean的属性值等，甚至可以在此快速初始化Bean。</p>
<span id="more"></span>

<h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h2><p>作用时机：Bean初始化前后</p>
<p><code>BeanPostProcessors#ProcessBeforeInitialization()</code>在Bean初始化前调用</p>
<p><code>BeanPostProcessors#ProcessaAfterInitialization()</code>在Bean初始化后调用</p>
<p>…待补充</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
</search>
