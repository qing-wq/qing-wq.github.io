<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Go GC VS Java GC</title>
    <url>/2023/11/03/Go-GC-Vs-Java-GC/</url>
    <content><![CDATA[<p>之前面试的时候被面试官问到过这个问题，但是当时对Go的GC一点也不了解。于是后来整理了一下，发现Go的GC算法真有意思。本文对比了Java和Go在GC算法上的的区别：</p>
<h1 id="Java-GC"><a href="#Java-GC" class="headerlink" title="Java GC"></a>Java GC</h1><p>Java的GC使用<strong>分代回收算法</strong>，将堆内存划分为新生代和老年代，一般情况下在<strong>新生代使用标记-复制算法，老年代使用标记-清除或标记-整理算法</strong></p>
<p>分代GC依赖分代假设，即GC将主要的回收目标放在新创建的对象上（存活时间短，更倾向于被回收），而非频繁检查所有对象。</p>
<p>在Java中，不同的垃圾回收器使用的垃圾回收算法不同：</p>
<ul>
<li>JDK 8：Parallel Scavenge</li>
<li>JDK 9 ~ JDK20: G1</li>
</ul>
<span id="more"></span>

<p><strong>特点：</strong></p>
<ul>
<li>都会造成STW，这是影响性能最主要的因素</li>
<li>部分算法还会产生大量空间碎片</li>
</ul>
<p>介绍一下Java中比较经典的垃圾回收器：</p>
<h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p><strong>以获取最短回收停顿时间为目标</strong>，使用了<strong>标记-清除</strong> 算法，<strong>第一次实现了让垃圾收集线程与用户线程（基本上）同时工作</strong></p>
<ul>
<li>主要优点：<strong>并发收集、低停顿</strong></li>
<li>缺点：<strong>对 CPU 资源敏感</strong>，<strong>会产生大量空间碎片</strong></li>
</ul>
<h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p>G1 收集器在后台维护了一个<strong>优先列表</strong>，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 <strong>Garbage-First</strong> 的由来) 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率）。</p>
<p>G1使用<strong>标记-整理</strong>算法</p>
<h1 id="Go-GC"><a href="#Go-GC" class="headerlink" title="Go GC"></a>Go GC</h1><p>Golang的垃圾回收算法使用的是<em><strong>无分代、不整理、并发</strong>的</em><em>三色标记清扫算法</em>**。原因在于：</p>
<ul>
<li>Go 运行时的分配算法基于<code>tcmalloc</code>，<strong>基本上没有碎片问题</strong>，对对象进行整理不会带来实质性的性能提升。</li>
<li>Go 的编译器会通过<strong>逃逸分析</strong>将大部分新生对象存储在栈上，只有那些需要长期存在的对象才会被分配到需要进行垃圾回收的堆中。也就是说，分代<code>GC</code>回收的那些存活时间短的对象在 Go 中是直接被分配到栈上，当<code>goroutine</code>死亡后栈也会被直接回收，不需要<code>GC</code>的参与，进而分代假设并没有带来直接优势。</li>
<li>引入了<strong>混合屏障机制</strong>，能够让Go 的垃圾回收器部分阶段与用户代码并发执行，大大缩短了STW的时间</li>
</ul>
]]></content>
      <categories>
        <category>Java VS Go</category>
      </categories>
  </entry>
  <entry>
    <title>GraphQL入门</title>
    <url>/2024/04/13/GraphQL%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<blockquote>
<p>最近工作中用到了这个技术「GraphQL」，本文记录一下入门学习过程</p>
</blockquote>
<h2 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1 基础概念"></a>1 基础概念</h2><h3 id="1-1-操作类型-Operation-Type"><a href="#1-1-操作类型-Operation-Type" class="headerlink" title="1.1 操作类型 Operation Type"></a>1.1 操作类型 Operation Type</h3><ol>
<li><code>query</code>：查询数据，相当于CRUD 中的 R</li>
<li><code>mutation</code>：变更，对数据进行变更，比如增加、删除、修改，CRUD 中的 CUD</li>
<li><code>substription</code>：订阅，当数据发生更改，进行消息推送</li>
</ol>
<h3 id="1-2-对象类型和标量类型-Object-Type-Scalar-Type"><a href="#1-2-对象类型和标量类型-Object-Type-Scalar-Type" class="headerlink" title="1.2 对象类型和标量类型 Object Type &amp; Scalar Type"></a>1.2 对象类型和标量类型 Object Type &amp; Scalar Type</h3><ol>
<li><strong>对象类型</strong>：用户在 schema 中定义的 <code>type</code></li>
<li><strong>标量类型</strong>：GraphQL 中内置有一些标量类型 <code>String</code>、<code>Int</code>、<code>Float</code>、<code>Boolean</code>、<code>ID</code>，用户也可以定义自己的标量类型</li>
</ol>
<span id="more"></span>

<p>例如：</p>
<figure class="highlight graphql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MetaData <span class="punctuation">{</span></span><br><span class="line">    <span class="symbol">fileName</span><span class="punctuation">:</span> String<span class="punctuation">!</span></span><br><span class="line">    <span class="symbol">fileId</span><span class="punctuation">:</span> ID</span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>其中<code>MetaData</code>是对象类型，<code>String</code>、<code>ID</code>等则是标量类型，<code>!</code>表示非空标量</p>
<p>如果一个 GraphQL 服务接受到了一个 <code>query</code>，那么这个 <code>query</code> 将从 <code>Root Query</code> 开始查找，找到对象类型时则使用它的解析函数 Resolver 来获取内容，如果返回的是对象类型则继续使用解析函数获取内容，如果返回的是标量类型则结束获取，直到找到最后一个标量类型。</p>
<h3 id="1-3-模式-Schema"><a href="#1-3-模式-Schema" class="headerlink" title="1.3 模式 Schema"></a>1.3 模式 Schema</h3><p>Schema定义了字段的类型、数据的结构，描述了接口数据请求的规则，Schema 使用一个简单的强类型模式语法，称为模式描述语言（Schema Definition Language, <em><strong>SDL</strong></em>）</p>
<p>如下是一个Schema的demo：</p>
<figure class="highlight graphql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">Query</span> <span class="punctuation">{</span></span><br><span class="line">    metaData<span class="punctuation">(</span><span class="symbol">fileId</span><span class="punctuation">:</span> ID<span class="punctuation">)</span><span class="punctuation">:</span> MetaData</span><br><span class="line"><span class="punctuation">}</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">Mutation</span> <span class="punctuation">{</span></span><br><span class="line">    createMetaData<span class="punctuation">(</span><span class="symbol">fileId</span><span class="punctuation">:</span> ID, <span class="symbol">fileName</span><span class="punctuation">:</span> String, <span class="symbol">fileType</span><span class="punctuation">:</span> String<span class="punctuation">)</span><span class="punctuation">:</span> MetaData</span><br><span class="line"><span class="punctuation">}</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MetaData <span class="punctuation">{</span></span><br><span class="line">    <span class="symbol">fileName</span><span class="punctuation">:</span> String<span class="punctuation">!</span></span><br><span class="line">    <span class="symbol">fileType</span><span class="punctuation">:</span> String</span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>Schema 文件从 Query、Mutation、Subscription 入口开始定义了各个对象类型或标量类型，这些字段的类型也可能是其他的对象类型或标量类型，组成一个<strong>树形结构</strong>，而用户在向服务端发送请求的时候，沿着这个树选择一个或多个分支就可以获取多组信息。</p>
<p>注意：在 Query 查询字段时，是并行执行的，而在 Mutation 变更的时候，是线性执行，一个接着一个，防止同时变更带来的竞态问题，比如说我们在一个请求中发送了两个 Mutation，那么前一个将始终在后一个之前执行。</p>
<h3 id="1-4-解析函数-Resolver"><a href="#1-4-解析函数-Resolver" class="headerlink" title="1.4 解析函数 Resolver"></a>1.4 解析函数 Resolver</h3><p>前端请求信息到达后端之后，需要由解析函数 Resolver 来提供数据：</p>
<figure class="highlight graphql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">query</span> <span class="punctuation">{</span></span><br><span class="line">  hello</span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>对应的同名的解析函数应该是这样的：</p>
<figure class="highlight graphql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="symbol">Query</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">  hello <span class="punctuation">(</span>parent, args, context, info<span class="punctuation">)</span> <span class="punctuation">{</span></span><br><span class="line">    return <span class="punctuation">...</span></span><br><span class="line">  <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>解析函数接受四个参数，分别为</p>
<ol>
<li><code>parent</code>：当前上一个解析函数的返回值</li>
<li><code>args</code>：查询中传入的参数</li>
<li><code>context</code>：提供给所有解析器的上下文信息</li>
<li><code>info</code>：一个保存与当前查询相关的字段特定信息以及 schema 详细信息的值</li>
</ol>
<p>解析函数的返回值可以是一个具体的值，也可以是 Promise 或 Promise 数组。</p>
<h3 id="1-5-请求格式"><a href="#1-5-请求格式" class="headerlink" title="1.5 请求格式"></a>1.5 请求格式</h3><p>下面演示如何通过 Get/Post 方式来执行下面的 GraphQL 查询：</p>
<p><strong>查询文档</strong></p>
<figure class="highlight graphql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">query</span> <span class="punctuation">{</span></span><br><span class="line">  me <span class="punctuation">{</span></span><br><span class="line">    name</span><br><span class="line">  <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>Get/Post请求方式：</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Get 方式</span></span><br><span class="line">http<span class="punctuation">:</span><span class="comment">//localhost:8080/graphql?query={me{name}}</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Post 方式的请求体</span></span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"query"</span><span class="punctuation">:</span> <span class="string">"{me{name}}"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"operationName"</span><span class="punctuation">:</span> <span class="string">""</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"variables"</span><span class="punctuation">:</span> <span class="punctuation">{</span> <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"value"</span><span class="punctuation">,</span> ... <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>标准的 GraphQL POST 请求应当在 HTTP header 中声明 <code>Content-Type: application/json</code>，并且使用 JSON 格式的内容。</p>
<p><strong>返回的格式</strong></p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 正确返回</span></span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"data"</span><span class="punctuation">:</span> <span class="punctuation">{</span> ... <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行时发生错误</span></span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"errors"</span><span class="punctuation">:</span> <span class="punctuation">[</span> ... <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>GraphQL也提供了方便的图形化界面帮助构建GraphQL请求：</p>
<blockquote>
<p>左边是请求信息栏，左下是请求参数栏和请求头设置栏，右边是返回参数栏</p>
</blockquote>
<p><img src="/../images/GraphQL%E5%85%A5%E9%97%A8/image_B7PpTjmpqj.png"></p>
<h2 id="2-GraphQL-Java"><a href="#2-GraphQL-Java" class="headerlink" title="2 GraphQL-Java"></a>2 GraphQL-Java</h2><p>先看一下官网Demo：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> {</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">      <span class="comment">//schema定义，包含一个hello的查询方法</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">schema</span> <span class="operator">=</span> <span class="string">"type Query{hello: String} schema{query: Query}"</span>;</span><br><span class="line">      <span class="type">SchemaParser</span> <span class="variable">schemaParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SchemaParser</span>();</span><br><span class="line">      <span class="comment">// 加载schema并解析为TypeDefinitionRegistry</span></span><br><span class="line">      <span class="type">TypeDefinitionRegistry</span> <span class="variable">typeDefinitionRegistry</span> <span class="operator">=</span> schemaParser.parse(schema);</span><br><span class="line">      <span class="comment">// 定义hello方法触发的操作</span></span><br><span class="line">      <span class="type">RuntimeWiring</span> <span class="variable">runtimeWiring</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeWiring</span>()</span><br><span class="line">              .type(<span class="string">"Query"</span>, builder -&gt; builder.dataFetcher(<span class="string">"hello"</span>, <span class="keyword">new</span> <span class="title class_">StaticDataFetcher</span>(<span class="string">"world"</span>)))</span><br><span class="line">              .build();</span><br><span class="line"></span><br><span class="line">      <span class="type">SchemaGenerator</span> <span class="variable">schemaGenerator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SchemaGenerator</span>();</span><br><span class="line">      <span class="type">GraphQLSchema</span> <span class="variable">graphQLSchema</span> <span class="operator">=</span> schemaGenerator.makeExecutableSchema(typeDefinitionRegistry, runtimeWiring);</span><br><span class="line">      <span class="comment">// 构建GraphQL实例</span></span><br><span class="line">      <span class="type">GraphQL</span> <span class="variable">build</span> <span class="operator">=</span> GraphQL.newGraphQL(graphQLSchema).build();</span><br><span class="line">      <span class="type">ExecutionResult</span> <span class="variable">executionResult</span> <span class="operator">=</span> build.execute(<span class="string">"{hello}"</span>);</span><br><span class="line"></span><br><span class="line">      System.out.println(executionResult.getData().toString());  <span class="comment">// result: {hello=world}</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过这个Demo，我们来看一下GraphQL的实现需要哪些关键组件：</p>
<h3 id="2-1-TypeDefinitionRegistry"><a href="#2-1-TypeDefinitionRegistry" class="headerlink" title="2.1 TypeDefinitionRegistry"></a>2.1 TypeDefinitionRegistry</h3><p><strong>类型定义</strong>。在Java代码中，通过加载Schema文件或描述，将其解析为<code>TypeDefinitionRegistry</code>。</p>
<h3 id="2-2-RuntimeWiring"><a href="#2-2-RuntimeWiring" class="headerlink" title="2.2 RuntimeWiring"></a>2.2 RuntimeWiring</h3><p><strong>运行时织入</strong>。仅有Schema及其类型定义还不够，在Java中要实际运行GraphQL，还需要显式指定定义中的每个操作，该触发什么样的行为，<em>相当于Resolver函数</em></p>
<p>例如，在本例中，<code>builder -&gt; builder.dataFetcher("hello", new StaticDataFetcher("world")</code>表示当查询Query类型下的hello字段时，返回值为”world”。</p>
<h3 id="2-3-GraphQL"><a href="#2-3-GraphQL" class="headerlink" title="2.3 GraphQL"></a>2.3 GraphQL</h3><p><strong>核心组件</strong>。GraphQL实例是我们使用GraphQL最关键的组件，负责对GraphQL请求进行响应</p>
<p>在结合前面<code>TypeDefinitionRegistry</code>和<code>RuntimeWiring</code>的基础上，生成的可运行的GraphQL实例</p>
<h3 id="2-4-ExecutionResult"><a href="#2-4-ExecutionResult" class="headerlink" title="2.4 ExecutionResult"></a>2.4 ExecutionResult</h3><p>每次执行GraphQL操作时，返回的<strong>结果对象</strong>。</p>
<p>其中包含error字段，用于保存执行过程中的报错信息；data字段，用于获取执行结果返回值。</p>
<h3 id="2-5-DataFetchers"><a href="#2-5-DataFetchers" class="headerlink" title="2.5 DataFetchers"></a>2.5 DataFetchers</h3><p><em><strong>Schema中的每个字段都有一个<code>DataFethcer</code>与之关联，</strong></em>在查询执行的时候，它会为查询语句中的每个字段调用合适的<code>DataFetcher</code></p>
<p><code>DataFetcher</code>是一个接口，核心方法是<code>get()</code>，只有一个<code>DataFetcherEnvironment</code>参数：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DataFetcher</span>&lt;T&gt; {</span><br><span class="line"></span><br><span class="line">    T <span class="title function_">get</span><span class="params">(DataFetchingEnvironment environment)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>DataFetchingEnvironment</code>中包含前端传递的字段参数，<code>DataFetchers</code>复杂根据这些参数查找到对应的数据</p>
<p>下面这张图非常形象画的（虽然不是我画的😆）</p>
<p><img src="/../images/GraphQL%E5%85%A5%E9%97%A8/image_hy8ZUSywws.png"></p>
<h2 id="3-实践"><a href="#3-实践" class="headerlink" title="3 实践"></a>3 实践</h2><blockquote>
<p>“Talk is cheap. Show me the code.”</p>
</blockquote>
<p>场景：创建一个文件服务器，能够上传和下载文件，并可以保存和查询文件的元数据</p>
<p>先定义一个Scheme文件<code>schema.graphqls</code>：</p>
<figure class="highlight graphql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">Query</span> <span class="punctuation">{</span></span><br><span class="line">    metaData<span class="punctuation">(</span><span class="symbol">fileId</span><span class="punctuation">:</span> ID<span class="punctuation">)</span><span class="punctuation">:</span> MetaData</span><br><span class="line"><span class="punctuation">}</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">Mutation</span> <span class="punctuation">{</span></span><br><span class="line">    createMetaData<span class="punctuation">(</span><span class="symbol">fileId</span><span class="punctuation">:</span> ID, <span class="symbol">fileName</span><span class="punctuation">:</span> String, <span class="symbol">fileType</span><span class="punctuation">:</span> String<span class="punctuation">)</span><span class="punctuation">:</span> MetaData</span><br><span class="line"><span class="punctuation">}</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MetaData <span class="punctuation">{</span></span><br><span class="line">    <span class="symbol">fileName</span><span class="punctuation">:</span> String</span><br><span class="line">    <span class="symbol">fileType</span><span class="punctuation">:</span> String</span><br><span class="line"><span class="punctuation">}</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mutation</span> createMetaData <span class="punctuation">{</span></span><br><span class="line">    createMetaData<span class="punctuation">(</span><span class="symbol">fileId</span><span class="punctuation">:</span> <span class="string">"%s"</span>, <span class="symbol">fileName</span><span class="punctuation">:</span> <span class="string">"%s"</span>, <span class="symbol">fileType</span><span class="punctuation">:</span> <span class="string">"%s"</span><span class="punctuation">)</span> <span class="punctuation">{</span></span><br><span class="line">        fileName,</span><br><span class="line">        fileType</span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">query</span> <span class="punctuation">{</span></span><br><span class="line">    metaData<span class="punctuation">(</span><span class="symbol">fileId</span><span class="punctuation">:</span> <span class="string">"%s"</span><span class="punctuation">)</span> <span class="punctuation">{</span></span><br><span class="line">        fileName,</span><br><span class="line">        fileType</span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>我们定义一个类<code>GraphQLFactory</code>，用于构建GraphQL实例：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GraphQLFactory</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> GraphQL graphQL;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowire</span></span><br><span class="line">    <span class="keyword">private</span> SpringSQLQueryDataFetcher queryDataFetcher;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowire</span></span><br><span class="line">    <span class="keyword">private</span> SpringSQLMutationDataFetcher mutationDataFetcher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">schemaString</span> <span class="operator">=</span> getGraphQLSchemaResourceAsString(<span class="string">"schema.graphqls"</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">GraphQLSchema</span> <span class="variable">graphQLSchema</span> <span class="operator">=</span> buildSchema(schemaString, queryDataFetcher, mutationDataFetcher);</span><br><span class="line">        <span class="keyword">return</span> GraphQL.newGraphQL(graphQLSchema).build();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> GraphQLSchema <span class="title function_">buildSchema</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> <span class="meta">@NotNull</span> String schemaString,</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> <span class="meta">@NotNull</span> DataFetcher&lt;MetaData&gt; queryDataFetcher,</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> <span class="meta">@NotNull</span> DataFetcher&lt;MetaData&gt; mutationDataFetcher</span></span><br><span class="line"><span class="params">    )</span> {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">TypeDefinitionRegistry</span> <span class="variable">typeDefinitionRegistry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SchemaParser</span>().parse(schemaString);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">RuntimeWiring</span> <span class="variable">runtimeWiring</span> <span class="operator">=</span> buildWiring(queryDataFetcher, mutationDataFetcher);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">SchemaGenerator</span> <span class="variable">schemaGenerator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SchemaGenerator</span>();</span><br><span class="line">        <span class="keyword">return</span> schemaGenerator.makeExecutableSchema(typeDefinitionRegistry, runtimeWiring);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RuntimeWiring <span class="title function_">buildWiring</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> RuntimeWiring.newRuntimeWiring()</span><br><span class="line">                .type(newTypeWiring(<span class="string">"Query"</span>).dataFetcher(<span class="string">"metaData"</span>, queryDataFetcher))</span><br><span class="line">                .type(newTypeWiring(<span class="string">"Mutation"</span>).dataFetcher(<span class="string">"createMetaData"</span>, mutationDataFetcher))</span><br><span class="line">                .build();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getGraphQLSchemaResourceAsString</span><span class="params">(<span class="meta">@NotNull</span> <span class="keyword">final</span> String resourceName)</span> {</span><br><span class="line">        <span class="meta">@SuppressWarnings("ConstantConditions")</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(</span><br><span class="line">                Thread</span><br><span class="line">                        .currentThread()</span><br><span class="line">                        .getContextClassLoader()</span><br><span class="line">                        .getResourceAsStream(Objects.requireNonNull(resourceName))</span><br><span class="line">        )</span><br><span class="line">                .useDelimiter(<span class="string">"\\A"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (scanner.hasNext()) {</span><br><span class="line">            <span class="keyword">return</span> scanner.next();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> String.format(<span class="string">"GraphQL schema file not found: '%s'"</span>, resourceName);</span><br><span class="line">        LOG.error(message);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(message);</span><br><span class="line">    }   </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接下来我们创建对应的<code>DataFetchers</code>，分别对Schema中定义的<code>createMetaData</code>和<code>metaData</code>方法进行实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringSQLQueryDataFetcher</span> <span class="keyword">implements</span> <span class="title class_">DataFetcher</span>&lt;MetaData&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MetaData <span class="title function_">get</span><span class="params">(<span class="keyword">final</span> DataFetchingEnvironment dataFetchingEnvironment)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">fileId</span> <span class="operator">=</span> dataFetchingEnvironment.getArgument(FILE_ID);</span><br><span class="line">        <span class="comment">// select from db</span></span><br><span class="line">        <span class="type">MetaData</span> <span class="variable">metaData</span> <span class="operator">=</span> getMetaDataByFileId(fileId);</span><br><span class="line">        <span class="keyword">return</span> metaData;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringSQLMutationDataFetcher</span> <span class="keyword">implements</span> <span class="title class_">DataFetcher</span>&lt;MetaData&gt; {</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FILE_ID</span> <span class="operator">=</span> <span class="string">"fileId"</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FILE_NAME</span> <span class="operator">=</span> <span class="string">"fileName"</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FILE_TYPE</span> <span class="operator">=</span> <span class="string">"fileType"</span>;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> MetaData <span class="title function_">get</span><span class="params">(<span class="keyword">final</span> DataFetchingEnvironment dataFetchingEnvironment)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">      <span class="keyword">final</span> <span class="type">String</span> <span class="variable">fileId</span> <span class="operator">=</span> dataFetchingEnvironment.getArgument(FILE_ID);</span><br><span class="line">      <span class="keyword">final</span> <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> dataFetchingEnvironment.getArgument(FILE_NAME);</span><br><span class="line">      <span class="keyword">final</span> <span class="type">String</span> <span class="variable">fileType</span> <span class="operator">=</span> dataFetchingEnvironment.getArgument(FILE_TYPE);</span><br><span class="line"></span><br><span class="line">      updateMetaData(fileId, fileName, fileType);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> MetaData.of(</span><br><span class="line">              Stream.of(</span><br><span class="line">                      <span class="keyword">new</span> <span class="title class_">AbstractMap</span>.SimpleImmutableEntry&lt;&gt;(FILE_NAME, fileName),</span><br><span class="line">                      <span class="keyword">new</span> <span class="title class_">AbstractMap</span>.SimpleImmutableEntry&lt;&gt;(FILE_TYPE, fileType)</span><br><span class="line">              ).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))</span><br><span class="line">      );</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<p>参考：</p>
<ul>
<li><a href="https://juejin.cn/post/7066694688090095652" title="Graphql+SpringBoot看这一篇就够了">Graphql+SpringBoot看这一篇就够了</a></li>
<li><a href="https://www.cnblogs.com/pku-liuqiang/p/11496914.html" title="GraphQL Java-入门指南">GraphQL Java-入门指南</a></li>
</ul>
]]></content>
      <categories>
        <category>日常小记</category>
      </categories>
      <tags>
        <tag>GraphQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Bean的初始化流程</title>
    <url>/2024/03/31/Bean%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>Bean生命周期的大致过程：实例化→属性注入→初始化→销毁</p>
<p><img src="/../images/Bean%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/bean.svg"></p>
<p>本文主要探讨一下初始化这个过程：</p>
<h2 id="初始化生命钩子"><a href="#初始化生命钩子" class="headerlink" title="初始化生命钩子"></a>初始化生命钩子</h2><p>该阶段主要做bean的初始化操作，包括：<strong>回调Aware接口</strong>、<strong>回调初始化方法</strong>、<strong>生成代理对象</strong>等：</p>
<ol>
<li><p><strong>回调<code>Aware</code>接口</strong></p>
<p> 包括<code>BeanNameAware</code>、<code>BeanFactoryAware</code>等</p>
</li>
<li><p><strong><code>BeanPostProcessors</code>前置处理器</strong></p>
<ul>
<li><code>ApplicationContextAwareProcessor</code>：回调一些Aware接口，如：<ul>
<li><code>ApplicationContextAware</code>：注入<code>context</code>对象</li>
<li><code>EnvironmentAware</code>：注入<code>Environment</code>对象</li>
</ul>
</li>
<li><code>InitDestroyAnnotationBeanPostProcessor</code>：调用<code>@PostConstruct</code>标注的方法</li>
</ul>
</li>
<li><p><strong>回调初始化方法</strong></p>
<ul>
<li><code>initializingBean</code>的<code>afterPropertiesSet()</code></li>
<li>Bean的<code>init-method</code></li>
</ul>
</li>
<li><p><strong><code>BeanPostProcessors</code>后置处理器</strong></p>
<p> 常用于返回代理对象。</p>
<p> 其中<code>AbstractAutoProxyCreator</code>和 <code>AbstractAdvisingBeanPostProcessor</code>都有可能产生代理对象，如：</p>
<ul>
<li><code>AsyncAnnotationBeanPostProcessor</code>：对<code>@Async</code>进行代理</li>
<li><code>InfrastructureAdvisorAutoProxyCreator</code>：对<code>@Transactional</code>进行代理</li>
</ul>
</li>
<li><p>把最终生成的代理对象放入<strong>单例池</strong>（源码中叫做<code>singletonObjects</code>）中</p>
</li>
</ol>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">initializeBean</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> {</span><br><span class="line">  <span class="comment">// 1: 回调Aware接口中的方法</span></span><br><span class="line">  invokeAwareMethods(beanName, bean);</span><br><span class="line"></span><br><span class="line">   <span class="type">Object</span> <span class="variable">wrappedBean</span> <span class="operator">=</span> bean;</span><br><span class="line">   <span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) {</span><br><span class="line">      <span class="comment">// 2: 调用前置处理器</span></span><br><span class="line">      wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> {</span><br><span class="line">      <span class="comment">// 3: 完成init方法回调</span></span><br><span class="line">      invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 4: 调用后置处理器</span></span><br><span class="line">   <span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) {</span><br><span class="line">      wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> wrappedBean;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>Spring源码系列</category>
      </categories>
      <tags>
        <tag>Spring源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言基础</title>
    <url>/2023/09/01/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li><strong>GOPATH</strong>：代表 Go 语言项目的工作目录，在 Go Module 模式之前非常重要，现在基本上用来存放使用 go get 命令获取的项目。</li>
<li><strong>GOBIN</strong>：代表 Go 编译生成的程序的安装目录，比如通过 go install 命令，会把生成的 Go 程序安装到 GOBIN 目录下，以供你在终端使用。</li>
<li>Go代理：<code>GOPROXY=https://goproxy.cn</code></li>
</ul>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> GOROOT=/usr/local/go </span><br><span class="line"><span class="built_in">export</span> GOPATH=<span class="variable">$HOME</span>/MyDoucument/code/goProject</span><br><span class="line"><span class="built_in">export</span> GOBIN=<span class="variable">$GOPATH</span>/bin</span><br><span class="line"><span class="built_in">export</span> GO111MODULE=on</span><br></pre></td></tr></tbody></table></figure>

<h3 id="编译发布"><a href="#编译发布" class="headerlink" title="编译发布"></a>编译发布</h3><p><code>go build</code>编译生成可执行文件</p>
<p><code>go install</code>把它安装到 <code>$GOBIN</code> 目录或者任意位置</p>
<h3 id="跨平台编译"><a href="#跨平台编译" class="headerlink" title="跨平台编译"></a>跨平台编译</h3><p>Go 语言通过两个环境变量来控制跨平台编译，它们分别是 <code>GOOS</code> 和 <code>GOARCH</code> 。</p>
<ul>
<li><strong>GOOS</strong>：代表要编译的目标操作系统，常见的有 Linux、Windows、Darwin 等。</li>
<li><strong>GOARCH</strong>：代表要编译的目标处理器架构，常见的有 386、AMD64、ARM64 等。</li>
</ul>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">GOOS=linux GOARCH=amd64 go build ./ch01/main.go</span><br></pre></td></tr></tbody></table></figure>

<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><ul>
<li><strong>有符号整型</strong>：如 <code>int</code>、<code>int8</code>、<code>int16</code>、<code>int32</code> 和 <code>int64</code>。</li>
<li><strong>无符号整型</strong>：如 <code>uint</code>、<code>uint8</code>、<code>uint16</code>、<code>uint32</code> 和 <code>uint64</code>。</li>
</ul>
<p>除了有用“位”（bit）大小表示的整型外，还有 int 和 uint 这两个没有具体 bit 大小的整型，它们的大小可能是 32bit，也可能是 64bit，和硬件设备 CPU 有关。</p>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><ul>
<li><code>float32</code> </li>
<li><code>float64</code></li>
</ul>
<h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><ul>
<li><code>complex64</code></li>
<li><code>complex128</code></li>
</ul>
<p>复数有实部和虚部，<code>complex64</code>的实部和虚部为32位，<code>complex128</code>的实部和虚部为64位</p>
<h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p><code>bool</code></p>
<ul>
<li>布尔类型变量的默认值为false。</li>
<li>Go 语言中不允许将整型强制转换为布尔型.</li>
<li>布尔型无法参与数值运算，也无法与其他类型进行转换</li>
</ul>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>*** Go 语言里的字符串的内部实现使用UTF-8编码，每个字符串的底层都是byte数组***</p>
<ul>
<li><em><strong>byte：相当于uint8</strong></em></li>
<li><em><strong>rune：相当于int32</strong></em><ul>
<li>Go 使用了特殊 <code>rune</code> 类型来处理 <code>Unicode</code>（复合字符，包括中文、日文等用多字节表示字符）</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//utf-8遍历</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str); i++ {</span><br><span class="line">    ch := str[i]</span><br><span class="line">    fmt.Printf(<span class="string">"%c \n"</span>, ch)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//Unicode遍历</span></span><br><span class="line"><span class="keyword">for</span> _, ch1 := <span class="keyword">range</span> str {</span><br><span class="line">    fmt.Printf(<span class="string">"%c \n"</span>, ch1)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="Array、Slice、Map"><a href="#Array、Slice、Map" class="headerlink" title="Array、Slice、Map"></a>Array、Slice、Map</h2><p><img src="/../images/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/image_MkJ3W3cuce.png"></p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">array1:=[<span class="number">5</span>]<span class="type">string</span>{<span class="number">1</span>:<span class="string">"b"</span>,<span class="number">3</span>:<span class="string">"d"</span>}</span><br><span class="line"></span><br><span class="line">slice:=array[start:end]</span><br><span class="line"></span><br><span class="line">slice1:=<span class="built_in">make</span>([]<span class="type">string</span>,<span class="number">4</span>,<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">slice2:=<span class="built_in">append</span>(slice1,<span class="string">"f"</span>)</span><br><span class="line"></span><br><span class="line">nameAgeMap:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">nameAgeMap:=<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>{<span class="string">"飞雪无情"</span>:<span class="number">20</span>}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>📌提示</p>
<p>在创建新切片的时候，最好要让新切片的长度和容量一样，这样在追加操作的时候就会生成新的底层数组，从而和原有数组分离，就不会因为共用底层数组导致修改内容的时候影响多个切片。</p>
</blockquote>
<h2 id="函数和方法"><a href="#函数和方法" class="headerlink" title="函数和方法"></a>函数和方法</h2><p>在 Go 语言中，方法和函数是两个概念，但又非常相似，不同点在于方法必须要有一个接收者，这个接收者是一个类型，这样方法就和这个类型绑定在一起，称为这个类型的方法。</p>
<ul>
<li>函数：正常的代码逻辑</li>
<li>方法：特定类型才有，相当于对象的方法</li>
</ul>
<h3 id="值类型接收者和指针类型接收者"><a href="#值类型接收者和指针类型接收者" class="headerlink" title="值类型接收者和指针类型接收者"></a>值类型接收者和指针类型接收者</h3><ul>
<li>值类型接收者：不会改变原来的对象，相当于操作对象的拷贝</li>
<li>指针类型接收者：通过指针可以获取对象地址，可以直接改变原来的对象</li>
</ul>
<blockquote>
<p>提示：在调用方法的时候，传递的接收者本质上都是副本，只不过一个是这个值的副本，一是指向这个值指针的副本。指针具有指向原有值的特性，所以修改了指针指向的值，也就修改了原有的值。<em><strong>我们可以简单地理解为值接收者使用的是值的副本来调用方法，而指针接收者使用实际的值来调用方法。</strong></em></p>
</blockquote>
<blockquote>
<p>📌值接受者方法不会改变原始结构体实例</p>
</blockquote>
<ul>
<li>如果使用一个值类型变量调用指针类型接收者的方法，Go 语言编译器会自动帮我们取指针调用，以满足指针接收者的要求。</li>
<li>同样的原理，如果使用一个指针类型变量调用值类型接收者的方法，Go 语言编译器会自动帮我们解引用调用，以满足值类型接收者的要求。</li>
</ul>
<h3 id="值类型调用者和指针类型调用者"><a href="#值类型调用者和指针类型调用者" class="headerlink" title="值类型调用者和指针类型调用者"></a>值类型调用者和指针类型调用者</h3><p>在官方effective go文档中，对两者区别描述如下：</p>
<ul>
<li><em><strong>值方法（value methods）可以通过指针和值调用，但是指针方法（pointer methods）只能通过指针来调用</strong></em><em><strong>。</strong></em></li>
<li>但有一个例外，如果某个值是可寻址的（addressable，或者说<em>左值</em>），那么编译器会在值调用指针方法时自动插入取地址符，使得在此情形下看起来像指针方法也可以通过值来调用。</li>
</ul>
<hr>
<p>总结：</p>
<ul>
<li>不管是普通对象还是指针，都可以调用他们的值方法和指针方法，因为编译器会自行处理（语法糖</li>
<li><strong>遇事不决请用pointer method！！！</strong></li>
</ul>
<h3 id="通过变量调用方法"><a href="#通过变量调用方法" class="headerlink" title="通过变量调用方法"></a>通过变量调用方法</h3><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">student := Student(<span class="string">"my name is xiaoming, I am "</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法赋值给变量</span></span><br><span class="line">sm := Student.stu</span><br><span class="line">sm2 := (*Student).stu2</span><br><span class="line">sm(student, <span class="number">2</span>)</span><br><span class="line">sm2(&amp;student)</span><br><span class="line">student.stu(<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="结构体和接口"><a href="#结构体和接口" class="headerlink" title="结构体和接口"></a>结构体和接口</h2><p>结构体定义：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">type Stu <span class="class"><span class="keyword">struct</span>{</span></span><br><span class="line">  name <span class="built_in">string</span></span><br><span class="line">  age <span class="type">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名结构体 变量 </span></span><br><span class="line">var stu <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">  name <span class="built_in">string</span></span><br><span class="line">  age <span class="type">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名结构体变量另一种写法</span></span><br><span class="line">newCar := <span class="keyword">struct</span> {</span><br><span class="line">  Make    <span class="built_in">string</span> `json:<span class="string">"make"</span>`</span><br><span class="line">  Model   <span class="built_in">string</span> `json:<span class="string">"model"</span>`</span><br><span class="line">  Mileage <span class="type">int</span>    `json:<span class="string">"mileage"</span>`</span><br><span class="line">}{}</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyStringer interface</span></span><br><span class="line">type MyStringer interface{</span><br><span class="line">  myString() <span class="built_in">string</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><em><strong>以指针类型接收者实现接口的时候，只有对应的指针类型实例才被认为实现了该接口。</strong></em></p>
<p><img src="/../images/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/Ciqc1F-yPMSAZ4k7AABU_GW4VxE080_qJvRefMHb8.png"></p>
<h3 id="工厂函数（构造函数）"><a href="#工厂函数（构造函数）" class="headerlink" title="工厂函数（构造函数）"></a>工厂函数（构造函数）</h3><p>工厂函数一般用于创建自定义的结构体，便于使用者调用</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="type">string</span>)</span></span> *person {</span><br><span class="line">    <span class="keyword">return</span> &amp;person{name:name}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="继承和组合"><a href="#继承和组合" class="headerlink" title="继承和组合"></a>继承和组合</h3><p>在 Go 语言中没有继承的概念，所以结构、接口之间也没有父子关系，Go 语言提倡的是组合，利用组合达到代码复用的目的，这也更灵活。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 组合</span></span><br><span class="line">p:=person{</span><br><span class="line">    age:<span class="number">30</span>,</span><br><span class="line">    name:<span class="string">"飞雪无情"</span>,</span><br><span class="line">    address:address{</span><br><span class="line">        province: <span class="string">"北京"</span>,</span><br><span class="line">        city:     <span class="string">"北京"</span>,</span><br><span class="line">    },</span><br><span class="line">}</span><br><span class="line"><span class="comment">//像使用自己的字段一样，直接使用</span></span><br><span class="line">fmt.Println(p.province)</span><br></pre></td></tr></tbody></table></figure>

<p>类型组合后，外部类型不仅可以使用内部类型的字段，也可以使用内部类型的方法，就像使用自己的方法一样。<br><strong>方法覆写</strong>：如果外部类型定义了和内部类型同样的方法，那么外部类型的会覆盖内部类型，这就是。</p>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>类型断言用来判断一个接口的值是否是实现该接口的某个具体类型。</p>
<p>接口引用拥有断言能力，用于判断当前引用是否属于某个对象的实例</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 接口引用指向子类实例</span></span><br><span class="line"><span class="keyword">var</span> myInterface MyInterface = NewTest(<span class="string">"test"</span>, <span class="number">18</span>, <span class="string">"test"</span>)</span><br><span class="line"><span class="comment">// 判断myInterface是否是Test类型</span></span><br><span class="line"><span class="keyword">if</span> _, ok := myInterface.(*Test);!ok {</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">"myInterface 不是 Test实例"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>在类型断言的时候，同时完成了类型转换</strong></p>
<h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><p>在 Go 语言中，错误是通过内置的 error 接口表示的：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// error 定义</span></span><br><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> {</span><br><span class="line">   Error() <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂函数</span></span><br><span class="line">errors.New(<span class="string">"error"</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong>自定义异常</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> commonError <span class="keyword">struct</span> {</span><br><span class="line">  errorCode <span class="type">int</span>    <span class="comment">//错误码</span></span><br><span class="line">  errorMsg  <span class="type">string</span> <span class="comment">//错误信息</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 实现了Error()就是自定义异常 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ce *commonError)</span></span> Error() <span class="type">string</span> {</span><br><span class="line">  <span class="keyword">return</span> ce.errorMsg</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Error-Wrapping"><a href="#Error-Wrapping" class="headerlink" title="Error Wrapping"></a>Error Wrapping</h3><p>上述自定义异常可以满足我们的需求，但是非常烦琐，因为既要定义新的类型还要实现 error 接口。</p>
<p> Go 语言 1.13 版本开始，Go 标准库新增了 Error Wrapping 功能，让我们可以基于一个存在的 error 生成新的 error，并且可以保留原 error 信息。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// wrap</span></span><br><span class="line">e := errors.New(<span class="string">"原始错误e"</span>)</span><br><span class="line">w := fmt.Errorf(<span class="string">"Wrap了一个错误:%w"</span>, e)</span><br><span class="line">fmt.Println(w)   <span class="comment">// wrap了一个错误:原始错误e</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Unwrap</span></span><br><span class="line">fmt.Println(errors.Unwrap(w))   <span class="comment">// 原始错误e</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="errors-Is"><a href="#errors-Is" class="headerlink" title="errors.Is"></a>errors.Is</h3><p>有了 Error Wrapping 后，你会发现原来用的判断两个 error 是不是同一个 error 的方法失效了，比如 Go 语言标准库经常用到的如下代码中的方式：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">fmt.Println(errors.Is(w, e))  <span class="comment">// true</span></span><br><span class="line">fmt.Println(e == os.ErrExist) <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>errors.ls</code></p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Is</span><span class="params">(err, target <span class="type">error</span>)</span></span> <span class="type">bool</span></span><br></pre></td></tr></tbody></table></figure>

<p>以上就是errors.Is 函数的定义，可以解释为：</p>
<ul>
<li>如果 err 和 target 是同一个，那么返回 true。</li>
<li>如果 err 是一个 wrapping error，target 也包含在这个嵌套 error 链中的话，也返回 true。</li>
</ul>
<blockquote>
<p>📌可以简单地概括为，两个 error 相等或 err 包含 target 的情况下返回 true，其余返回 false。</p>
</blockquote>
<h3 id="errors-As"><a href="#errors-As" class="headerlink" title="errors.As"></a>errors.As</h3><p>同样的原因，有了 error 嵌套后，error 断言也不能用了，因为你不知道一个 error 是否被嵌套，又嵌套了几层。所以 Go 语言为解决这个问题提供了 errors.As 函数，比如前面 error 断言的例子，可以使用  errors.As 函数重写，效果是一样的，如下面的代码所示：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cm *commonError</span><br><span class="line"><span class="keyword">if</span> errors.As(err,&amp;cm){</span><br><span class="line">   fmt.Println(<span class="string">"错误代码为:"</span>,cm.errorCode,<span class="string">"，错误信息为："</span>,cm.errorMsg)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">   fmt.Println(sum)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Deferred"><a href="#Deferred" class="headerlink" title="Deferred"></a>Deferred</h3><p>defer 语句常被用于成对的操作，如文件的打开和关闭，加锁和释放锁，连接的建立和断开等。不管多么复杂的操作，都可以保证资源被正确地释放。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(filename <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) {</span><br><span class="line">   f, err := os.Open(filename)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">defer</span> f.Close()</span><br><span class="line">   <span class="comment">//省略无关代码</span></span><br><span class="line">   <span class="keyword">return</span> readAll(f, n)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>在一个方法或者函数中，可以有多个 defer 语句；</li>
<li>defer 有一个调用栈，多个 defer 语句的执行顺序依照<strong>后进先出</strong>的原则。</li>
</ol>
<h3 id="Panic"><a href="#Panic" class="headerlink" title="Panic"></a>Panic</h3><p>Go 语言是一门静态的强类型语言，很多问题都尽可能地在编译时捕获，但是有一些只能在运行时检查，比如数组越界访问、不相同的类型强制转换等，这类运行时的问题会引起 panic 异常。除了运行时可以产生 panic 外，我们自己也可以抛出 panic 异常。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panic</span><span class="params">(v <span class="keyword">interface</span>{})</span></span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p><code>interface{}</code> 是空接口的意思，在 Go 语言中代表任意类型。</p>
</blockquote>
<p>panic 异常是一种非常严重的情况，会让程序中断运行，使程序崩溃，所以<strong>如果是不影响程序运行的错误，不要使用 panic，使用普通错误 error 即可。</strong></p>
<h4 id="Recover-捕获-Panic-异常"><a href="#Recover-捕获-Panic-异常" class="headerlink" title="Recover 捕获 Panic 异常"></a>Recover 捕获 Panic 异常</h4><p>通常情况下，我们不对 panic 异常做任何处理，因为既然它是影响程序运行的异常，就让它直接崩溃即可。但是也的确有一些特例，比如<strong>在****程序崩溃前做一些资源释放的处理</strong>，这时候就需要从 panic 异常中恢复，才能完成处理。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connectMySQL</span><span class="params">(ip, username, password <span class="type">string</span>)</span></span> {</span><br><span class="line">  <span class="keyword">if</span> ip == <span class="string">""</span> {</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"ip不能为空"</span>)</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//省略其他代码</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> {</span><br><span class="line">      fmt.Println(p)</span><br><span class="line">    }</span><br><span class="line">  }()</span><br><span class="line">  connectMySQL(<span class="string">""</span>, <span class="string">"root"</span>, <span class="string">"123456"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="并发基础"><a href="#并发基础" class="headerlink" title="并发基础"></a>并发基础</h1><h2 id="协程（Goroutine）"><a href="#协程（Goroutine）" class="headerlink" title="协程（Goroutine）"></a>协程（Goroutine）</h2><p>Go 语言中没有线程的概念，只有协程，也称为 goroutine。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> function()</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">ch:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>接收：获取 chan 中的值，操作符为<code> &lt;- chan</code>。</li>
<li>发送：向 chan 发送值，把值放在 chan 中，操作符为 <code>chan &lt;-</code>。</li>
</ol>
<h3 id="无缓冲-channel"><a href="#无缓冲-channel" class="headerlink" title="无缓冲 channel"></a><strong>无缓冲 channel</strong></h3><p>无缓冲 channel，它的容量是 0，不能存储任何数据。所以无缓冲 channel 只起到传输数据的作用，数据并不会在 channel 中做任何停留。这也意味着，无缓冲 channel 的发送和接收操作是同时进行的，它也可以称为同步 channel。</p>
<h3 id="有缓冲-channel"><a href="#有缓冲-channel" class="headerlink" title="有缓冲 channel"></a>有缓冲 channel</h3><p>有缓冲 channel 类似一个可阻塞的队列，内部的元素<em><strong>先进先出</strong></em>。通过 make 函数的第二个参数可以指定 channel 容量的大小，进而创建一个有缓冲 channel。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">cacheCh:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">5</span>)</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/../images/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/CgqCHl-7fzmAVLu0AACSjW-neAE188_bGrO7t8IpW.png"></p>
<p>一个有缓冲 channel 具备以下特点：</p>
<ol>
<li>有缓冲 channel 的内部有一个缓冲队列；</li>
<li>发送操作是向队列的尾部插入元素，如果队列已满，则阻塞等待，直到另一个 goroutine 执行，接收操作释放队列的空间；</li>
<li>接收操作是从队列的头部获取元素并把它从队列中删除，如果队列为空，则阻塞等待，直到另一个 goroutine 执行，发送操作插入新的元素。</li>
</ol>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 获取队列容量和元素个数：</span></span><br><span class="line">fmt.Println(<span class="string">"cacheCh容量为:"</span>,<span class="built_in">cap</span>(cacheCh),<span class="string">",元素个数为："</span>,<span class="built_in">len</span>(cacheCh))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭 channel</span></span><br><span class="line"><span class="built_in">close</span>(cacheCh)</span><br></pre></td></tr></tbody></table></figure>

<p>如果一个 channel 被关闭了，就不能向里面发送数据了，如果发送的话，会引起 painc 异常。但是还可以接收 channel 里的数据，如果 channel 里没有数据的话，接收的数据是元素类型的零值。</p>
<h3 id="单向-channel"><a href="#单向-channel" class="headerlink" title="单向 channel"></a>单向 channel</h3><p>有时候，我们有一些特殊的业务需求，比如限制一个 channel 只可以接收但是不能发送，或者限制一个 channel 只能发送但不能接收，这种 channel 称为单向 channel。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">onlySend := <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span><br><span class="line">onlyReceive:=<span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="select-多路复用"><a href="#select-多路复用" class="headerlink" title="select 多路复用"></a>select 多路复用</h3><blockquote>
<p>小提示：多路复用可以简单地理解为，N 个 channel 中，任意一个 channel 有数据产生，select 都可以监听到，然后执行相应的分支，接收数据并处理。</p>
</blockquote>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> {</span><br><span class="line">   <span class="keyword">case</span> i1 = &lt;-c1:</span><br><span class="line">     <span class="comment">//todo</span></span><br><span class="line">   <span class="keyword">case</span> c2 &lt;- i2:</span><br><span class="line">     <span class="comment">//todo</span></span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">     <span class="comment">// default todo</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="sync-包"><a href="#sync-包" class="headerlink" title="sync 包"></a>sync 包</h2><blockquote>
<p>小技巧：使用 go build、go run、go test 这些 Go 语言工具链提供的命令时，添加 <code>-race</code> 标识可以帮你检查 Go 语言代码是否存在资源竞争。</p>
</blockquote>
<h3 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a><strong>sync.Mutex</strong></h3><p>互斥锁，顾名思义，指的是在同一时刻只有一个协程执行某段代码，其他协程都要等待该协程执行完毕后才能继续执行。</p>
<p>Mutex 的 <code>Lock</code> 和 <code>Unlock</code> 方法总是成对出现，而且要确保 Lock 获得锁后，一定执行 UnLock 释放锁</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>(</span><br><span class="line">   sum <span class="type">int</span></span><br><span class="line">   mutex sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(i <span class="type">int</span>)</span></span> {</span><br><span class="line">   mutex.Lock()</span><br><span class="line">   sum += i</span><br><span class="line">   mutex.Unlock()</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>小提示：以上被加锁保护的 sum+=i 代码片段又称为<strong>临界区</strong>。在同步的程序设计中，临界区段指的是一个访问共享资源的程序片段，而这些共享资源又有无法同时被多个协程访问的特性。</p>
</blockquote>
<h3 id="sync-RWMutex"><a href="#sync-RWMutex" class="headerlink" title="sync.RWMutex"></a>sync.RWMutex</h3><p>go中的读写锁。使用：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mutex sync.RWMutex</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readSum</span><span class="params">()</span></span> <span class="type">int</span> {</span><br><span class="line"></span><br><span class="line">   <span class="comment">//只获取读锁</span></span><br><span class="line">   mutex.RLock()</span><br><span class="line">   <span class="keyword">defer</span> mutex.RUnlock()</span><br><span class="line">   b:=sum</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h3><p>相当于Java中的***<code>CountDownLatch</code>***，用于最终完成的场景，关键点在于一定要等待所有协程都执行完毕。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">   <span class="comment">//因为要监控110个协程，所以设置计数器为110</span></span><br><span class="line">   wg.Add(<span class="number">110</span>)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ {</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">         <span class="comment">//计数器值减1</span></span><br><span class="line">         <span class="keyword">defer</span> wg.Done()</span><br><span class="line">         add(<span class="number">10</span>)</span><br><span class="line">      }()</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>;i++ {</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">         <span class="comment">//计数器值减1</span></span><br><span class="line">         <span class="keyword">defer</span> wg.Done()</span><br><span class="line">         fmt.Println(<span class="string">"和为:"</span>,readSum())</span><br><span class="line">      }()</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">//一直等待，直到计数器值为0</span></span><br><span class="line">   wg.Wait()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h3><p>让代码只执行一次，哪怕是在高并发的情况下，比如创建一个单例。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">   doOnce()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doOnce</span><span class="params">()</span></span> {</span><br><span class="line">   <span class="keyword">var</span> once sync.Once</span><br><span class="line">   onceBody := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">      fmt.Println(<span class="string">"Only once"</span>)</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">//用于等待协程执行完毕</span></span><br><span class="line">   done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//启动10个协程执行once.Do(onceBody)</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">         <span class="comment">//把要执行的函数(方法)作为参数传给once.Do方法即可</span></span><br><span class="line">         once.Do(onceBody)</span><br><span class="line">         done &lt;- <span class="literal">true</span></span><br><span class="line">      }()</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">      &lt;-done</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="sync-Cond"><a href="#sync-Cond" class="headerlink" title="sync.Cond"></a>sync.Cond</h3><p>sync.Cond 可以用于发号施令，一声令下所有协程都可以开始执行，关键点在于协程开始的时候是等待的，要等待 sync.Cond 唤醒才能执行。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//10个人赛跑，1个裁判发号施令</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">race</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">   cond :=sync.NewCond(&amp;sync.Mutex{})</span><br><span class="line">   <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">   wg.Add(<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>; i++ {</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(num <span class="type">int</span>)</span></span> {</span><br><span class="line">         <span class="keyword">defer</span>  wg.Done()</span><br><span class="line">         fmt.Println(num,<span class="string">"号已经就位"</span>)</span><br><span class="line">         cond.L.Lock()</span><br><span class="line">         cond.Wait()<span class="comment">//等待发令枪响</span></span><br><span class="line">         fmt.Println(num,<span class="string">"号开始跑……"</span>)</span><br><span class="line">         cond.L.Unlock()</span><br><span class="line">      }(i)</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">//等待所有goroutine都进入wait状态</span></span><br><span class="line">   time.Sleep(<span class="number">2</span>*time.Second)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">      <span class="keyword">defer</span>  wg.Done()</span><br><span class="line">      fmt.Println(<span class="string">"裁判已经就位，准备发令枪"</span>)</span><br><span class="line">      fmt.Println(<span class="string">"比赛开始，大家准备跑"</span>)</span><br><span class="line">      cond.Broadcast()<span class="comment">//发令枪响</span></span><br><span class="line">   }()</span><br><span class="line">   <span class="comment">//防止函数提前返回退出</span></span><br><span class="line">   wg.Wait()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><strong>Wait</strong>，阻塞当前协程，直到被其他协程调用 Broadcast 或者 Signal 方法唤醒，使用的时候需要加锁，使用 sync.Cond 中的锁即可，也就是 L 字段。</li>
<li><strong>Signal</strong>，唤醒一个等待时间最长的协程。</li>
<li><strong>Broadcast</strong>，唤醒所有等待的协程。</li>
</ol>
<blockquote>
<p>注意：在调用 Signal 或者 Broadcast 之前，要确保目标协程处于 Wait 阻塞状态，不然会出现死锁问题。</p>
</blockquote>
<p>如果你以前学过 Java，会发现 sync.Cond 和 Java 的等待唤醒机制很像，它的三个方法 Wait、Signal、Broadcast 就分别对应 Java 中的 wait、notify、notifyAll。</p>
<h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><blockquote>
<p>一个任务会有很多个协程协作完成，一次 HTTP 请求也会触发很多个协程的启动，而这些协程有可能会启动更多的子协程，并且无法预知有多少层协程、每一层有多少个协程。</p>
<p>如果因为某些原因导致任务终止了，HTTP 请求取消了，那么它们启动的协程怎么办？该如何取消呢？因为取消这些协程可以节约内存，提升性能，同时避免不可预料的 Bug。</p>
<p>Context 就是用来简化解决这些问题的，并且是并发安全的。Context 是一个接口，它具备手动、定时、超时发出取消信号、传值等功能，主要用于控制多个协程之间的协作，尤其是取消操作。一旦取消指令下达，那么被 Context 跟踪的这些协程都会收到取消信号，就可以做清理和退出操作。</p>
</blockquote>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> {</span><br><span class="line"></span><br><span class="line">   Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">   Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{}</span><br><span class="line">   Err() <span class="type">error</span></span><br><span class="line">   Value(key <span class="keyword">interface</span>{}) <span class="keyword">interface</span>{}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Context-树"><a href="#Context-树" class="headerlink" title="Context 树"></a>Context 树</h3><p>Go 语言提供了函数可以帮助我们生成不同的 Context，通过这些函数可以生成一颗 Context 树，这样 Context 才可以关联起来，父 Context 发出取消信号的时候，子 Context 也会发出，这样就可以控制不同层级的协程退出。</p>
<p>从使用功能上分，有四种实现好的 Context。</p>
<ol>
<li><strong>空 Context</strong>：不可取消，没有截止时间，主要用于 Context 树的根节点。</li>
<li><strong>可取消的 Context</strong>：用于发出取消信号，当取消的时候，它的子 Context 也会取消。</li>
<li><strong>可定时取消的 Context</strong>：多了一个定时的功能。</li>
<li><strong>值 Context</strong>：用于存储一个 key-value 键值对。</li>
</ol>
<p><img src="/../images/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/CgqCHl_EyHOARbBqAAKzKmhclWo807_j9j7DgBnzy.png"></p>
<p><code> context.Background()</code>获取一个根节点 Context。</p>
<hr>
<p> Context 树要怎么生成呢？</p>
<ol>
<li>**<code>WithCancel(parent Context)</code>**：生成一个可取消的 Context。<ol>
<li>**<code>WithDeadline(parent Context, d time.Time)</code>**：生成一个可定时取消的 Context，参数 d 为定时取消的具体时间。<ol>
<li>**<code>WithTimeout(parent Context, timeout time.Duration)</code>**：生成一个可超时取消的 Context，参数 timeout 用于设置多久后取消</li>
</ol>
</li>
</ol>
</li>
<li>**<code>WithValue(parent Context, key, val interface{})</code>**：生成一个可携带 key-value 键值对的 Context。</li>
</ol>
<p>以上四个生成 Context 的函数中，前三个都属于可取消的 Context，它们是一类函数，最后一个是值 Context，用于存储一个 key-value 键值对。</p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    name:=<span class="string">"xiaoming"</span></span><br><span class="line">    <span class="keyword">var</span> nameP *<span class="type">string</span> = &amp;name</span><br><span class="line">    fmt.Println(*nameP)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>获取一个变量的指针非常容易，使用取地址符 &amp; 就可以</p>
</li>
<li><p>指针类型就是在对应的类型前加 * 号</p>
</li>
<li><p>指针类型非常廉价，只占用 4 个或者 8 个字节的内存大小。</p>
</li>
<li><p><em><strong>通过 var 声明的指针变量还没有分配内存</strong></em>，因为这时候它仅仅是个变量，是不能直接赋值和取值的，它的值是 nil </p>
<p><img src="/../images/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/image_xouftL6NE6.png" alt="直接赋值和取值" title="直接赋值和取值"></p>
<p>解决方法：将一块内存地址<code>&amp;m</code>赋值给指针变量<code>*p</code></p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> m <span class="type">int</span></span><br><span class="line">p = &amp;m</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>通过new创建的指针是存在内存地址的，可以直接赋值</p>
<ul>
<li><code>var intP *int = new(int)</code></li>
</ul>
</li>
</ul>
<h1 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h1><p><strong>严格来说，Go 语言没有引用类型</strong>，但是我们可以把 map、chan 称为引用类型，这样便于理解。除了 map、chan 之外，Go 语言中的函数、接口、slice 切片、指针都可以称为引用类型。</p>
<p><img src="/../images/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/image_B8036E8m0p.png"></p>
<p>总结：</p>
<p>在 Go 语言中，<strong>函数的参数传递只有值传递</strong>，而且传递的实参都是原始数据的一份拷贝。</p>
<p>如果拷贝的内容是值类型的，那么在函数中就无法修改原始数据；</p>
<p>如果拷贝的内容是指针（或者可以理解为引用类型 map、chan 等），那么就可以在函数中修改原始数据。</p>
<h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1><ul>
<li>指针类型的变量如果没有分配内存，就默认是零值 nil，它没有指向的内存，所以无法使用，强行使用就会得到以上 nil 指针错误</li>
<li>对于值类型来说，即使只声明一个变量，没有对其初始化，该变量也会有分配好的内存。</li>
<li>两个关键函数：new和make</li>
</ul>
<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>new 函数只用于分配内存，并且把内存清零，也就是返回一个指向对应类型零值的指针。new 函数一般用于需要显式地返回指针的情况，不是太常用。</p>
<h2 id="make"><a href="#make" class="headerlink" title="make"></a>make</h2><p>make 函数只用于 slice、chan 和 map 这三种内置类型的创建和初始化，因为这三种类型的结构比较复杂，比如 slice 要提前初始化好内部元素的类型，slice 的长度和容量等，这样才可以更好地使用它们。</p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><ul>
<li><p><strong><code>reflect.Value</code></strong> 和**<code>reflect.Type</code>**</p>
<p>在 Go 语言的反射定义中，任何接口都由两部分组成：接口的具体类型，以及具体类型对应的值。比如 var i int = 3，因为 <code>interface{}</code> 可以表示任何类型，所以变量 i 可以转为 interface{}。其中 Value 为变量的值，即 3，而 Type 为变量的类型，即 int。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">i:=<span class="number">3</span></span><br><span class="line">iv:=reflect.ValueOf(i)</span><br><span class="line">it:=reflect.TypeOf(i)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>修改变量</p>
<p>要修改一个变量的值，有几个关键点：传递指针（可寻址），通过 Elem 方法获取指向的值，才可以保证值可以被修改，reflect.Value 为我们提供了 CanSet 方法判断是否可以修改该变量。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">ipv := reflect.ValueOf(&amp;i)</span><br><span class="line">ipv.Elem().SetInt(<span class="number">4</span>)</span><br><span class="line">fmt.Println(i)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>反射的三大定律</p>
<ol>
<li>任何接口值 <code>interface{}</code> 都可以反射出反射对象，也就是 reflect.Value 和 reflect.Type，通过函数 reflect.ValueOf 和 reflect.TypeOf 获得。</li>
<li>反射对象也可以还原为 interface{} 变量，也就是第 1 条定律的可逆性，通过 reflect.Value 结构体的 Interface 方法获得。</li>
<li>要修改反射的对象，该值必须可设置，也就是可寻址，参考上节课修改变量的值那一节的内容理解。</li>
</ol>
</li>
</ul>
<h1 id="SliceHeader"><a href="#SliceHeader" class="headerlink" title="SliceHeader"></a>SliceHeader</h1><ul>
<li><p>在 Go 语言中，切片其实是一个结构体，定义如下：</p>
<p><img src="/../images/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/image_GCPR--tEED.png"></p>
<p>SliceHeader 是切片在运行时的表现形式，它有三个字段 Data、Len 和 Cap。</p>
<ol>
<li>Data 用来指向存储切片元素的数组。</li>
<li>Len 代表切片的长度。</li>
<li>Cap 代表切片的容量。</li>
</ol>
</li>
<li><p>优点</p>
<ol>
<li>支持动态扩容</li>
<li>切片的本质是 SliceHeader，又因为函数的参数是值传递，所以传递的是 SliceHeader 的副本，而不是底层数组的副本。这时候切片的优势就体现出来了，因为 SliceHeader 的副本内存占用非常少，即使是一个非常大的切片，也顶多占用 24 个字节的内存，这就解决了大数组在传参时内存浪费的问题。</li>
</ol>
</li>
</ul>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ul>
<li>测试文件以_test.go结尾</li>
<li>测试函数以Testxxx（xxx为测试函数名）开头</li>
</ul>
<p>假设编写的函数在<em>ch18/main.go</em>中：<code>go test -v ./ch18</code></p>
<hr>
<ul>
<li>go test -v –coverprofile=ch18.cover ./ch18：得到一个单元测试覆盖率文件</li>
</ul>
<h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h2><p>衡量代码的性能</p>
<ul>
<li><p>函数必须以 Benchmark 开头</p>
</li>
<li><p>函数的签名必须接收一个指向 testing.B 类型的指针，并且不能返回任何值；</p>
</li>
<li><p>最后的 for 循环很重要，被测试的代码要放到循环里；</p>
</li>
<li><p>b.N 是基准测试框架提供的，表示循环的次数，因为需要反复调用测试的代码，才可以评估性能。</p>
</li>
<li><p>运行：<code>go test -bench=. ./ch18</code></p>
<p><img src="/../images/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/image_TRt00J58vX.png"></p>
</li>
<li><p>计时方法</p>
<p><img src="/../images/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/image_3wVKmmQ8bg.png"></p>
</li>
<li><p>内存统计</p>
<p><img src="/../images/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/image_MfFsm1QCxq.png"></p>
</li>
<li><p>并发基准测试</p>
<p><img src="/../images/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/image_MgQUA96T3S.png"></p>
</li>
</ul>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>Go的泛型使用<code>interface</code>实现</p>
<ul>
<li>an approximation element <code>~T</code> restricts to all types whose underlying type is T: 代表底层类型是<code>T</code></li>
<li>a union element <code>T1 | T2 | ...</code> restricts to any of the listed elements: 代表<code>或</code>,类型列表之一。</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 任意类型 any</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span>[<span class="title">T1</span>, <span class="title">T2</span> <span class="title">any</span>]<span class="params">(x <span class="type">int</span>, y T1)</span></span> T2 {</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Integer <span class="keyword">interface</span> {</span><br><span class="line">  Signed | Unsigned</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Signed <span class="keyword">interface</span> {</span><br><span class="line">  ~<span class="type">int</span> | ~<span class="type">int8</span> | ~<span class="type">int16</span> | ~<span class="type">int32</span> | ~<span class="type">int64</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Unsigned <span class="keyword">interface</span> {</span><br><span class="line">  ~<span class="type">uint</span> | ~<span class="type">uint8</span> | ~<span class="type">uint16</span> | ~<span class="type">uint32</span> | ~<span class="type">uint64</span> | ~<span class="type">uintptr</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型抽象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span>[<span class="title">T</span> <span class="title">Integer</span>]<span class="params">(input T)</span></span> T {</span><br><span class="line">  <span class="keyword">if</span> input &lt; <span class="number">0</span> {</span><br><span class="line">    <span class="keyword">return</span> -input</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> input</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC基础</title>
    <url>/2023/09/03/JUC%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>线程的生命周期分为五种状态：</p>
<ul>
<li>新生 <code>NEW</code></li>
<li>运行 <code>RUNNABLE</code></li>
<li>阻塞 <code>BLOCKED</code></li>
<li>等待 <code>WAITING</code></li>
<li>超时等待<code>TIME_WAITING</code></li>
<li>终止 <code>TERMINATED</code></li>
</ul>
<p>在操作系统层面，线程有 READY 和 RUNNING 状态；而在 JVM 层面，只能看到 RUNNABLE 状态</p>
<span id="more"></span>

<p><strong>为什么 JVM 没有区分这两种状态呢？</strong> </p>
<p> 现在的时分多任务操作系统架构通常都是用所谓的“时间分片”方式进行抢占式轮转调度。这个时间分片通常是很小的，一个线程一次最多只能在 CPU 上运行比如 10-20ms 的时间（此时处于 running 状态），也即大概只有 0.01 秒这一量级，时间片用后就要被切换下来放入调度队列的末尾等待再次调度。（也即回到 ready 状态）。<em>线程切换的如此之快，区分这两种状态就没什么意义了。</em></p>
<h2 id="wait-sleep"><a href="#wait-sleep" class="headerlink" title="wait/sleep"></a>wait/sleep</h2><p><strong>区别</strong>：</p>
<ul>
<li><p><strong><code>sleep()</code></strong>** 方法没有释放锁，而 <strong><strong><code>wait()</code></strong></strong> 方法释放了锁** 。这是因为<code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，不会操作对象锁，而<code>wait()</code> 则是 <code>Object</code> 类的本地方法，让获得对象锁的线程实现等待</p>
</li>
<li><p><code>wait()</code> 方法被调用后，<em>线程不会自动苏醒</em>，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</p>
</li>
</ul>
<p>因此，<code>wait()</code> 通常被用于线程间交互/通信，<code>sleep()</code>通常被用于暂停当前线程的执行。</p>
<p><strong>为什么 wait() 方法不定义在 Thread 中？</strong></p>
<p><code>wait()</code> 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入等待状态，自然是要操作对应的对象而非当前的线程。</p>
<h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><p><strong>公平锁：</strong> 十分公平，必须先来后到；</p>
<p><strong>非公平锁：</strong> 十分不公平，可以插队；**(默认)**</p>
<h2 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h2><p>lock三部曲</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1.</span> Lock lock=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> lock.lock() 加锁</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> <span class="keyword">finally</span>=&gt; 解锁：lock.unlock();</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Synchronized锁-与Lock锁-的区别"><a href="#Synchronized锁-与Lock锁-的区别" class="headerlink" title="Synchronized锁 与Lock锁 的区别"></a>Synchronized锁 与Lock锁 的区别</h2><ul>
<li>Synchronized 无法判断获取<strong>锁的状态</strong>，Lock可以判断</li>
<li>Synchronized 会<strong>自动释放锁</strong>，lock必须要手动加锁和手动释放锁！可能会遇到死锁</li>
<li>Synchronized 线程1(获得锁-&gt;阻塞)、线程2(等待)；lock就不一定会一直等待下去，lock会有一个<strong>trylock</strong>去尝试获取锁，不会造成长久的等待。</li>
<li>Synchronized <strong>是可重入锁</strong>，不可以中断的，<strong>非公平的</strong>；Lock是可重入的，可以判断锁，可以自己设置公平锁和非公平锁；</li>
<li>Synchronized 适合锁少量的代码同步问题，Lock适合锁大量的同步代码；</li>
</ul>
<h2 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h2><p>实现类：<code>FutureTask</code>，可以获取到线程执行完毕的结果</p>
<p><code>Callable</code>与<code>Runable</code>的区别：</p>
<ul>
<li><code>Callable</code>可以有返回值</li>
<li><code>Callable</code>可以抛出异常，而<code>Runnable</code>不能抛出被检查的异常</li>
<li>启动方法不同</li>
</ul>
<h2 id="线程安全类集合"><a href="#线程安全类集合" class="headerlink" title="线程安全类集合"></a>线程安全类集合</h2><h3 id="List类"><a href="#List类" class="headerlink" title="List类"></a>List类</h3><ul>
<li><p><code>Vector</code></p>
</li>
<li><p><code>Collections.synchronizedList()</code></p>
</li>
<li><p><code>CopyOnWriteArrayList</code></p>
<p>  适用于读多写少的场景</p>
<p>  核心思想是：如果有多个调用者同时要求相同的资源，他们会共同获取相同的指针指向相同的资源，直到某个调用者视图修改资源内容时，系统才会真正复制一份专用副本给该调用者，而其他调用者所见到的最初的资源仍然保持不变。</p>
<p>  读的时候不需要加锁，如果读的时候有多个线程正在向CopyOnWriteArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的CopyOnWriteArrayList。</p>
</li>
</ul>
<p>**<code>CopyOnWriteArrayList</code><strong>比</strong><code>Vector</code>**区别？</p>
<ul>
<li>**<code>Vector</code><strong>底层是使用</strong><code>synchronized</code>**关键字来实现的，效率低下</li>
<li>**<code>CopyOnWriteArrayList</code>**使用的是Lock锁，更加高效</li>
</ul>
<h3 id="Set类"><a href="#Set类" class="headerlink" title="Set类"></a>Set类</h3><ul>
<li><code>Collections.synchronizedSet()</code></li>
<li><code>CopyOnWriteArraySet</code></li>
</ul>
<h3 id="Map类"><a href="#Map类" class="headerlink" title="Map类"></a>Map类</h3><ul>
<li><code>Collections.synchronizedMap()</code></li>
<li><code>ConcurrentHashMap</code></li>
<li><code>HashTable</code></li>
</ul>
<h1 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h1><h2 id="生产者和消费者问题"><a href="#生产者和消费者问题" class="headerlink" title="生产者和消费者问题"></a>生产者和消费者问题</h2><p>这是一个经典的线程通信问题。两组线程共享一个缓冲区。生产者将数据放入缓冲区，消费者将数据从缓冲区取出</p>
<p>demo如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProviderConsumer</span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span>  <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断等待、业务、通知</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        }</span><br><span class="line">        num++;</span><br><span class="line">       System.out.println(Thread.currentThread().getName() + <span class="string">" increment num "</span> + num);</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        }</span><br><span class="line">        num--;</span><br><span class="line">       System.out.println(Thread.currentThread().getName() + <span class="string">" decrement num "</span> + num);</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ProviderConsumer</span> <span class="variable">providerConsumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProviderConsumer</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    providerConsumer.increment();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    providerConsumer.decrement();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"B"</span>).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong>虚假唤醒问题</strong></p>
<blockquote>
<p>当一定的条件触发时会唤醒很多在阻塞态的线程，但只有部分的线程唤醒是有用的，其余线程的唤醒是多余的。  </p>
</blockquote>
<p>  <a href="https://blog.csdn.net/weixin_45668482/article/details/117373700?ydreferer=aHR0cHM6Ly9jbi5iaW5nLmNvbS8=">https://blog.csdn.net/weixin_45668482/article/details/117373700?ydreferer=aHR0cHM6Ly9jbi5iaW5nLmNvbS8%3D</a></p>
<p>解决虚假唤醒问题：应该将唤醒放在循环中，不满足条件需要继续等待</p>
<p>换句话说：将if替换成while。当使用<code>notifyAll()</code>时，所有的线程都将被唤醒，如果使用的是if，不会再次进行条件判断，因此被唤醒的可能是消费者，也可能是生产者。而使用while的时候，会再次进行等待判断，从而避免虚假唤醒问题。</p>
<h3 id="Lock-Condition实现"><a href="#Lock-Condition实现" class="headerlink" title="Lock + Condition实现"></a>Lock + Condition实现</h3><p>Lock锁的Condition可以精准通知唤醒的线程，从而<strong>控制多个线程的执行顺序</strong></p>
<p>demo：多个线程轮流输出A B C</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestCondition</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition3</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 1A 2B 3C</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printA</span><span class="params">()</span> {</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 业务代码 判断 -&gt; 执行 -&gt; 通知</span></span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">1</span>) {</span><br><span class="line">                condition1.await();</span><br><span class="line">            }</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"==&gt; AAAA"</span> );</span><br><span class="line">            num = <span class="number">2</span>;</span><br><span class="line">            condition2.signal();</span><br><span class="line">        }<span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printB</span><span class="params">()</span> {</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">2</span>) {</span><br><span class="line">                condition2.await();</span><br><span class="line">            }</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"==&gt; BBBB"</span> );</span><br><span class="line">            num = <span class="number">3</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        }<span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printC</span><span class="params">()</span> {</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">3</span>) {</span><br><span class="line">                condition3.await();</span><br><span class="line">            }</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"==&gt; CCCC"</span> );</span><br><span class="line">            num = <span class="number">1</span>;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        }<span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h3 id="BlockingQueue实现生产者消费者问题"><a href="#BlockingQueue实现生产者消费者问题" class="headerlink" title="BlockingQueue实现生产者消费者问题"></a>BlockingQueue实现生产者消费者问题</h3><p>BlockingQueue是Java自带的阻塞队列，内部的原理也是使用了ReentrantLock + Condition实现</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    BlockingQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">producer</span> <span class="operator">=</span> () -&gt; {</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                queue.put(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(producer).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(producer).start();</span><br><span class="line">    </span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">consumer</span> <span class="operator">=</span> () -&gt; {</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                queue.take();</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(consumer).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(consumer).start();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="Java中的线程协作"><a href="#Java中的线程协作" class="headerlink" title="Java中的线程协作"></a>Java中的线程协作</h1><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>倒计数锁存器，可以用作一个<strong>简单的开/关锁存器，或者门</strong>：所有线程调用<code>await()</code>在门口等待，直到被调用<code>countDown()</code>的线程打开。</p>
<p>CountDownLatch一个有用的属性是，它不要求调用countDown线程等待计数到达零之前相互等待，它只是阻止任何线程通过await，直到所有线程可以通过。</p>
<p>常用方法：</p>
<ul>
<li>**<code>countDown()</code>**减一操作；</li>
<li><strong><code>await()</code></strong> 等待计数器归零</li>
</ul>
<h3 id="CyclickBarrier"><a href="#CyclickBarrier" class="headerlink" title="CyclickBarrier"></a>CyclickBarrier</h3><p>循环屏障，它允许一组线程全部等待彼此达到共同屏障点的同步辅助。循环阻塞在涉及固定大小的线程方的程序中很有用，这些线程必须偶尔等待彼此。屏障被称为循环，因为它可以在等待的线程被释放之后重新使用。</p>
<p>常用方法包括：</p>
<ul>
<li><strong><code>await()</code></strong>: 调用该方法的线程到达屏障点，并等待其他线程到达。如果是最后一个到达的线程，将执行可选的任务。</li>
<li><code>await(long timeout, TimeUnit unit)</code>: 调用该方法的线程到达屏障点，并等待其他线程到达，但最多等待指定的时间。</li>
<li><code>getParties()</code>: 返回需要到达屏障点的总线程数。</li>
<li><code>isBroken()</code>: 检查屏障是否被破坏（是否有线程等待超时）。</li>
</ul>
<p>**<code>CyclicBarrier </code>****与 ****<code>CountDownLatch </code>**<strong>区别</strong></p>
<ul>
<li><code>CountDownLatch</code>是一次性的，<code>CyclicBarrier</code> 是可以重用的</li>
<li><code>CountDownLatch</code>中有两个关键，一个是<code>countDown()</code>，一个是<code>awit()</code>，调用<code>awit()</code>的线程需要等待，调用<code>countDown()</code>的线程会将倒计时-1，不同的线程职责可能是不同的，被管理的是调用了<code>awit()</code>的线程，计数器可以是单独的逻辑。</li>
</ul>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>信号量，用于控制同时访问某个资源的线程数量。它可以用来限制并发访问的线程数，或者用于线程间的信号通知。</p>
<p><code>Semaphore</code> 维护了一组许可（permits），线程在访问资源之前必须先获得许可，如果许可数不足，则线程必须等待，直到有可用的许可为止。每个 <code>Semaphore</code> 对象都有一个初始许可数，表示可同时访问该资源的线程数。</p>
<p>假设信号量初始数量为sem：</p>
<p>  P 操作：申请一个许可，将 sem 减 1，相减后，如果 <code>sem &lt; 0</code>，则进程/线程进入阻塞等待，否则继续，表明 P 操作可能会阻塞；</p>
<p>  V 操作：释放一个许可，将 sem 加 1，相加后，如果<code> sem &lt;= 0</code>，唤醒一个等待中的进程/线程，表明 V 操作不会阻塞；</p>
<p>常用方法：</p>
<ul>
<li><strong><code>acquire()</code></strong>: 获取一个许可，如果没有可用许可，则线程会被阻塞，直到有可用许可。</li>
<li><strong><code>release()</code></strong>: 释放一个许可，将其返回给 <code>Semaphore</code>。</li>
<li><code>tryAcquire()</code>: 尝试获取一个许可，如果获取成功则返回 true，否则返回 false。</li>
<li><code>availablePermits()</code>: 返回当前可用的许可数。</li>
</ul>
<h2 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h2><p>读写锁，控制对共享资源访问的同步机制。它允许多个线程同时读取资源，但只允许一个线程独占写入资源。</p>
<p>ReadWriteLock的目的是在资源被读取的频率高于写入的情况下优化性能。通过允许并发读取，多个线程可以同时访问资源，这可以提高吞吐量并减少线程之间的竞争。然而，当一个线程希望修改资源时，它需要独占访问以确保一致性。</p>
<h2 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork/Join"></a>Fork/Join</h2><p>核心思想：<strong>分而治之</strong></p>
<p>Fork-Join模型的核心思想是关键概念是”fork”（分叉）和”join”（合并），即将一个大任务划分为若干个小任务，然后并行地执行这些小任务，最后将它们的结果组合起来得到最终的结果。这个过程可以递归地进行，即每个小任务也可以再次划分成更小的子任务，直到任务的规模足够小以至于可以被直接执行。</p>
<p>两个实现类：</p>
<ul>
<li><code>RecursiveTask</code>有返回值</li>
<li><code>RecursiveAction</code>没有返回值</li>
</ul>
<p>Fork/Join框架的优势在于它能够自动地将任务划分成合适的大小，并利用多核处理器上的并行性提高程序的性能。它也提供了一些优化技术，如<em><strong>工作窃取（work stealing）</strong></em>，可以确保各个线程在执行任务时能够充分利用系统资源。</p>
<h3 id="工作窃取原理"><a href="#工作窃取原理" class="headerlink" title="工作窃取原理"></a>工作窃取原理</h3><ol>
<li>每个工作线程都有一个本地的工作队列（<em>双端队列</em>），用于存储待执行的任务。使用双端队列作为本地工作队列的好处在于，工作线程可以高效地从队列的头部或尾部执行插入和删除操作。当工作线程执行任务时，它会从队列的头部获取任务并执行；而当工作线程尝试窃取任务时，它会从队列的尾部插入窃取到的任务。</li>
<li>当一个工作线程的本地工作队列为空时，它会尝试从其他工作线程的工作队列中窃取任务。这个窃取的目标通常是选择一个相对较繁忙的工作线程，即其工作队列中有更多任务等待执行。</li>
<li>工作线程可以从目标工作线程的工作队列的顶部（头部）或者底部（尾部）窃取任务。选择窃取的位置可以根据具体的实现策略来确定，不同的实现方式可能有所不同。</li>
<li>窃取任务的过程通常是通过线程间的原子操作来实现的，以确保并发的正确性。例如，可以使用CAS（Compare and Swap）操作来保证任务的窃取是原子的。</li>
<li>当一个工作线程成功地窃取到任务后，它会将任务添加到自己的本地工作队列中，并继续执行窃取到的任务。</li>
</ol>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>LSTM复现</title>
    <url>/2024/10/28/LSTM%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>长短期记忆网络（Long Short-Term Memory, LSTM）是一种特殊的循环神经网络（Recurrent Neural Network, RNN），能够有效地学习和记忆长期依赖关系。由于其在处理序列数据方面的卓越表现，LSTM在自然语言处理、语音识别、时间序列预测等领域得到了广泛应用。本文将通过介绍LSTM的基本原理，并结合源码实现，帮助读者深入理解并复现LSTM模型。</p>
<p><img src="/../images/LSTM%E5%A4%8D%E7%8E%B0/image_miFIeYOq26.png" alt="LSTM架构示意图 LSTM架构示意图 " title="LSTM架构示意图 LSTM架构示意图 "></p>
<h2 id="LSTM介绍"><a href="#LSTM介绍" class="headerlink" title="LSTM介绍"></a>LSTM介绍</h2><h3 id="1-循环神经网络（RNN）概述"><a href="#1-循环神经网络（RNN）概述" class="headerlink" title="1. 循环神经网络（RNN）概述"></a>1. 循环神经网络（RNN）概述</h3><p>循环神经网络（RNN）是一种用于处理序列数据的神经网络结构。与传统的前馈神经网络不同，RNN具有内部的循环连接，能够在隐藏层中保留前一时刻的信息，从而捕捉序列中的时序特征。然而，标准的RNN在处理较长序列时，容易出现梯度消失或梯度爆炸的问题，导致模型难以学习长期依赖关系。</p>
<h3 id="2-LSTM的诞生"><a href="#2-LSTM的诞生" class="headerlink" title="2. LSTM的诞生"></a>2. LSTM的诞生</h3><p><strong>RNN存在的问题</strong>：RNN虽然在理论上可以保留所有历史时刻的信息，但在实际使用时，信息的传递往往会因为时间间隔太长而逐渐衰减，传递一段时刻以后其信息的作用效果就大大降低了。因此，普通RNN对于信息的长期依赖问题没有很好的处理办法。而LSTM克服了这个问题，可以学习长期依赖信息</p>
<p>LSTM由Hochreiter和Schmidhuber在1997年提出，旨在解决标准RNN在长序列中的训练困难。LSTM通过引入门控机制，有效地控制信息的流动，能够在较长时间步内保持有用的信息，同时过滤掉无关或干扰的信息。</p>
<p>LSTM的关键是细胞状态 Ct，用来保存当前LSTM的状态信息并传递到下一时刻的LSTM中，也就是RNN中那根“自循环”的箭头。当前的LSTM接收来自上一个时刻的细胞状态 Ct−1，并与当前LSTM接收的信号输入 xt共同作用产生当前LSTM的细胞状态 Ct</p>
<h3 id="3-LSTM的结构与工作原理"><a href="#3-LSTM的结构与工作原理" class="headerlink" title="3. LSTM的结构与工作原理"></a>3. LSTM的结构与工作原理</h3><p>LSTM单元主要由以下几个部分组成：</p>
<ul>
<li><strong>遗忘门（Forget Gate）</strong>：决定保留多少过去的信息。</li>
<li><strong>输入门（Input Gate）</strong>：决定引入多少新的信息。</li>
<li><strong>输出门（Output Gate）</strong>：决定将多少当前的信息输出。</li>
</ul>
<p>每个门都由一个Sigmoid神经网络层组成，输出值在0到1之间，用以控制信息的流动。具体结构如下图所示：</p>
<p><img src="https://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-chain.png" alt="LSTM单元结构" title="LSTM单元结构"></p>
<p><em>图2：LSTM单元结构</em></p>
<h4 id="具体计算过程"><a href="#具体计算过程" class="headerlink" title="具体计算过程"></a>具体计算过程</h4><p>假设在时间步$t$，输入为$x_t$，前一时刻的隐藏状态为$h_{t-1}$，细胞状态为$c_{t-1}$，则LSTM的计算过程如下：</p>
<ol>
<li><p><strong>遗忘门</strong>：</p>
 <span>
 $$
 f_t = \sigma(W_f \cdot [h_{t-1}, x_t] + b_f) 
 $$
 </span>
</li>
<li><p><strong>输入门</strong>：</p>
</li>
</ol>
<span>
   $$
   i_t = \sigma(W_i \cdot [h_{t-1}, x_t] + b_i) 
   $$
</span>

<span>
   $$
   \tilde{C}_t = \tanh(W_C \cdot [h_{t-1}, x_t] + b_C) 
   $$
</span>

<ol start="3">
<li><p><strong>更新细胞状态</strong>：</p>
<p>$$<br>C_t = f_t * C_{t-1} + i_t * \tilde{C}_t<br>$$</p>
</li>
<li><p><strong>输出门</strong>：</p>
<p>$$<br>o_t = \sigma(W_o \cdot [h_{t-1}, x_t] + b_o)<br>$$</p>
<p>$$<br>h_t = o_t * \tanh(C_t)<br>$$</p>
</li>
</ol>
<p>其中，$\sigma$表示Sigmoid函数，$*$表示逐元素相乘。</p>
<h2 id="LSTM源码实现"><a href="#LSTM源码实现" class="headerlink" title="LSTM源码实现"></a>LSTM源码实现</h2><p>本文将以PyTorch框架为例，手把手实现一个简单的LSTM网络，并应用于字符级的文本预测任务。</p>
<h3 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h3><p>首先，确保已经安装了PyTorch。可以使用以下命令进行安装：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">pip install torch</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-数据准备"><a href="#2-数据准备" class="headerlink" title="2. 数据准备"></a>2. 数据准备</h3><p>以莎士比亚的文本为例，我们将其作为训练数据，用于预测下一个字符。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取文本数据</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'shakespeare.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    text = f.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建字符到索引的映射</span></span><br><span class="line">chars = <span class="built_in">sorted</span>(<span class="built_in">list</span>(<span class="built_in">set</span>(text)))</span><br><span class="line">char_to_idx = {ch: i <span class="keyword">for</span> i, ch <span class="keyword">in</span> <span class="built_in">enumerate</span>(chars)}</span><br><span class="line">idx_to_char = {i: ch <span class="keyword">for</span> i, ch <span class="keyword">in</span> <span class="built_in">enumerate</span>(chars)}</span><br><span class="line"></span><br><span class="line">vocab_size = <span class="built_in">len</span>(chars)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f'字符集大小: <span class="subst">{vocab_size}</span>'</span>)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-模型定义"><a href="#3-模型定义" class="headerlink" title="3. 模型定义"></a>3. 模型定义</h3><p>定义一个LSTM类，继承自<code>nn.Module</code>。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LSTMModel</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, input_size, hidden_size, output_size, num_layers=<span class="number">1</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(LSTMModel, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.hidden_size = hidden_size</span><br><span class="line">        <span class="variable language_">self</span>.num_layers = num_layers</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 定义LSTM层</span></span><br><span class="line">        <span class="variable language_">self</span>.lstm = nn.LSTM(input_size, hidden_size, num_layers, batch_first=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 定义全连接层</span></span><br><span class="line">        <span class="variable language_">self</span>.fc = nn.Linear(hidden_size, output_size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, hidden</span>):</span><br><span class="line">        <span class="comment"># LSTM前向传播</span></span><br><span class="line">        out, hidden = <span class="variable language_">self</span>.lstm(x, hidden)</span><br><span class="line">        <span class="comment"># 取最后一个时间步的输出</span></span><br><span class="line">        out = out[:, -<span class="number">1</span>, :]</span><br><span class="line">        out = <span class="variable language_">self</span>.fc(out)</span><br><span class="line">        <span class="keyword">return</span> out, hidden</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">init_hidden</span>(<span class="params">self, batch_size</span>):</span><br><span class="line">        <span class="comment"># 初始化隐藏状态和细胞状态</span></span><br><span class="line">        weight = <span class="built_in">next</span>(<span class="variable language_">self</span>.parameters()).data</span><br><span class="line">        hidden = (weight.new(<span class="variable language_">self</span>.num_layers, batch_size, <span class="variable language_">self</span>.hidden_size).zero_(),</span><br><span class="line">                  weight.new(<span class="variable language_">self</span>.num_layers, batch_size, <span class="variable language_">self</span>.hidden_size).zero_())</span><br><span class="line">        <span class="keyword">return</span> hidden</span><br></pre></td></tr></tbody></table></figure>

<h3 id="4-模型训练"><a href="#4-模型训练" class="headerlink" title="4. 模型训练"></a>4. 模型训练</h3><p>定义训练函数，并进行模型训练。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 超参数</span></span><br><span class="line">input_size = vocab_size</span><br><span class="line">hidden_size = <span class="number">128</span></span><br><span class="line">output_size = vocab_size</span><br><span class="line">num_layers = <span class="number">2</span></span><br><span class="line">num_epochs = <span class="number">20</span></span><br><span class="line">batch_size = <span class="number">64</span></span><br><span class="line">seq_length = <span class="number">100</span></span><br><span class="line">learning_rate = <span class="number">0.002</span></span><br><span class="line"></span><br><span class="line">model = LSTMModel(input_size, hidden_size, output_size, num_layers)</span><br><span class="line">loss_fn = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = optim.Adam(model.parameters(), lr=learning_rate)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备数据集</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_sequences</span>(<span class="params">text, seq_length</span>):</span><br><span class="line">    sequences = []</span><br><span class="line">    targets = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(text) - seq_length):</span><br><span class="line">        seq = text[i:i+seq_length]</span><br><span class="line">        target = text[i+seq_length]</span><br><span class="line">        sequences.append([char_to_idx[ch] <span class="keyword">for</span> ch <span class="keyword">in</span> seq])</span><br><span class="line">        targets.append(char_to_idx[target])</span><br><span class="line">    <span class="keyword">return</span> sequences, targets</span><br><span class="line"></span><br><span class="line">sequences, targets = create_sequences(text, seq_length)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f'总序列数: <span class="subst">{<span class="built_in">len</span>(sequences)}</span>'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换为张量</span></span><br><span class="line">inputs = torch.tensor(sequences, dtype=torch.long)</span><br><span class="line">targets = torch.tensor(targets, dtype=torch.long)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练循环</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">    hidden = model.init_hidden(batch_size)</span><br><span class="line">    epoch_loss = <span class="number">0</span></span><br><span class="line">    num_batches = <span class="built_in">len</span>(inputs) // batch_size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(inputs) - batch_size, batch_size):</span><br><span class="line">        x = inputs[i:i+batch_size]</span><br><span class="line">        y = targets[i:i+batch_size]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 独热编码</span></span><br><span class="line">        x_one_hot = torch.zeros(batch_size, seq_length, input_size)</span><br><span class="line">        x_one_hot.scatter_(<span class="number">2</span>, x.unsqueeze(<span class="number">2</span>), <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        hidden = <span class="built_in">tuple</span>([h.data <span class="keyword">for</span> h <span class="keyword">in</span> hidden])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 前向传播</span></span><br><span class="line">        outputs, hidden = model(x_one_hot, hidden)</span><br><span class="line">        loss = loss_fn(outputs, y)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 反向传播和优化</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        epoch_loss += loss.item()</span><br><span class="line"></span><br><span class="line">    avg_loss = epoch_loss / num_batches</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f'Epoch [<span class="subst">{epoch+<span class="number">1</span>}</span>/<span class="subst">{num_epochs}</span>], Loss: <span class="subst">{avg_loss:<span class="number">.4</span>f}</span>'</span>)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="5-模型预测"><a href="#5-模型预测" class="headerlink" title="5. 模型预测"></a>5. 模型预测</h3><p>训练完成后，可以使用模型生成文本。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generate_text</span>(<span class="params">model, start_str, length, hidden_size</span>):</span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    chars = [ch <span class="keyword">for</span> ch <span class="keyword">in</span> start_str]</span><br><span class="line">    input_seq = torch.tensor([[char_to_idx[ch] <span class="keyword">for</span> ch <span class="keyword">in</span> start_str]], dtype=torch.long)</span><br><span class="line">    input_one_hot = torch.zeros(<span class="number">1</span>, <span class="built_in">len</span>(start_str), vocab_size)</span><br><span class="line">    input_one_hot.scatter_(<span class="number">2</span>, input_seq.unsqueeze(<span class="number">2</span>), <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    hidden = model.init_hidden(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(start_str) - <span class="number">1</span>):</span><br><span class="line">            _, hidden = model(input_one_hot[:, i:i+<span class="number">1</span>, :], hidden)</span><br><span class="line"></span><br><span class="line">        last_char = input_one_hot[:, -<span class="number">1</span>, :]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            out, hidden = model(last_char.unsqueeze(<span class="number">1</span>), hidden)</span><br><span class="line">            _, predicted = torch.<span class="built_in">max</span>(out, <span class="number">1</span>)</span><br><span class="line">            predicted_char = idx_to_char[predicted.item()]</span><br><span class="line">            chars.append(predicted_char)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 准备下一个输入</span></span><br><span class="line">            last_char = torch.zeros(<span class="number">1</span>, <span class="number">1</span>, vocab_size)</span><br><span class="line">            last_char[<span class="number">0</span>, <span class="number">0</span>, predicted] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(chars)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成文本示例</span></span><br><span class="line">start_str = <span class="string">"To be, or not to be, that is the question:\n"</span></span><br><span class="line">generated = generate_text(model, start_str, <span class="number">200</span>, hidden_size)</span><br><span class="line"><span class="built_in">print</span>(generated)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/" title="Understanding LSTM Networks">Understanding LSTM Networks</a></li>
<li><a href="https://pytorch.org/docs/stable/index.html" title="PyTorch官方文档">PyTorch官方文档</a></li>
<li><a href="https://chauby.github.io/2020/01/30/LSTM/" title="深入浅出LSTM及其Python代码实现">深入浅出LSTM及其Python代码实现</a></li>
</ol>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
  </entry>
  <entry>
    <title>Java中的线程池</title>
    <url>/2023/02/03/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h2 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h2><p>使用<code>Executors</code>创建线程池：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newSingleThreadExecutor(); <span class="comment">//单个线程</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool2</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>); <span class="comment">//创建一个固定的线程池的大小</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool3</span> <span class="operator">=</span> Executors.newCachedThreadPool(); <span class="comment">//可伸缩的线程池</span></span><br></pre></td></tr></tbody></table></figure>

<p>但是不建议使用<code>Executors</code>创建线程池，在阿里巴巴技术规范中写有：</p>
<p><img src="/../images/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20240903160832255.png" alt="image-20240903160832255"></p>
<span id="more"></span>

<blockquote>
<p>使用<code>Executors</code>创建线程池的本质实际上也是调用了<code>ThreadPoolExecutor</code>创建线程池，但是创建的线程池默认配置不太合理？</p>
</blockquote>
<h2 id="TreadPoolExector"><a href="#TreadPoolExector" class="headerlink" title="TreadPoolExector"></a>TreadPoolExector</h2><p><code>ThreadPoolExecutor</code>的构造方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, </span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize, </span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime, </span></span><br><span class="line"><span class="params">                          TimeUnit unit, </span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue, </span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory, </span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>ThreadPoolExecutor</code>的构造函数具有以下七个参数，它们分别是：</p>
<ol>
<li><p><code>corePoolSize</code>（核心线程数）：</p>
<p> 它指定了线程池中保持活动状态的核心线程数量。核心线程是一直存活的线程，即使它们处于空闲状态也不会被回收。当有新任务提交时，核心线程会立即执行任务。如果使用的是无界队列，线程池中的线程数永远不会超过核心线程数。</p>
</li>
<li><p><code>maximumPoolSize</code>（最大线程数）：</p>
<p> 它定义了线程池中允许创建的最大线程数量。当工作队列已满且当前线程数小于最大线程数时，线程池会创建新的线程来执行任务。如果使用的是有界队列，当队列已满且线程数达到最大值时，新的任务会触发拒绝策略。</p>
</li>
<li><p><code>keepAliveTime</code>（线程空闲超时时间）：</p>
<p> 它表示非核心线程空闲的最大时间。当线程池中的线程数超过核心线程数，并且空闲时间超过该值时，多余的线程会被终止并从线程池中移除，以减少资源消耗。新任务到达时，如果线程池中的线程数小于核心线程数，可能会重新创建线程。</p>
</li>
<li><p><code>unit</code>（空闲超时时间的单位）：</p>
<p> 用于指定<code>keepAliveTime</code>参数的单位，可以是<code>TimeUnit.SECONDS</code>、<code>TimeUnit.MILLISECONDS</code>等。</p>
</li>
<li><p><code>workQueue</code>（工作队列）：</p>
<p> 它定义了用于保存待执行任务的阻塞队列。当任务提交到线程池时，如果线程数小于核心线程数，会创建新线程来执行任务。如果线程数达到核心线程数，而工作队列未满，则将任务放入队列中等待执行。工作队列可以是有界队列（如<code>ArrayBlockingQueue</code>）或无界队列（如<code>LinkedBlockingQueue</code>）。</p>
</li>
<li><p><code>threadFactory</code>（线程工厂，可选）：</p>
<p> 线程工厂指定创建线程的方式，用于创建新线程的工厂对象。线程工厂可以根据需要对线程进行自定义配置，例如设置线程名字、设置线程优先级等。如果未指定，将使用默认的<code>DefaultThreadFactory</code></p>
</li>
<li><p><code>handler</code>（拒绝策略，可选）：</p>
<p> 它定义了当线程池无法接受新任务时的处理方式。拒绝策略可以是预定义的几种策略，如抛出异常、丢弃任务、阻塞等。也可以根据需要自定义拒绝策略实现<code>RejectedExecutionHandler</code>接口。</p>
</li>
</ol>
<p>我们可以这样类比：</p>
<p><img src="/../images/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20240903161026674.png" alt="image-20240903161026674"><br><em><strong>注意：核心线程没有空闲时，超量任务首先放入队列中，队列满了才会开普通线程处理！</strong></em></p>
<p>如果<code>corePoolSize</code>为0，则要使用<code>SynchronousQueue</code>避免无限阻塞。因为核心线程为0时，任务会先放入队列中，队列放不下了再使用普通线程，如果队列是无限的就会导致一直阻塞</p>
<h3 id="工作队列-BlockQueue"><a href="#工作队列-BlockQueue" class="headerlink" title="工作队列 BlockQueue"></a>工作队列 BlockQueue</h3><p>使用用<code>ThreadPoolExecutor</code>需要指定一个<code>BlockingQueue</code>任务等待队列。</p>
<p>BlockingQueue（阻塞队列）定义了一组用于插入、获取和检查元素的方法。与普通的队列不同，BlockingQueue在队列为空时，获取元素的操作会被阻塞，直到队列中有可用元素为止。同样地，当队列已满时，插入元素的操作也会被阻塞，直到队列有空闲空间为止。</p>
<p>BlockQueue有四组API：</p>
<p><img src="/../images/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20240903161114544.png" alt="image-20240903161114544"></p>
<p>BlockingQueue提供了多个实现类，其中常用的有以下几种：</p>
<ol>
<li><code>ArrayBlockingQueue</code>：基于数组实现的有界阻塞队列。它在构造时需要指定队列的容量，并且在队列已满时会阻塞插入操作，直到有空闲空间。</li>
<li><code>LinkedBlockingQueue</code>：基于链表实现的可选有界或无界阻塞队列。如果构造时不指定容量，则队列大小默认为无限制。</li>
<li><code>PriorityBlockingQueue</code>：基于优先级堆实现的无界阻塞队列。元素按照优先级进行排序，可以自定义比较器。</li>
<li><code>SynchronousQueue</code>：同步队列。是一个没有容量的阻塞队列，任何一次插入操作的元素都要等待相对的删除/读取操作，否则进行行行插入操作的线程就要一直等待,反之亦然<ol>
<li>进去一个元素，必须等待取出来之后，才能再往里面放入一个元素</li>
<li>使用lock锁保证线程安全的</li>
</ol>
</li>
<li><code>DelayQueue</code>：基于优先级堆实现的延迟阻塞队列。其中的元素必须实现<code>Delayed</code>接口，只有经过一定时间后才能被取出。</li>
</ol>
<p><em><strong>BlockingQueue实现原理：ReentrantLock + Condition</strong></em></p>
<p><code>ArrayBlockingQueue</code>和<code>LinkedBlockingQueue</code>区别：<br>    - <code>ArrayBlockingQueue</code>使用数组作缓冲区，有界，生产者消费者之间使用<strong>独占锁</strong>，即生产者和消费者共用一把缓冲区的锁，出队和入队不能同时进行<br>    - <code>LinkedBlockingQueue</code>使用链表作缓冲区，无界，生产者消费者之间使用<strong>分离锁</strong>，即生产者和消费者分别用一把缓冲区的锁，出队和入队可以同时进行</p>
<h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>  如上面介绍，拒绝策略需要实现<code>RejectedExecutionHandler</code>接口，<code>Executors</code>为我们提供了4种拒绝策略：</p>
<ul>
<li><code>AbortPolicy</code>（默认）：丢弃任务并抛出<code>RejectedExecutionException</code>异常</li>
<li><code>CallerRunsPolicy</code>：直接运行这个任务的run方法，但并非是由线程池处理，而是交由任务的调用线程处理</li>
<li><code>DiscardPolicy</code>：直接丢弃任务，不抛出任何异常</li>
<li><code>DiscardOldestPolicy</code>：将当前处于等待队列列头的等待任务强行取出，然后再试图将当前被拒绝的任务提交</li>
</ul>
<h2 id="常见线程池种类"><a href="#常见线程池种类" class="headerlink" title="常见线程池种类"></a>常见线程池种类</h2><p>四种线程池的特点：</p>
<ul>
<li><code>SingleThreadExecutor</code>单线程线程池<ul>
<li>特点：线程池只有一个线程</li>
<li>使用一个<code>LinkedBlockingQueue</code>作为工作队列，未指定容量（默认值<code>Integer.MAX_VALUE</code>）</li>
</ul>
</li>
<li><code>FixedThreadPool</code>固定线程池<ul>
<li>特点：最大线程数就是核心线程数，<strong>即只有核心线程</strong></li>
<li><code>keepAliveTime=0</code>，但核心线程不会被回收或者销毁</li>
<li>无界队列：使用<code>LinkedBlockingQueue</code>作为工作队列，未指定容量（默认值<code>Integer.MAX_VALUE</code>）</li>
<li>适用于需要有一定持续并发量的场景</li>
</ul>
</li>
<li><code>CachedThreadPool</code>缓存线程池<ul>
<li><strong>没有核心线程，普通线程数量无限</strong></li>
<li><code>keepAliveTime=60</code>，线程闲置60s后回收</li>
<li>使用<code>SynchronousQueue</code>作为工作队列，它不会保存任务，而是直接将任务交给空闲线程执行</li>
<li>处理大量短时间工作任务的线程池，适用于项目中多线程的场景不多或者是需要快速响应的场景，即来即处理，且用完释放，不占用过多资源</li>
</ul>
</li>
<li><code>ScheduledThreadPool</code>定时线程池<ul>
<li><strong>指定核心线程数量，普通线程数量无限</strong></li>
<li>任务队列为延时阻塞队列<code>DelayQueue</code></li>
<li>适用用于执行定时或周期性的任务</li>
</ul>
</li>
</ul>
<h2 id="线程池调优"><a href="#线程池调优" class="headerlink" title="线程池调优"></a>线程池调优</h2><p>在设置线程池大小时，可以考虑任务类型和系统资源的特点，以确定适当的线程池大小。具体而言，对于 CPU 密集型任务和 I/O 密集型任务，可以采取以下建议：</p>
<ul>
<li><strong>CPU 密集型任务</strong><ul>
<li>对于 CPU 密集型任务，线程数应与 CPU 核心数相近或稍多一些，以充分利用 CPU 资源，并避免过多的线程竞争和上下文切换开销。</li>
<li>可以通过 <code>Runtime.getRuntime().availableProcessors()</code> 获取当前系统的 CPU 核心数，作为线程池的核心线程数。</li>
<li>由于 CPU 密集型任务不涉及阻塞等待，可以选择较小的工作队列容量或使用 <code>SynchronousQueue</code>，使得任务提交后立即执行。</li>
</ul>
</li>
<li><strong>I/O 密集型任务</strong><ul>
<li>对于 I/O 密集型任务，一般建议将线程数设置为 CPU 核心数的几倍，例如 2 倍或 4 倍，以充分利用 I/O 操作的等待时间，提高系统的吞吐量。</li>
<li>由于 I/O 操作会涉及到阻塞等待，可以设置较大的工作队列容量，以处理可能的任务积压。</li>
</ul>
</li>
</ul>
<p>实际线程池大小的选择还取决于任务的具体特点和系统资源的限制。在实际应用中，可以通过测试和性能调优来确定最佳的线程池大小，确保任务能够高效执行并充分利用系统资源。</p>
<p><a href="/2024/02/03/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9C%A8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5%E4%BB%A5%E5%8F%8A%E5%AF%B9%E5%BA%94%E5%8F%82%E6%95%B0%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1/">线程池在业务中的实践以及对应参数如何设计</a></p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>LangChain入门笔记</title>
    <url>/2024/04/27/LangChain%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>LangChain是一个用于开发由语言模型驱动的应用程序的框架。</p>
<p>主要功能：</p>
<ul>
<li><p>调用语言模型</p>
</li>
<li><p>将不同数据源接入到语言模型的交互中</p>
</li>
<li><p>允许语言模型与运行环境交互</p>
</li>
</ul>
</blockquote>
<p><strong>基本架构</strong></p>
<p><img src="/../images/LangChain%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/langchain_stack_dark_0TT7SLpV72.svg"></p>
<p><strong>LangChain中提供的模块</strong></p>
<ul>
<li><p>Modules：支持的模型类型和集成。</p>
</li>
<li><p>Prompt：提示词管理、优化和序列化。</p>
</li>
<li><p>Memory：内存是指在链/代理调用之间持续存在的状态。</p>
</li>
<li><p>Indexes：当语言模型与特定于应用程序的数据相结合时，会变得更加强大-此模块包含用于加载、查询和更新外部数据的接口和集成。</p>
</li>
<li><p>Chain：链是结构化的调用序列（对LLM或其他实用程序）。</p>
</li>
<li><p>Agents：代理是一个链，其中LLM在给定高级指令和一组工具的情况下，反复决定操作，执行操作并观察结果，直到高级指令完成。</p>
</li>
<li><p>Callbacks：回调允许您记录和流式传输任何链的中间步骤，从而轻松观察、调试和评估应用<br>程序的内部。</p>
</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>文档问答</li>
<li>查询数据表格（CSV、SQL、DataFrame等）</li>
<li>API交互、信息提取、文档总结等</li>
</ul>
<h1 id="Model-I-O"><a href="#Model-I-O" class="headerlink" title="Model I/O"></a>Model I/O</h1><p>四个核心组件：</p>
<ul>
<li>Prompts 提示词</li>
<li>Chat Models 聊天模型<ul>
<li>擅长对话</li>
</ul>
</li>
<li>LLMs 纯文本模型<ul>
<li>擅长理解和合成文本方面，例如总结文档、PDF、概念页面等</li>
</ul>
</li>
<li>Output parsers 输出转换器</li>
</ul>
<blockquote>
<p>📌Chat Models 和 LLMs 的区别：</p>
<p>Chat models和LLMs都是LangChain中的语言模型抽象，但是LLMs是纯语言模型，Chat models是针对对话做了优化的聊天模型</p>
</blockquote>
<h1 id="Agents"><a href="#Agents" class="headerlink" title="Agents"></a>Agents</h1><blockquote>
<p>大型语言模型（LLMs）非常强大，但它们缺乏“最笨”的计算机程序可以轻松处理的特定能力。LLM 对逻辑推理、计算和检索外部信息的能力较弱，这与最简单的计算机程序形成对比。例如，语言模型无法准确回答简单的计算问题，还有当询问最近发生的事件时，其回答也可能过时或错误，因为无法主动获取<br>最新信息。这是由于当前语言模型仅依赖预训练数据，与外界“断开”。要克服这一缺陷， LangChain 框<br>架提出了 “代理”(Agent) 的解决方案。</p>
</blockquote>
<p>Agent作为语言模型的外部模块，可提供计算、逻辑、检索等功能的支持，使语言模型获得异常强大的推理和获取信息的超能力。</p>
<hr>
<p>Agents的核心思想是使用语言模型来选择要采取的一系列Action</p>
<p>在langchain中，一系列Action被硬编码（在代码中）。</p>
<p>在Agents中，语言模型被用作推理引擎来确定要采取哪些操作以及按什么顺序。</p>
<p>不同Agents的区别：不同的推理提示风格、不同的编码输入方式以及不同的解析输出方式。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h3><p>构建代理的核心组件</p>
<ul>
<li><code>AgentAction</code> 即Action，表示代理执行的操作，通常表示调用tools<ul>
<li>我们将想让对Agents的操作封装成Action（tools），再让Agents在被调用时选择应该使用哪些tools</li>
<li>在<code>AgentAction</code>中有两个属性：<code>tool</code>和<code>tool_input</code>，分别代表工具的名字和工具输入</li>
</ul>
</li>
<li><code>AgentFinish</code>  Agents返回的最终结果</li>
<li><code>Intermediate Steps</code> 中间步骤。代表<code>AgentAction</code>以及当前Agents运行的相应输出</li>
</ul>
<h3 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h3><ul>
<li><code>Agent Inputs</code> Agents的输入，键值对类型<ul>
<li>required：<code>intermediate_steps</code></li>
</ul>
</li>
<li><code>Agent Outputs</code> Agents的响应，分为<code>Union[AgentAction, List[AgentAction], AgentFinish]</code><ul>
<li>输出解析器负责获取原始 LLM 输出并将其转换为这三种类型之一</li>
</ul>
</li>
</ul>
<p>demo：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">agent = (</span><br><span class="line">    {</span><br><span class="line">        <span class="string">"input"</span>: <span class="keyword">lambda</span> x: x[<span class="string">"input"</span>],</span><br><span class="line">        <span class="string">"agent_scratchpad"</span>: <span class="keyword">lambda</span> x: format_to_openai_tool_messages(</span><br><span class="line">            x[<span class="string">"intermediate_steps"</span>]</span><br><span class="line">        ),</span><br><span class="line">    }</span><br><span class="line">    | prompt</span><br><span class="line">    | llm_with_tools</span><br><span class="line">    | OpenAIToolsAgentOutputParser()</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>

<h4 id="Agents-API"><a href="#Agents-API" class="headerlink" title="Agents API"></a>Agents API</h4><ul>
<li><code>AgentExecutor</code> 重复调用Agents并执行工具<ul>
<li>封装了各种错误处理、日志等</li>
</ul>
</li>
</ul>
<h3 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h3><p>工具是代理可以调用​​的功能。 <code>Tool</code> 抽象由两个组件组成：</p>
<p>工具 API 的目标是比使用通用文本完成或聊天 API 更可靠地返回有效且有用的工具调用。</p>
<ul>
<li>schema</li>
<li>function</li>
</ul>
<p>设计Agents的关键：</p>
<ul>
<li>让Agents正确的使用tools</li>
<li>以对代理最有帮助的方式描述工具</li>
</ul>
<h2 id="Agent-Type"><a href="#Agent-Type" class="headerlink" title="Agent Type"></a>Agent Type</h2><p>介绍几个常用的Agent Type</p>
<p>ReAct：LLM 可以循环进行 Reasoning 和 Action 步骤的过程。它启用了一个多步骤的过程来识别答案。</p>
<h1 id="Prompt"><a href="#Prompt" class="headerlink" title="Prompt"></a>Prompt</h1><p>提示词工程和模型微调的区别：</p>
<ul>
<li><p>微调</p>
<ul>
<li>定义：针对预先训练的语言模型，在特定任务的少量数据集上对其进行进一步训练</li>
<li>适用场景：当任务或域定义明确，并且有足够的标记数据可供训练时，通常使用微调过程</li>
</ul>
</li>
<li><p>提示词工程</p>
<ul>
<li>涉及设计自然语言提示或指令，可以指导语言模型执行特定任务</li>
<li>最适合需要高精度和明确输出的任务。提示工程可用于制作引发所需输出的查询</li>
</ul>
</li>
</ul>
<h1 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h1><p><img src="/../images/LangChain%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/memory_diagram-0627c68230aa438f9b5419064d63cbbc_TH.png"></p>
<p>四种主要储存模块：</p>
<ul>
<li><code>ConversationBufferMemory</code>对话缓存</li>
<li><code>ConversationTokenBufferMemory</code>按窗口缓存</li>
<li><code>ConversationTokenBufferMemory</code>按令牌缓存</li>
<li><code>ConversationSummaryBufferMemory</code>按摘要缓存</li>
</ul>
<p>最常见的内存类型之一涉及返回聊天消息列表。这些可以作为单个字符串返回，全部连接在一起（当它们被传递到 LLMs 时有用）或 ChatMessages 列表（当传递到 ChatModels 时有用）。</p>
<p>默认情况下，它们作为单个字符串返回。为了作为消息列表返回，您可以设置 <code>return_messages=True</code></p>
<p><img src="/../images/LangChain%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image_6DBZDWLskV.png"></p>
<h1 id="Chains"><a href="#Chains" class="headerlink" title="Chains"></a>Chains</h1><p>链是指调用序列 - 即 LLM、Tools还是数据预处理步骤的先后顺序。主要支持的方法是使用 LCEL。</p>
<h2 id="LCEL-Chains"><a href="#LCEL-Chains" class="headerlink" title="LCEL Chains"></a>LCEL Chains</h2><p>LangChain Expression Language（LCEL）可以轻松地从基本组件构建复杂的链，并支持开箱即用的功能，例如流式传输、并行性和日志记录，最基本和常见的用例是将Prompt和LLM链接在一起。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">chain = prompt | model | output_parser</span><br></pre></td></tr></tbody></table></figure>

<p><a href="https://python.langchain.com/v0.1/docs/expression_language/get_started/" title="https://python.langchain.com/v0.1/docs/expression_language/get_started/">https://python.langchain.com/v0.1/docs/expression_language/get_started/</a></p>
<p>意义：组合大模型调用中不相关的部分，让开发者省去胶水代码</p>
<p>下面举一些简单的栗子：</p>
<p>模型调用：</p>
<p><img src="/../images/LangChain%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image_I16oGnpYi7.png"></p>
<p>Stream流：</p>
<p><img src="/../images/LangChain%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image_8inhVIpa63.png"></p>
<p>Batch批处理：</p>
<p><img src="/../images/LangChain%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image_HKv1CygTUu.png"></p>
<p>异步调用：</p>
<p><img src="/../images/LangChain%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image_wKdMBtlRZQ.png"></p>
<h1 id="RAG"><a href="#RAG" class="headerlink" title="RAG"></a>RAG</h1><p>全称Retrieval Augmented Generation (RAG)</p>
<p><img src="/../images/LangChain%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/data_connection-95ff2033a8faa5f3ba41376c0f6dd32a_6.jpg"></p>
<p>核心组件：</p>
<ul>
<li><strong>Document loaders</strong>文档加载器</li>
<li>Text Splitting文本分割器，将大文档分割（或分块）为更小的块。</li>
<li>Text Embedding models嵌入模型，用于将文档嵌入到Vector stores中，主要有两种常用方式：<ul>
<li>text2vector</li>
<li>llm</li>
</ul>
</li>
<li>Retrievers检索器，用于在数据源中检索相关信息</li>
<li>Indexing数据库索引，用于检索</li>
</ul>
<h2 id="Retrievers检索"><a href="#Retrievers检索" class="headerlink" title="Retrievers检索"></a>Retrievers检索</h2><p>相关算法：</p>
<ul>
<li><p>基本语义相似度（Basicsemanticsimilarity)</p>
</li>
<li><p>最大边际相关性（Maximummarginalrelevance，MMR)</p>
</li>
<li><p>过滤元数据</p>
</li>
<li><p>LLM辅助检索 SelfQueryRetriever</p>
</li>
<li><p>压缩 ContextualCompressionRetriever</p>
<ul>
<li>工作原理：先使用标准向量检索获得候选文档，然后基于查询语句的语义，使用语言模型压缩这些文档,只保留与问题相关的部分<br><img src="/../images/LangChain%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image_vwodDD-H4n.png"></li>
</ul>
</li>
</ul>
<p>其他类型的检索：</p>
<p>vetordb 并不是唯一一种检索文档的工具。 LangChain 还提供了其他检索文档的方式，例如： TF-IDF 或 SVM 。</p>
<h2 id="对话检索链"><a href="#对话检索链" class="headerlink" title="对话检索链"></a>对话检索链</h2><h3 id="检索链类型"><a href="#检索链类型" class="headerlink" title="检索链类型"></a>检索链类型</h3><p>通过LangChain创建一个检索问答链，对检索到的文档进行问题回答。检索问答链的输入包含以下</p>
<ul>
<li>llm大语言模型</li>
<li><code>chain_type</code>指定传入链（用于将文档传递到 LLM 的上下文窗口中）类型<ul>
<li><strong>Stuff</strong>：只需将所有文档“塞”到一个提示中即可，这是最简单的方法<ul>
<li>API：create_stuff_documents_chain</li>
</ul>
</li>
<li><strong>Map-reduce</strong>：将所有块与问题一起传递给语言模型，获取回复，使用另一个语言模型调用将所有单独的回复总结成最终答案，它可以在任意数量的文档上运行。可以并行处理单个问题，同时也需要更多的调用。它将所有文档视为独立的<ul>
<li>MapReduceDocumentsChain</li>
</ul>
</li>
<li><strong>Refine</strong><ul>
<li>循环许多文档，实际上是迭代的，建立在先前文档的答案之上，非常适合前后因果信息并随时间逐步构建答案，依赖于先前调用的结果。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/../images/LangChain%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/summarization_use_case_2-f2a4d5d60980a79140085fb7f.png" alt="Stuff和MapReduce区别" title="Stuff和MapReduce区别"></p>
<p><img src="/../images/LangChain%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image_5N5XBgZFMJ.png"></p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.chains.combine_documents.stuff <span class="keyword">import</span> StuffDocumentsChain</span><br><span class="line"><span class="keyword">from</span> langchain.chains.llm <span class="keyword">import</span> LLMChain</span><br><span class="line"><span class="keyword">from</span> langchain_core.prompts <span class="keyword">import</span> PromptTemplate</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define prompt</span></span><br><span class="line">prompt_template = <span class="string">"""Write a concise summary of the following:</span></span><br><span class="line"><span class="string">"{text}"</span></span><br><span class="line"><span class="string">CONCISE SUMMARY:"""</span></span><br><span class="line">prompt = PromptTemplate.from_template(prompt_template)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define LLM chain</span></span><br><span class="line">llm = ChatOpenAI(temperature=<span class="number">0</span>, model_name=<span class="string">"gpt-3.5-turbo-16k"</span>)</span><br><span class="line">llm_chain = LLMChain(llm=llm, prompt=prompt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define StuffDocumentsChain</span></span><br><span class="line">stuff_chain = StuffDocumentsChain(llm_chain=llm_chain, document_variable_name=<span class="string">"text"</span>)</span><br><span class="line"></span><br><span class="line">docs = loader.load()</span><br><span class="line"><span class="built_in">print</span>(stuff_chain.run(docs))</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>langchain</tag>
        <tag>LLM</tag>
      </tags>
  </entry>
  <entry>
    <title>🐛开源经历：LangChain4j-Spring Bug修复记录</title>
    <url>/2024/08/25/LangChain4j-Spring-Bug/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在使用Langchain4j的过程中发现，如果在启动类所在的classPath以外的目录中定义了<code>AiService</code>，那么该类将不会被Langchain4j扫描并代理到，即使你使用<code>@ComponentScan</code>或者其他方式指定了文件扫描路径</p>
<p>查看源码后发现，Langchain4j中 <code>AiService</code> 只会扫描启动类所在的classPath，而对于其他方式配置的扫描路径都没有进行处理，也没有实现其他配置手段能够让用户指定扫描路径，最后就导致了 <code>AiService</code> 不存在的Bug _(:з」∠)_</p>
<p><strong>相关issue</strong></p>
<ul>
<li><a href="https://github.com/langchain4j/langchain4j/issues/1606">https://github.com/langchain4j/langchain4j/issues/1606</a></li>
<li><a href="https://github.com/langchain4j/langchain4j-spring/pull/35">https://github.com/langchain4j/langchain4j-spring/pull/35</a></li>
<li><a href="https://github.com/langchain4j/langchain4j-spring/pull/48">https://github.com/langchain4j/langchain4j-spring/pull/48</a></li>
</ul>
<blockquote>
<p><em>Tips：</em>这也是我第一次参加开源，虽然只是做了一个微不足道的贡献，但是还是感觉收获很多吧…一直在担心自己的水平不够所以反复理解反复查资料，但是作者很热心帮我修改了代码并且很快就被处理接受了😃</p>
</blockquote>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>项目中相关代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Set&lt;Class&lt;?&gt;&gt; findAiServices(ConfigurableListableBeanFactory beanFactory) {</span><br><span class="line">  String[] applicationBean = beanFactory.getBeanNamesForAnnotation(SpringBootApplication.class);</span><br><span class="line">  <span class="type">BeanDefinition</span> <span class="variable">applicationBeanDefinition</span> <span class="operator">=</span> beanFactory.getBeanDefinition(applicationBean[<span class="number">0</span>]);</span><br><span class="line">  <span class="type">String</span> <span class="variable">basePackage</span> <span class="operator">=</span> applicationBeanDefinition.getResolvableType().resolve().getPackage().getName();</span><br><span class="line">  <span class="type">Reflections</span> <span class="variable">reflections</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reflections</span>((<span class="keyword">new</span> <span class="title class_">ConfigurationBuilder</span>()).forPackage(basePackage));</span><br><span class="line">  Set&lt;Class&lt;?&gt;&gt; classes = reflections.getTypesAnnotatedWith(AiService.class);</span><br><span class="line">  classes.removeIf(clazz -&gt; !clazz.getName().startsWith(basePackage));</span><br><span class="line">  <span class="keyword">return</span> classes;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>大致逻辑就是，获取启动类所在的路径，然后使用反射找到该路径下所有带有AiService的class。</p>
<p>目前有两个问题：</p>
<ol>
<li>扫描路径的获取。在不增加额外的用户配置的情况下，如何知道应该扫描全部的路径呢？用户指定扫描路径的方式有很多种，其中最常用的就是通过<code>@ComponentScan</code>指定，于是想到我们可以解析项目中所有<code>@ComponentScan</code>注解，以此作为扫描路径</li>
<li>扫描的方式是通过Reflections，而不是通过Spring自带的方法。作者使用Reflections是因为<strong>Spring默认是不会扫描接口</strong>的，因为接口没有办法实例化，因此通过Spring自带的方法自然也无法获取到Bean。但是这么做属实有点不合理，有没有更加优雅的解决办法呢？</li>
</ol>
<h2 id="获取扫描路径"><a href="#获取扫描路径" class="headerlink" title="获取扫描路径"></a>获取扫描路径</h2><p>用户指定扫描路径的方式有很多种，其中最常用的就是通过<code>@ComponentScan</code>指定，于是想到我们可以解析项目中所有<code>@ComponentScan</code>注解，以此作为扫描路径</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Set&lt;String&gt; <span class="title function_">getBasePackages</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> {</span><br><span class="line">  Set&lt;String&gt; collectedBasePackages = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(); </span><br><span class="line">  beanFactory.getBeansWithAnnotation(ComponentScan.class).forEach((beanName, instance) -&gt; {</span><br><span class="line">      Set&lt;ComponentScan&gt; componentScans = AnnotatedElementUtils.getMergedRepeatableAnnotations(instance.getClass(), ComponentScan.class);</span><br><span class="line">      <span class="keyword">for</span> (ComponentScan componentScan : componentScans) {</span><br><span class="line">          Set&lt;String&gt; basePackages = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">          String[] basePackagesArray = componentScan.basePackages();</span><br><span class="line">          <span class="keyword">for</span> (String pkg : basePackagesArray) {</span><br><span class="line">              String[] tokenized = StringUtils.tokenizeToStringArray(<span class="built_in">this</span>.environment.resolvePlaceholders(pkg),</span><br><span class="line">                      ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);</span><br><span class="line">              Collections.addAll(basePackages, tokenized);</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">for</span> (Class&lt;?&gt; clazz : componentScan.basePackageClasses()) {</span><br><span class="line">              basePackages.add(ClassUtils.getPackageName(clazz));</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">if</span> (basePackages.isEmpty()) {</span><br><span class="line">              basePackages.add(ClassUtils.getPackageName(instance.getClass()));</span><br><span class="line">          }</span><br><span class="line">          collectedBasePackages.addAll(basePackages);</span><br><span class="line">      }</span><br><span class="line">  });</span><br><span class="line">  <span class="keyword">return</span> collectedBasePackages;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p><em>Tips：</em> 这里我只处理了<code>@ComponentScan</code>的basePackages等相关的路径扫描属性、别名问题，过滤器之类的属性目前还没有解决（Spring太复杂了🥲）</p>
</blockquote>
<h2 id="自定义类扫描器"><a href="#自定义类扫描器" class="headerlink" title="自定义类扫描器"></a>自定义类扫描器</h2><p>如果是要与Spring集成的话肯定是使用Spring的方式扫描Bean更好，但是Spring自带的类扫描器会直接过滤接口，这怎么办？我想到一个比较熟悉的场景：MyBatis的Mapper也是接口，但是他是怎么被扫描并且注册到Spring中的呢？</p>
<p>于是我去翻了MyBatis相关的源代码，发现其原理是自定义了一个类扫描<code>ClassPathMapperScanner</code>，并重写了他的<code>isCandidateComponent()</code>方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isCandidateComponent</span><span class="params">(AnnotatedBeanDefinition beanDefinition)</span> {</span><br><span class="line">  <span class="keyword">return</span> beanDefinition.getMetadata().isInterface() &amp;&amp; beanDefinition.getMetadata().isIndependent();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在Spring自带的类扫描器中，他们的<code>isCandidateComponent()</code>方法是这样的：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isCandidateComponent</span><span class="params">(AnnotatedBeanDefinition beanDefinition)</span> {</span><br><span class="line">  <span class="type">AnnotationMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> beanDefinition.getMetadata();</span><br><span class="line">  <span class="keyword">return</span> (metadata.isIndependent() &amp;&amp; (metadata.isConcrete() ||</span><br><span class="line">      (metadata.isAbstract() &amp;&amp; metadata.hasAnnotatedMethods(Lookup.class.getName()))));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>isConcrete()</code>返回基础类是否表示具体类，即既不是接口也不是抽象类。这里我们也可以知道Spring不扫描接口的原因了，在这一步就被pass掉了</p>
<p>关于MyBatis代理的详细过程可以参考MyBatis创建代理全过程</p>
<p>接下来我们就可以参考MyBatis自定义类扫描器了：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassPathAiServiceScanner</span> <span class="keyword">extends</span> <span class="title class_">ClassPathBeanDefinitionScanner</span> {</span><br><span class="line">    ClassPathAiServiceScanner(BeanDefinitionRegistry registry, <span class="type">boolean</span> useDefaultFilters) {</span><br><span class="line">        <span class="built_in">super</span>(registry, useDefaultFilters);</span><br><span class="line">        addIncludeFilter(<span class="keyword">new</span> <span class="title class_">AnnotationTypeFilter</span>(AiService.class));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isCandidateComponent</span><span class="params">(AnnotatedBeanDefinition beanDefinition)</span> {</span><br><span class="line">        <span class="type">AnnotationMetadata</span> <span class="variable">annotationMetadata</span> <span class="operator">=</span> beanDefinition.getMetadata();</span><br><span class="line">        <span class="keyword">return</span> annotationMetadata.isInterface() &amp;&amp; annotationMetadata.isIndependent();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>按照Mybatis的方式，我们可以通过自定义类扫描器的方式实现让Spring扫描接口，那么问题来了，如何让Spring使用我们自定义的类扫描器呢？</p>
<p>我们可以在Spring的BeanDefinition扫描流程结束后，再扫描一遍不就好了吗？这时候后置处理器就可以派上用场了：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AiServiceScannerProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException {</span><br><span class="line">        <span class="type">ClassPathAiServiceScanner</span> <span class="variable">classPathAiServiceScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathAiServiceScanner</span>(registry, <span class="literal">false</span>);</span><br><span class="line">        classPathAiServiceScanner.addIncludeFilter(<span class="keyword">new</span> <span class="title class_">AnnotationTypeFilter</span>(AiService.class));</span><br><span class="line">        Set&lt;String&gt; basePackages = getBasePackages((ConfigurableListableBeanFactory) registry);</span><br><span class="line">        classPathAiServiceScanner.scan(StringUtils.toStringArray(basePackages));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>至此这个问题就大致解决了，但是一些细节肯定没有处理好，这个项目目前也是刚起步的阶段，期待有大佬给出更好的解决方案🥳</p>
<hr>
<p>附一个贴图，纪念一下：</p>
<p><img src="/../images/%E5%BC%80%E6%BA%90%E7%BB%8F%E5%8E%86-LangChain4j-Spring-Bug%E4%BF%AE%E5%A4%8D%E8%AE%B0%E5%BD%95/pr.png"></p>
]]></content>
      <categories>
        <category>日常小记</category>
      </categories>
      <tags>
        <tag>langchain</tag>
        <tag>开源</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中的字符串类型</title>
    <url>/2023/09/14/MySQL%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>变量名称</th>
<th>含义</th>
<th>大小</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>固定大小的字符</td>
<td>0-255<strong>个字符</strong></td>
</tr>
<tr>
<td>varchar</td>
<td>可变长度字符串,相当于<code>String</code></td>
<td>0 - 65536<strong>个字符</strong></td>
</tr>
<tr>
<td>Text</td>
<td>文本串,保存大文本</td>
<td>4G</td>
</tr>
<tr>
<td>Blob</td>
<td>二进制大对象，专门用来储存图片，声音，视频等流媒体数据。插入数据的时候，需要使用IO流。</td>
<td>4G</td>
</tr>
</tbody></table>
<span id="more"></span>


<h2 id="CHAR-和-VARCHAR-的定义"><a href="#CHAR-和-VARCHAR-的定义" class="headerlink" title="CHAR 和 VARCHAR 的定义"></a>CHAR 和 VARCHAR 的定义</h2><p><code>CHAR(N)</code> 用来保存固定长度的字符，N 的范围是 0 ~ 255，<strong>请牢记，N 表示的是字符，而不是字节</strong>。<code>VARCHAR(N)</code> 用来保存变长字符，N 的范围为 0 ~ 65536， <strong>N 表示字符</strong>。</p>
<p>在超出 65536 个字符的情况下，可以考虑使用更大的字符类型 TEXT 或 BLOB，两者最大存储长度为 4G，其区别是 BLOB 没有字符集属性，纯属二进制存储。</p>
<p>MySQL 数据库的 VARCHAR 字符类型，最大能够存储 65536 个字符，所以在 MySQL 数据库下，绝大部分场景使用类型 VARCHAR 就足够了。</p>
<p>对于长文本，比如存储博客这样的场景，可以使用<code>Text</code></p>
<p><strong>字符集</strong></p>
<p>在表结构设计中，除了将列定义为 CHAR 和 VARCHAR 用以存储字符以外，还需要额外定义字符对应的字符集，因为每种字符在不同字符集编码下，对应着不同的二进制值。常见的字符集有 GBK、UTF8，通常默认把字符集设置为 UTF8。</p>
<p><strong>推荐把 MySQL 的默认字符集设置为 UTF8MB4</strong>，可以存储emoji 表情</p>
<h2 id="varchar-100-可以存多少中文字符"><a href="#varchar-100-可以存多少中文字符" class="headerlink" title="varchar(100)可以存多少中文字符"></a>varchar(100)可以存多少中文字符</h2><p>不同的字符集，<code>CHAR(N)</code>、<code>VARCHAR(N)</code>对应最长的字节也不相同。</p>
<p>比如 <em><strong>GBK 字符集，1 个字符最大存储 2 个字节，UTF-8字符集支持每个字符最大三3字节，UTF8MB4 字符集 1 个字符最大存储 4 个字节。</strong></em></p>
<blockquote>
<p>注意MySQL中的UTF-8跟平时用的UTF-8有区别，真正的 UTF-8 是每个字符最多四个字节。</p>
</blockquote>
<p>那么在UTF-8字符集的情况下，一个汉字3个字节，<code>varchar(100)</code>可以存放100个中文字符</p>
<h2 id="补充：Unicode-ASCII-UTF-8-GBK-编码的区别"><a href="#补充：Unicode-ASCII-UTF-8-GBK-编码的区别" class="headerlink" title="补充：Unicode ASCII UTF-8 GBK 编码的区别"></a>补充：Unicode ASCII UTF-8 GBK 编码的区别</h2><h3 id="ASCII编码"><a href="#ASCII编码" class="headerlink" title="ASCII编码"></a>ASCII编码</h3><p>ASCII 码使用指定的7 位或8 位二进制数组合来表示128 或256 种可能的字符。</p>
<p><em><strong>长度：1个字节</strong></em></p>
<h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。</p>
<p>Unicode最常用的是用<strong>两个字节表示一个字符</strong>。现代操作系统和大多数编程语言都直接支持Unicode。</p>
<p>新的问题：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p>
<p><em><strong>长度：2个字节</strong></em></p>
<h3 id="UTF8"><a href="#UTF8" class="headerlink" title="UTF8"></a>UTF8</h3><p>所以，本着节约的精神，出现了“可变长编码”的UTF-8编码</p>
<p>UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，<em><strong>常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节</strong></em>。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间。</p>
<p><em><strong>长度：1-6个字节，汉字一般是3个字节</strong></em></p>
<h3 id="GBK-编码"><a href="#GBK-编码" class="headerlink" title="GBK 编码"></a><strong>GBK 编码</strong></h3><p>GBK 编码专门用于表示汉字</p>
<p><em><strong>长度：</strong></em><em><strong>2个字节</strong></em></p>
]]></content>
      <categories>
        <category>日常小记</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SPI机制详解</title>
    <url>/2024/06/01/SPI%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>什么是SPI机制？</p>
<p><em><strong>SPI（Service Provider Interface）</strong></em>，是 JDK 内置的一种服务提供发现机制，具体表现为按照约定能够为同一接口提供多种不同的实现，常用来启用框架扩展和替换组件</p>
<p><img src="/../images/SPI%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/image_ieFj3Q2IEV.png"></p>
<p>Java 中 SPI 机制主要思想是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要，其核心思想就是 <strong>解耦</strong>。</p>
</blockquote>
<p>本文探讨SPI在Java和SpringBoot中的实现以及具体的使用姿势</p>
<h1 id="Java-SPI"><a href="#Java-SPI" class="headerlink" title="Java SPI"></a>Java SPI</h1><p>Java SPI 中有四个重要的组件：</p>
<ol>
<li><strong>服务接口</strong>：一个定义了服务提供者实现类契约方法的接口或者抽象类。</li>
<li><strong>服务实现</strong>：实际提供服务的实现类。</li>
<li><strong>SPI 配置文件</strong>：文件名必须存在于 <code>META-INF/services</code> 目录中。文件名应与服务提供商接口完全限定名完全相同。文件中的每一行都有一个实现服务类详细信息，即服务提供者类的完全限定名。</li>
<li><strong>ServiceLoader</strong>： Java SPI 关键类，用于加载服务提供者接口的服务。</li>
</ol>
<p>简单看一个demo：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 标准服务接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Compresser</span> {</span><br><span class="line">    <span class="type">byte</span>[] compress(<span class="type">byte</span>[] bytes);</span><br><span class="line">    <span class="type">byte</span>[] decompress(<span class="type">byte</span>[] bytes);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际服务提供者1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GzipCompresser</span> <span class="keyword">implements</span> <span class="title class_">Compresser</span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] compress(<span class="type">byte</span>[] bytes) {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"compress by Gzip"</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] decompress(<span class="type">byte</span>[] bytes) {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"decompress by Gzip"</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际服务提供者2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZipCompresser</span> <span class="keyword">implements</span> <span class="title class_">Compresser</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] compress(<span class="type">byte</span>[] bytes) {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"compress by Zip"</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] decompress(<span class="type">byte</span>[] bytes) {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"decompress by Zip"</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>编写SPI 配置文件：</p>
<p>在<code>META-INF/services</code>中创建<code>cn.ppphuang.demoserver.serviceproviders.Compresser</code>文件，注意文件名是标准服务接口类的<strong>全限定类名</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">cn.ppphuang.demoserver.serviceproviders.GzipCompresser</span><br><span class="line">cn.ppphuang.demoserver.serviceproviders.ZipCompresser cn.ppphuang.demoserver.serviceproviders.Compresser</span><br></pre></td></tr></tbody></table></figure>

<p>接下来通过 ServiceLoader 加载服务：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">  ServiceLoader&lt;Compresser&gt; serviceLoader = ServiceLoader.load(Compresser.class);</span><br><span class="line">  <span class="keyword">for</span> (Compresser service : serviceLoader) {</span><br><span class="line">    System.out.println(service.getClass().getClassLoader());</span><br><span class="line">    <span class="type">byte</span>[] compress = service.compress(<span class="string">"Hello"</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(compress));</span><br><span class="line">    <span class="type">byte</span>[] decompress = service.decompress(<span class="string">"Hello"</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(decompress));</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">-------------</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">compress by Gzip</span><br><span class="line">decompress by Gzip</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">compress by Zip</span><br><span class="line">decompress by Zip</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="常见SPI案例"><a href="#常见SPI案例" class="headerlink" title="常见SPI案例"></a>常见SPI案例</h2><ul>
<li><p>JDBC SPI</p>
<p>SPI的使用非常广泛，一个比较出名的实现就是JDBC</p>
<p>在JDBC中，我们一般会通过<code>DriverManager</code>去创建与数据库的连接；而<code>DriverManager</code>会查找并加载classPath中不同的<code>Driver</code>的实现</p>
</li>
<li><p>Common-Logging（JCL）</p>
<p>Common-Logging apache是常用的日志库门面。只有接口（<code>LogFactory</code>），没有实现。具体方案由各提供商实现</p>
</li>
</ul>
<h2 id="Java-SPI存在的问题"><a href="#Java-SPI存在的问题" class="headerlink" title="Java SPI存在的问题"></a>Java SPI存在的问题</h2><p>使用 Java SPI 能方便得解耦模块，使得接口的定义与具体业务实现分离。应用程序可以根据实际业务情况启用或替换具体组件。但是也有一些缺点：</p>
<ul>
<li><strong>不能按需加载</strong>。虽然 ServiceLoader 做了延迟载入，但是基本只能通过遍历全部获取，也就是接口的实现类得全部载入并实例化。如果你并不想用某些实现类，或者某些类实例化很耗时，它也被载入并实例化了，这就造成了浪费。</li>
<li><strong>获取某个实现类的方式不够灵活</strong>。只能通过 Iterator 形式获取，不能根据某个参数来获取对应的实现类。</li>
<li>多个并发多线程使用 ServiceLoader 类的实例是不安全的。</li>
</ul>
<h1 id="Spring-SPI"><a href="#Spring-SPI" class="headerlink" title="Spring SPI"></a>Spring SPI</h1><p>Spring的SPI机制其实就是SpringBoot自动装配的原理。在SpringBoot的自动装配过程中，最终会加载<code>META-INF/spring.factories</code>文件，而加载的过程是由<code>SpringFactoriesLoader</code>加载的。</p>
<p><code>@SpringBootApplication</code> → <code>@EnableAutoConfinguration</code>  → <code>@Import(AutoConfigurationImportSelector.class)</code></p>
<p>核心类<code>AutoConfigurationImportSelector</code>，这个类是自动装配的关键：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoConfigurationImportSelector</span> <span class="keyword">implements</span> <span class="title class_">DeferredImportSelector</span>, BeanClassLoaderAware,</span><br><span class="line">    ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered {</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) {</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) {</span><br><span class="line">      <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">AutoConfigurationEntry</span> <span class="variable">autoConfigurationEntry</span> <span class="operator">=</span> getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">    <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">protected</span> AutoConfigurationEntry <span class="title function_">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) {</span><br><span class="line">      <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> getAttributes(annotationMetadata);</span><br><span class="line">    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">    configurations = removeDuplicates(configurations);</span><br><span class="line">    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">    checkExcludedClasses(configurations, exclusions);</span><br><span class="line">    configurations.removeAll(exclusions);</span><br><span class="line">    configurations = getConfigurationClassFilter().filter(configurations);</span><br><span class="line">    fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AutoConfigurationEntry</span>(configurations, exclusions);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> List&lt;String&gt; <span class="title function_">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> {</span><br><span class="line">  List&lt;String&gt; configurations = ImportCandidates.load(AutoConfiguration.class, getBeanClassLoader())</span><br><span class="line">    .getCandidates();</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> configurations;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCATION</span> <span class="operator">=</span> <span class="string">"META-INF/spring/%s.imports"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取资源文件并获取Bean的URL</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ImportCandidates <span class="title function_">load</span><span class="params">(Class&lt;?&gt; annotation, ClassLoader classLoader)</span> {</span><br><span class="line">  Assert.notNull(annotation, <span class="string">"'annotation' must not be null"</span>);</span><br><span class="line">  <span class="type">ClassLoader</span> <span class="variable">classLoaderToUse</span> <span class="operator">=</span> decideClassloader(classLoader);</span><br><span class="line">  <span class="type">String</span> <span class="variable">location</span> <span class="operator">=</span> String.format(LOCATION, annotation.getName());</span><br><span class="line">  Enumeration&lt;URL&gt; urls = findUrlsInClasspath(classLoaderToUse, location);</span><br><span class="line">  List&lt;String&gt; importCandidates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">while</span> (urls.hasMoreElements()) {</span><br><span class="line">    <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> urls.nextElement();</span><br><span class="line">    importCandidates.addAll(readCandidateConfigurations(url));</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ImportCandidates</span>(importCandidates);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>我们可以看一下最后获取到的需要注入的Bean信息：</p>
<p><img src="/../images/SPI%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/image_aJce8e-8zN.png"></p>
<h1 id="Dubbo-SPI"><a href="#Dubbo-SPI" class="headerlink" title="Dubbo SPI"></a>Dubbo SPI</h1><p>补充一下Dubbo SPI 扩展能力的特性：</p>
<ul>
<li>按需加载。Dubbo 的扩展能力不会一次性实例化所有实现，可以根据别名实例化指定的扩展类</li>
<li>增加扩展类的 IOC 能力。Dubbo 的扩展能力并不仅仅只是发现扩展服务实现类，而是在此基础上更进一步，如果该扩展类的属性依赖其他对象，则 Dubbo 会自动的完成该依赖对象的注入功能。</li>
<li>增加扩展类的 AOP 能力。Dubbo 扩展能力会自动的发现扩展类的包装类，完成包装类的构造，增强扩展类的功能。</li>
<li>具备动态选择扩展实现的能力。Dubbo 扩展会基于参数，在运行时动态选择对应的扩展类，提高了 Dubbo 的扩展能力。</li>
<li>可以对扩展实现进行排序。能够基于用户需求，指定扩展实现的执行顺序。</li>
<li>提供扩展点的 Adaptive 能力。该能力可以使的一些扩展类在 consumer 端生效，一些扩展类在 provider 端生效。</li>
</ul>
<p>Dubbo SPI 加载扩展的工作流程：</p>
<p><img src="/../images/SPI%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/image_3P8oDOj5xz.png"></p>
<hr>
<p>参考：</p>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1985623" title="如何在项目中引入SPI">如何在项目中引入SPI</a></li>
<li><a href="https://blog.csdn.net/weixin_41564440/article/details/108705534" title="Spring SPI机制实现自动装配 实现自定义Starter组件">Spring SPI机制实现自动装配 实现自定义Starter组件</a></li>
</ul>
]]></content>
      <categories>
        <category>日常小记</category>
      </categories>
      <tags>
        <tag>SPI</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ学习笔记</title>
    <url>/2022/09/08/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="1-AMQP协议中的关键概念"><a href="#1-AMQP协议中的关键概念" class="headerlink" title="1 AMQP协议中的关键概念"></a>1 AMQP协议中的关键概念</h2><ul>
<li><code>Connection</code>socket连接，它封装了socket协议相关部分逻辑。你可以认为一个Connection就是一个Tcp连接。</li>
<li><code>Channel</code>生产者与Broker通信的通道，可以把通道理解成共享一个 TCP 连接的多个轻量化连接（通常每个thread创建单独的channel进行通讯）。</li>
</ul>
<blockquote>
<p><code>Connection</code>就是一个TCP连接对象，而<code>Channel</code>相当于连接池</p>
</blockquote>
<ul>
<li><code>Exchange</code>交换器，接收消息，按照路由规则将消息路由到一个或者多个队列</li>
<li><code>Queue</code>消息队列，用来保存消息，供消费者消费</li>
<li><code>Produce/Consumer</code>消息生产者和消费者</li>
<li><code>Binding</code>绑定，交换器和消息队列之间的虚拟连接，绑定中可以包含一个或者多个 RoutingKey。</li>
<li><code>RoutingKey</code>路由键，生产者将消息发送给交换器的时候，会指定一个 RoutingKey，用来指定路由规则，交换器根据路由键把消息发送到指定队列</li>
</ul>
<span id="more"></span>

<h2 id="2-消息队列模式"><a href="#2-消息队列模式" class="headerlink" title="2 消息队列模式"></a>2 消息队列模式</h2><h3 id="2-1-点对点模式"><a href="#2-1-点对点模式" class="headerlink" title="2.1 点对点模式"></a>2.1 点对点模式</h3><p><img src="/../images/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/e6053e18-99d6-4914-b06a-4dc65d258a30_1koS-yViN2.png"></p>
<p>点对点模式特点：<strong>一个具体的消息只能由一个消费者消费</strong>，多个生产者可以向同一个消息队列发送消息，但是一个消息在被一个消息者处理的时候，这个消息在队列上会被锁住或者被移除并且其他消费者无法处理该消息。</p>
<h3 id="2-2-发布-订阅模式"><a href="#2-2-发布-订阅模式" class="headerlink" title="2.2 发布/订阅模式"></a>2.2 发布/订阅模式</h3><p><strong>单个消息可以被多个订阅者并发的获取和处理</strong>。一般来说，订阅有两种类型：</p>
<ul>
<li>临时订阅：这种订阅只有在消费者启动并且运行的时候才存在。一旦消费者退出，相应的订阅以及尚未处理的消息就会丢失。</li>
<li>持久订阅：这种订阅会一直存在，除非主动去删除。消费者退出后，消息系统会继续维护该订阅，并且后续消息可以被继续处理。</li>
</ul>
<p><img src="/../images/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image_TSARw_VzVJ.png"></p>
<h2 id="3-RabbitMQ原理"><a href="#3-RabbitMQ原理" class="headerlink" title="3 RabbitMQ原理"></a>3 RabbitMQ原理</h2><p>RabbbitMQ使用Erlang语言开发，基于AMQP协议实现。AMQP协议由三部分组成，分别是消费者，生产者和服务端。执行流程如下：</p>
<ol>
<li><p>生产者连接到Server，建立一个连接，开启一个通道。</p>
</li>
<li><p>生产者声明交换器和队列，设置相关属性，并通过路由键将交换器和队列进行绑定。</p>
</li>
<li><p>消费者也需要进行建立连接，开启信道等操作，便于接收消息。</p>
</li>
<li><p>生产者发送消息，发送到服务端中的虚拟主机。</p>
</li>
<li><p>虚拟主机中的交换器根据路由键选择路由规则，发送到不同的消息队列中。</p>
</li>
<li><p>订阅了消息队列的消费者就可以获取到消息，进行消费。</p>
</li>
</ol>
<p><img src="/../images/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/82ff9d01-1ac7-4463-9733-a7372c642d35_wBUrxx8cW8.png"></p>
<blockquote>
<p>📌RabbitMQ 消息传递模型的核心思想是生产者从不直接向队列发送任何消息。实际上，生产者通常根本不知道消息是否会被传递到任何队列。</p>
<p>相反，生产者只能将消息发送到交换器。交换是一件非常简单的事情。一方面，它接收来自生产者的消息，另一方面，它将消息推送到队列。</p>
<p>交换机绑定多个队列，一个队列绑定一个键</p>
</blockquote>
<h3 id="3-1-交换机"><a href="#3-1-交换机" class="headerlink" title="3.1 交换机"></a>3.1 交换机</h3><p>Rabbitmq队列和交换机是绑定的，每个队列都有一个***<code>routingKey</code><em><strong>，发布者每次发布的消息也有一个</strong></em><code>routingKey</code>***，交换机会根据不同的匹配规则将消息匹配到与自己绑定的队列中</p>
<p>RabbitMQ常用交换机有四种：</p>
<h4 id="3-1-1-Direct"><a href="#3-1-1-Direct" class="headerlink" title="3.1.1 Direct"></a>3.1.1 Direct</h4><p>Direct exchange背后的路由算法很简单 - 消息进入其绑定键与消息的路由键完全匹配的队列。</p>
<p><img src="/../images/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image_gOLw0gI3JR.png"></p>
<blockquote>
<p>多重绑定</p>
<p>使用相同的绑定键绑定多个队列是完全合法的。在我们的示例中，我们可以使用绑定键black在X和Q1之间添加绑定。在这种情况下，直接交换的行为将类似于扇出，并将消息广播到所有匹配的队列。</p>
<p><img src="/../images/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image_ILV-y7PI8A.png"></p>
</blockquote>
<h4 id="3-1-2-Topic-exchange"><a href="#3-1-2-Topic-exchange" class="headerlink" title="3.1.2 Topic exchange"></a>3.1.2 Topic exchange</h4><p>**<code>topic</code>**：将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“*”只能匹配一个词</p>
<p>发送到Topic exchange的 <code>routing_key</code>它必须是一个由点分隔的单词列表。这些单词可以是任何内容，但通常它们指定与消息相关的一些功能。一些有效的路由键示例： <code>stock.usd.nyse</code> 、 <code>nyse.vmw</code> 、<code>quick.orange.rabbit</code> 。路由密钥中可以有任意多个单词，最多 255 个字节。</p>
<p><img src="/../images/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image_WeBDd2GgZO.png"></p>
<ul>
<li><code>*</code>可以恰好替代一个单词。</li>
<li><code>#</code>可以替代零个或多个单词。</li>
</ul>
<p>当队列与<code>#</code>绑定键绑定时 - 它将接收所有消息，无论路由键如何 - 就像在扇区交换器中一样。</p>
<h4 id="3-1-3-Fanout"><a href="#3-1-3-Fanout" class="headerlink" title="3.1.3 Fanout"></a>3.1.3 Fanout</h4><p>Fanout 不处理路由键，而是广播。你只需要简单的将队列绑定到交换机上。一个发送到该类型交换机的消息都会被广播到与该交换机绑定的所有队列上</p>
<h4 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a><strong>Headers</strong></h4><p>不处理路由键，而是根据发送的消息内容中的headers属性进行匹配。</p>
<h3 id="3-2-队列"><a href="#3-2-队列" class="headerlink" title="3.2 队列"></a>3.2 队列</h3><h4 id="3-2-1-死信队列"><a href="#3-2-1-死信队列" class="headerlink" title="3.2.1 死信队列"></a>3.2.1 死信队列</h4><p>来自队列的消息可能是“<strong>死信的</strong>”；也就是说，当发生以下任何事件时，重新发布到交换机：</p>
<ul>
<li>消费者使用<code>basic.reject</code>或 <code>basic.nack</code>否定确认消息，并将requeue参数设置为false。</li>
<li>由于每条消息 TTL（最大存活时间） 的原因，该消息过期；</li>
<li>由于队列超出长度限制，消息被丢弃</li>
</ul>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>一般用在较为重要的业务队列中，为了确保未被正确消费的消息不被丢弃，当发生异常时，通过死信队列，可以让未正确处理的消息暂存到另一个队列中。待后续排查清楚问题后，编写相应的处理代码来处理死信消息，这样比手工恢复数据要好太多了 。</p>
<h4 id="3-2-2-延时队列"><a href="#3-2-2-延时队列" class="headerlink" title="3.2.2 延时队列"></a>3.2.2 延时队列</h4><p>​ 延迟队列存储的对象肯定是对应的延时消息，所谓”延时消息”是指当消息被发送以后，并不想让消费者立即拿到消息，而是等待指定时间后，消费者才拿到这个消息进行消费。</p>
<h3 id="3-3-ACK机制"><a href="#3-3-ACK机制" class="headerlink" title="3.3 ACK机制"></a>3.3 ACK机制</h3><p>ACK机制是消费者从RabbitMQ收到消息并处理完成后，反馈给RabbitMQ，RabbitMQ收到反馈后才将次消息从队列中删除。如果消费者处理消息时出现异常，RabbitMQ会认为消息未被正常消费，将消息重新放入队列中。可以在消费消息中try-catch或在Consumer的配置文件中配置重试机制来解决这个问题。</p>
<h3 id="3-4-重试机制"><a href="#3-4-重试机制" class="headerlink" title="3.4 重试机制"></a>3.4 重试机制</h3><p>在消息<strong>消费失败</strong>的时候，Spring-AMQP 会通过<strong>消费重试</strong>机制，重新投递该消息给 Consumer ，让 Consumer 有机会重新消费消息，实现消费成功。</p>
<p>当然，Spring-AMQP 并不会无限重新投递消息给 Consumer 重新消费，而是在默认情况下，达到 N 次重试次数时，Consumer 还是消费失败时，该消息就会进入到<strong>死信队列</strong>。后续，我们可以通过对死信队列中的消息进行重发，来使得消费者实例再次进行消费。</p>
<p>为了效率和节省资源，我们一般会选择<code>CONNECTION</code>模式</p>
<h2 id="4-衡量标准"><a href="#4-衡量标准" class="headerlink" title="4 衡量标准"></a>4 衡量标准</h2><ul>
<li><strong>消息顺序</strong>：发送到队列的消息，消费时是否可以保证消费的顺序，比如 A 先下单，B 后下单，应该是 A 先去扣库存，B 再去扣，顺序不能反。</li>
<li><strong>消息路由</strong>：根据路由规则，只订阅匹配路由规则的消息，比如有 A/B 两者规则的消息，消费者可以只订阅 A 消息，B 消息不会消费。</li>
<li>消息可靠性：是否会存在丢消息的情况，比如有 A/B 两个消息，最后只有 B 消息能消费，A 消息丢失。</li>
<li><strong>消息时序</strong>：主要包括 “消息存活时间” 和“延迟 / 预定的消息”，“消息存活时间”表示生产者可以对消息设置 TTL，如果超过该 TTL，消息会自动消失；“延迟 / 预定的消息”指的是可以延迟或者预订消费消息，比如延时 5 分钟，那么消息会 5 分钟后才能让消费者消费，时间未到的话，是不能消费的。</li>
<li><strong>消息留存</strong>：消息消费成功后，是否还会继续保留在消息队列。</li>
<li><strong>容错性</strong>：当一条消息消费失败后，是否有一些机制，保证这条消息是一种能成功，比如异步第三方退款消息，需要保证这条消息消费掉，才能确定给用户退款成功，所以必须保证这条消息消费成功的准确性。</li>
<li><strong>伸缩</strong>：当消息队列性能有问题，比如消费太慢，是否可以快速支持库容；当消费队列过多，浪费系统资源，是否可以支持缩容。</li>
<li><strong>吞吐量</strong>：支持的最高并发数。</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>中间件</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Event机制详解</title>
    <url>/2024/08/11/Spring-%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>Spring的事件机制提供了一种低耦合、无侵入的解决方式，它由三部分组成：</p>
<ul>
<li><code>ApplicationEventPublisher</code>：发布器，让容器拥有发布应用上下文事件的功能，包括容器启动事件、关闭事件等。</li>
<li><code>ApplicationListener</code>：监听器 ，可以接收到容器事件 ， 并对事件进行响应处理 。</li>
<li><code>ApplicationEventMulticaster</code>：事件多播器，它负责保存所有监听器，以便在容器产生上下文事件时通知这些事件监听者。</li>
<li><code>ApplicationEvent</code>：具体的事件</li>
</ul>
<p><img src="/../images/Spring-%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/image_k6VpJmK7hm.png"></p>
<blockquote>
<p>图片来自：<a href="https://juejin.cn/post/7140849555607650335#heading-10" title="https://juejin.cn/post/7140849555607650335#heading-10">https://juejin.cn/post/7140849555607650335#heading-10</a></p>
</blockquote>
<h2 id="1-Spring中的内置事件"><a href="#1-Spring中的内置事件" class="headerlink" title="1 Spring中的内置事件"></a>1 Spring中的内置事件</h2><p><img src="/../images/Spring-%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/image_NIowE11gVH.png"></p>
<ul>
<li><code>ContextRefreshedEvent</code>：在<code>refresh()</code>执行完成时触发，通知容器刷新完成。<ul>
<li>很适合我们做一些系统启动后的准备工作，此时我们就可以监听该事件，作为系统启动后初始预热的契机。</li>
</ul>
</li>
<li><code>ContextStartedEvent</code>：<code>ConfigurableApplicationContext</code>的<code>start()</code>执行完成时触发<ul>
<li>该事件的触发是所有的单例bean创建完成后发布，此时实现了<code>Lifecycle</code>接口的bean还没有回调<code>start()</code>，当这些<code>start()</code>被调用后，才会发布<code>ContextStartedEvent</code>事件。</li>
</ul>
</li>
<li><code>ContextClosedEvent</code>：<code>ConfigurableApplicationContext</code>的<code>close()</code>执行完成时触发<ul>
<li>此时IOC容器已经关闭，但尚未销毁所有的bean。</li>
</ul>
</li>
<li><code>ContextStoppedEvent</code>：<code>ConfigurableApplicationContext</code>的<code>stop()</code>执行完成时触发</li>
</ul>
<h2 id="2-自定义事件的使用"><a href="#2-自定义事件的使用" class="headerlink" title="2 自定义事件的使用"></a>2 自定义事件的使用</h2><ul>
<li><p><strong>定义事件</strong></p>
<p>自定义事件在使用上很简单，继承 ApplicationEvent 即可:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplicationEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> {</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyApplicationEvent</span><span class="params">(Long id)</span> {</span><br><span class="line">        <span class="built_in">super</span>(id);</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getId</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>发布自定义事件</strong></p>
<p><code>ApplicationContext</code>继承了<code>ApplicationEventPublisher</code>，因此也拥有消息发布的能力：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">applicationContext.publishEvent(<span class="keyword">new</span> <span class="title class_">MyApplicationEvent</span>(<span class="number">1L</span>));</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>定义监听器</strong></p>
<p>监听器需要实现<code>ApplicationListener</code>接口，<code>onApplicationEvent()</code>负责处理具体的事件</p>
<p>注意：需要通过泛型参数指定处理的事件类型</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyEventListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;MyApplicationEvent&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(MyApplicationEvent event)</span> {</span><br><span class="line">        System.out.println(event.getSource());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="3-ApplicationListener注册过程"><a href="#3-ApplicationListener注册过程" class="headerlink" title="3 ApplicationListener注册过程"></a>3 ApplicationListener注册过程</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException {</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 初始化各种监听器</span></span><br><span class="line">    <span class="built_in">this</span>.registerListeners();</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册监听器</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerListeners</span><span class="params">()</span> {</span><br><span class="line">  <span class="comment">// 1: 处理context.addApplicationListener() 方式注册的监听器，并将监听器注册到广播器中，</span></span><br><span class="line">  <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : <span class="built_in">this</span>.getApplicationListeners()) {</span><br><span class="line">    <span class="built_in">this</span>.getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2: 去Spring容器中获取监听器（处理扫描的或者register方式注册的）,同样也是添加到广播器中</span></span><br><span class="line">  String[] listenerBeanNames = <span class="built_in">this</span>.getBeanNamesForType(ApplicationListener.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) {</span><br><span class="line">    <span class="built_in">this</span>.getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>值得注意的是，IoC容器会扫描继承了<code>ApplicationListener</code>的监听器作为Bean并注册到容器中，但通过<code>@EventListener</code>方式注册的是一个方法，监听者应该是一个实例对象，那它是怎么被识别并注册呢？</p>
<h3 id="3-1-EventListener是如何工作的？"><a href="#3-1-EventListener是如何工作的？" class="headerlink" title="3.1 @EventListener是如何工作的？"></a>3.1 @EventListener是如何工作的？</h3><p>每次面对这种不同的注册方式时，适配器模式就要登场了。<code>@EventListener</code>的扫描和注册过程我觉得也很有参考意义，在此记录一下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException {</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    ..</span><br><span class="line">    <span class="comment">// 普通单例Bean的实例化</span></span><br><span class="line">    <span class="built_in">this</span>.finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> {</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 初始化非延迟加载的单例bean</span></span><br><span class="line">    beanFactory.preInstantiateSingletons();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException {</span><br><span class="line">    List&lt;String&gt; beanNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line">    <span class="comment">// 1: 完成bean的实例化</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) {</span><br><span class="line">        <span class="comment">// 调用BeanFactory尝试获取Bean，获取不到会创建Bean</span></span><br><span class="line">        getBean(beanName);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2: 调用bean的后置处理方法</span></span><br><span class="line">    <span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) {</span><br><span class="line">      <span class="comment">// singletonInstance instanceof SmartInitializingSingleton</span></span><br><span class="line">      smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>这里的<code>smartSingleton.afterSingletonsInstantiated()</code>会触发所有适用 bean 的回调：</p>
<p><img src="/../images/Spring-%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/image_9NiB6Gnaat.png"></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// EventListenerMethodProcessor.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterSingletonsInstantiated</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) {</span><br><span class="line">        processBean(beanName, type);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Class&lt;?&gt; targetType)</span> {</span><br><span class="line">    <span class="comment">// 1: 解析bean上加了@EventListener的方法</span></span><br><span class="line">    Map&lt;Method, EventListener&gt; annotatedMethods = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        annotatedMethods = MethodIntrospector.selectMethods(targetType,</span><br><span class="line">                        (MethodIntrospector.MetadataLookup&lt;EventListener&gt;) method -&gt;</span><br><span class="line">        AnnotatedElementUtils.findMergedAnnotation(method, EventListener.class));</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 2: 遍历加了@EventListener的方法，注册为事件监听器</span></span><br><span class="line">    <span class="keyword">for</span> (Method method : annotatedMethods.keySet()) {</span><br><span class="line">        <span class="keyword">for</span> (EventListenerFactory factory : factories) {</span><br><span class="line">            <span class="keyword">if</span> (factory.supportsMethod(method)) {</span><br><span class="line">                <span class="type">Method</span> <span class="variable">methodToUse</span> <span class="operator">=</span> AopUtils.selectInvocableMethod(method, context.getType(beanName));</span><br><span class="line">                <span class="comment">// 2.1 通过EventListenerFactory，将方法创建为监听器实例(ApplicationListenerMethodAdapter)</span></span><br><span class="line">                ApplicationListener&lt;?&gt; applicationListener = factory.createApplicationListener(beanName, targetType, methodToUse);</span><br><span class="line">                <span class="keyword">if</span> (applicationListener <span class="keyword">instanceof</span> ApplicationListenerMethodAdapter) {</span><br><span class="line">                        ((ApplicationListenerMethodAdapter) applicationListener).init(context, <span class="built_in">this</span>.evaluator);</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 2.2 注册为ApplicationListener</span></span><br><span class="line">                context.addApplicationListener(applicationListener);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结一下流程：在容器中所有的bean实例化后，会再次遍历所有bean，调用<code>afterSingletonsInstantiated()</code>的方法，此时符合条件的<code>EventListenerMethodProcessor</code>就会被调用</p>
<p><img src="/../images/Spring-%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/image_qNXImWUpet.png"></p>
<blockquote>
<p>关于@EventListener标注方法的解析时机，笔者首先想到的应该和<code>@Bean</code>的处理时机一致，在扫描类的时候，就解析出来加了<code>@EventListener</code>的方法，抽象为BeanDefinition放到容器中，后面实例化时候，和正常扫描出来的bean是一样的实例化流程。但是查找下来发现Spring并没有这样处理，而是在bean初始化后回调阶段处理的。究其原因，大概是@Bean真的是需要托付给Spring管理，而<code>@EventListener</code>只是一个标识，无需放入放入容器，防止对完暴露所致吧。</p>
</blockquote>
<h2 id="4-Spring如何广播消息？"><a href="#4-Spring如何广播消息？" class="headerlink" title="4 Spring如何广播消息？"></a>4 Spring如何广播消息？</h2><p><code>ApplicationEventMulticaster</code>负责事件的分发，我们可以看一下它的具体实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// SimpleApplicationEventMulticaster.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> {</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// getApplicationListeners 获取符合的监听器</span></span><br><span class="line">    <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) {</span><br><span class="line">        <span class="comment">// 执行每个监听器的逻辑</span></span><br><span class="line">         <span class="comment">// 注意，这里是同步的 </span></span><br><span class="line">        invokeListener(listener, event);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// invokeListener最后调用doInvokeListener</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doInvokeListener</span><span class="params">(ApplicationListener listener, ApplicationEvent event)</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      <span class="comment">// 调用监听器的onApplicationEvent方法进行处理</span></span><br><span class="line">      listener.onApplicationEvent(event);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>getApplicationListeners()</code>找到了所有匹配的监听器，我们继续跟踪看一下是如何进行事件匹配的：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Collection&lt;ApplicationListener&lt;?&gt;&gt; getApplicationListeners(</span><br><span class="line">      ApplicationEvent event, ResolvableType eventType) {</span><br><span class="line">   <span class="comment">// 省略缓存相关代码</span></span><br><span class="line">   <span class="keyword">return</span> retrieveApplicationListeners(eventType, sourceType, newRetriever);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Collection&lt;ApplicationListener&lt;?&gt;&gt; retrieveApplicationListeners(</span><br><span class="line">ResolvableType eventType, <span class="meta">@Nullable</span> Class&lt;?&gt; sourceType, <span class="meta">@Nullable</span> CachedListenerRetriever retriever) {</span><br><span class="line">    <span class="comment">// 1: 获取所有的ApplicationListener</span></span><br><span class="line">    Set&lt;ApplicationListener&lt;?&gt;&gt; listeners;</span><br><span class="line">    Set&lt;String&gt; listenerBeans;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.defaultRetriever) {</span><br><span class="line">        listeners = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="built_in">this</span>.defaultRetriever.applicationListeners);</span><br><span class="line">        listenerBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="built_in">this</span>.defaultRetriever.applicationListenerBeans);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : listeners) {</span><br><span class="line">        <span class="comment">// 2: 遍历判断是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> (supportsEvent(listener, eventType, sourceType)) {</span><br><span class="line">            <span class="keyword">if</span> (retriever != <span class="literal">null</span>) {</span><br><span class="line">                filteredListeners.add(listener);</span><br><span class="line">            }</span><br><span class="line">            allListeners.add(listener);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">supportsEvent</span><span class="params">(</span></span><br><span class="line"><span class="params">  ApplicationListener&lt;?&gt; listener, ResolvableType eventType, <span class="meta">@Nullable</span> Class&lt;?&gt; sourceType)</span> {</span><br><span class="line">  <span class="type">GenericApplicationListener</span> <span class="variable">smartListener</span> <span class="operator">=</span> (listener <span class="keyword">instanceof</span> GenericApplicationListener ?</span><br><span class="line">                                              (GenericApplicationListener) listener : <span class="keyword">new</span> <span class="title class_">GenericApplicationListenerAdapter</span>(listener));</span><br><span class="line">  <span class="comment">// supportsEventType 根据ApplicationListener的泛型, 和事件类型,看是否匹配</span></span><br><span class="line">  <span class="comment">// supportsSourceType 根据事件源类型，判断是否匹配</span></span><br><span class="line">  <span class="keyword">return</span> (smartListener.supportsEventType(eventType) &amp;&amp; smartListener.supportsSourceType(sourceType));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上就是<code>ApplicationEventMulticaster</code>分发事件的大致逻辑，本质上就是通过泛型查找到所有匹配的监听器，然后在一个for循环中调用监听器的事件处理方法</p>
<p>但是这里也有一个问题，这种方式事件的处理是同步的，可能会存在发布阻塞的问题，并且有性能问题。有没有办法能够使用异步机制来处理消息呢？</p>
<h2 id="5-异步处理事件"><a href="#5-异步处理事件" class="headerlink" title="5 异步处理事件"></a>5 异步处理事件</h2><p>Spring提供了两种异步处理事件的方式：</p>
<h3 id="5-1-给ApplicationEventMulticaster添加线程池"><a href="#5-1-给ApplicationEventMulticaster添加线程池" class="headerlink" title="5.1 给ApplicationEventMulticaster添加线程池"></a>5.1 给ApplicationEventMulticaster添加线程池</h3><p>通过<code>setTaskExecutor()</code>方法可以给<code>ApplicationEventMulticaster</code>设置线程池，这样的做法是全局生效的：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> {</span><br><span class="line">    <span class="comment">// 获取执行线程池</span></span><br><span class="line">    <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> getTaskExecutor();</span><br><span class="line">    <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) {</span><br><span class="line">        <span class="comment">// 如果存在线程池，使用线程池异步执行</span></span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="literal">null</span>) {</span><br><span class="line">            executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果不存在线程池，同步执行</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            invokeListener(listener, event);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTaskExecutor</span><span class="params">(<span class="meta">@Nullable</span> Executor taskExecutor)</span> {</span><br><span class="line">    <span class="built_in">this</span>.taskExecutor = taskExecutor;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="5-2-使用-Async"><a href="#5-2-使用-Async" class="headerlink" title="5.2 使用@Async"></a>5.2 使用<code>@Async</code></h3><p>还有一种方式是通过给监听者的<code>onApplicationEvent()</code>添加<code>@Async</code>注解使其变成异步的，这种方式只对单个方法生效，使用方式就跟我们平时定义的异步方法一样，这里就不多赘述了</p>
<h2 id="6-全局异常处理"><a href="#6-全局异常处理" class="headerlink" title="6 全局异常处理"></a>6 全局异常处理</h2><p><code>ApplicationEventMulticaster</code>分发事件的时候发生异常怎么办，后面的监听器还能执行吗？</p>
<p>Spring事件的处理，默认是同步依次执行。那如果前面的监听器出现了异常，并且没有处理异常，会对后续的监听器还能顺利接收该事件吗？其实不能的，因为异常中断了事件的发送了</p>
<p>如果设置了异步执行，因为不是一个线程执行，是不会互相影响的。</p>
<p>Spring提供了ErrorHandler来方便我们对消息处理异常进行统一处理：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">ApplicationEventMulticaster</span> <span class="variable">multicaster</span> <span class="operator">=</span> context.getBean(AbstractApplicationContext.APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line">((SimpleApplicationEventMulticaster) multicaster).setErrorHandler(t -&gt; System.out.println(t));</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h2><p><strong>Spring事件机制存在什么问题？</strong></p>
<p>我认为主要的问题还是公共线程池造成的问题：</p>
<ol>
<li><p><strong>发布阻塞</strong></p>
<p> <strong>监听器的执行速度会互相影响、甚至会发生阻塞</strong>。假如某一个监听器执行的很慢，把线程池中线程都占用了，此时其他的事件虽然发布但没有资源执行，只能在缓存队列等待线程释放<br> 其实这里可以参考Netty的boss-work工作模型，广播器只负责分发事件，调度执行监听器的逻辑交给由具体的work线程负责会更合适。</p>
</li>
<li><p><strong>无法定制监听器执行线程池</strong></p>
<p> 由于每种事件产生的数量、处理逻辑、处理速度差异化可能很大，所以每个监听器都有适合自己场景的线程数，为每个监听器配置单独的线程池尤为重要。Spring事件机制无法单独为监听器设置线程池，只能共用线程池，无法做到精准控制，线程拥堵或者线程浪费出现的几率极大</p>
<p> 虽然我们也可以在接收到事件后使用自定义的线程池处理，但是我们更希望简单化配置就能支持</p>
</li>
</ol>
<hr>
<p>参考：</p>
<ul>
<li><a href="https://juejin.cn/post/7140849555607650335#heading-14">聊透Spring事件机制</a></li>
</ul>
]]></content>
      <categories>
        <category>Spring体系结构</category>
      </categories>
      <tags>
        <tag>Spring源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>SpingBoot3.0 升级记录</title>
    <url>/2024/06/04/Spingboot3.0%20%E5%8D%87%E7%BA%A7%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<blockquote>
<p><strong>背景</strong>：在原来一个基于 SpringBoot 2.6.x 的项目中，引入了一个第三方库后，发现无法正常加载其自动装配的Bean。经过排查，发现第三方库基于Spring Boot 3.2.4 版本开发，存在依赖注入方式上的差异。为了兼容性，决定将原项目升级至 Spring Boot 3.x。鉴于 Spring Boot 3.0 的重大变化，本文详细记录了迁移过程中遇到的关键改动及解决方案。</p>
</blockquote>
<h2 id="SpringBoot-3-0主要改动"><a href="#SpringBoot-3-0主要改动" class="headerlink" title="SpringBoot 3.0主要改动"></a>SpringBoot 3.0主要改动</h2><p>以下是SpringBoot 3.0 中最重要的变动：</p>
<ul>
<li><strong>最低 Java 版本要求</strong>：升级至 Java 17。</li>
<li><strong>移除内置配置</strong>：例如，MySQL 驱动等配置被移除，官方提供迁移工具协助升级：</li>
</ul>
<span id="more"></span>

<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-properties-migrator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>Jakarta EE 替代 Java EE</strong>：所有 <code>javax</code> 包被替换为 <code>jakarta</code> 包：</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">javax.persistence.*   -&gt; jakarta.persistence.*</span><br><span class="line">javax.validation.*    -&gt; jakarta.validation.*</span><br><span class="line">javax.servlet.*       -&gt; jakarta.servlet.*</span><br><span class="line">javax.annotation.*    -&gt; jakarta.annotation.*</span><br><span class="line">javax.transaction.*   -&gt; jakarta.transaction.*</span><br></pre></td></tr></tbody></table></figure>

<p>更多改动详情，参考官方文档：<a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Release-Notes">SpringBoot 3.0 发布说明</a></p>
<h2 id="项目迁移中发现的问题"><a href="#项目迁移中发现的问题" class="headerlink" title="项目迁移中发现的问题"></a>项目迁移中发现的问题</h2><h3 id="自定义-Starter-不兼容"><a href="#自定义-Starter-不兼容" class="headerlink" title="自定义 Starter 不兼容"></a>自定义 Starter 不兼容</h3><p>原版本中自定义Starter的方式为：在扫描类上使用<code>@Configuration</code>注解，并在<code>META-INF/spring.factories</code>文件中声明该扫描类：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">{{启动类路径}}</span><br></pre></td></tr></tbody></table></figure>

<p>而在新版中，自定义Starter应采用<code>@AutoConfiguration</code>注解，<br>并在 <code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code> 文件中声明扫描类：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">{{启动类路径}}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Mybatis-兼容性问题"><a href="#Mybatis-兼容性问题" class="headerlink" title="Mybatis 兼容性问题"></a>Mybatis 兼容性问题</h3><p><img src="/../images/Spingboot3.0-%E5%8D%87%E7%BA%A7%E8%AE%B0%E5%BD%95/Secure2%20Image.png" alt="Secure2 Image"></p>
<p><strong>原因</strong>：Mybatis 旧版本与 SpringBoot 3.0 不兼容，需升级至 Mybatis 3.x 版本或更高。</p>
]]></content>
      <categories>
        <category>日常小记</category>
      </categories>
  </entry>
  <entry>
    <title>Spring Lazy-init 踩坑记录</title>
    <url>/2023/11/01/Spring%20Lazy-init%20%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<blockquote>
<p>起因：在写一个Springboot项目时，队友将项目加载方式改为<code>lazy-init</code>，理由是能加快重启的速度，但是导致了Bug</p>
</blockquote>
<span id="more"></span>

<p><img src="/../images/289b54f1b37819da340708c7cfb9e261_rfYNVwE36_.png"></p>
<p><img src="/../images/1551908c7fb3dddbbc2d3b1e90a48cf1_gLwVbcWEG6.png"></p>
<p>Spring在Bean初始化阶段会对所有继承了<code>ApplicationContextAware</code>接口的类注入<code>ApplicationContext</code></p>
<p>但是如果设置了<code>lazy-init</code>，bean加载顺序变了，<code>setApplicationContext</code>就不执行了</p>
]]></content>
      <categories>
        <category>日常小记</category>
      </categories>
      <tags>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 事务体系</title>
    <url>/2024/01/08/Spring-%E4%BA%8B%E5%8A%A1%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<p>最近了解到，Spring中的事务是由AOP实现的（当然这里说的是声明式事务），至于里面具体的逻辑是怎么样的，今天花了一天的时间看代码，总算弄是明白了大概流程😎，至于里面很多技术细节还没去深挖，先这样吧╮(╯_╰)╭</p>
<h2 id="Spring-事务相关的API"><a href="#Spring-事务相关的API" class="headerlink" title="Spring 事务相关的API"></a>Spring 事务相关的API</h2><p>先看看概念：</p>
<p><strong>事务操作相关的API</strong></p>
<ul>
<li><code>@Transactional</code> - Spring事务注解</li>
<li><code>@EnableTranSactionManagement</code> - Spring事务模块驱动</li>
</ul>
<p><strong>事务抽象相关的API</strong></p>
<ul>
<li><strong><code>PlatformTransactionManager</code></strong> - Spring平台事务管理器，负责执行事务的关键类</li>
<li><code>TransactionStatus</code> - Spring事务状态</li>
<li><code>TransactionDefinition</code> - Spring事务定义</li>
<li><strong><code>ProxyTransactionManagementConfiguration</code></strong> - Spring事务代理配置类</li>
</ul>
<p><strong>AOP相关的API</strong></p>
<ul>
<li><strong><code>BeanFactoryTransactionAttrubuteSourceAdvisor</code></strong> - Spring事务PointcutAdvisor实现</li>
<li><strong><code>TransactionInterceptor</code></strong> - 事务执行切面，负责事务执行的核心类</li>
<li><strong><code>TransactionAttributeSource</code></strong> - Spring事务属性源</li>
<li><strong><code>TransactionAnnotationParser</code></strong> - 解析器，负责扫描并解析所有的带有@Transactional的方法或类，并将数据封装为<code>TransactionAttributeSource</code></li>
<li><code>TransactionSynchronizationAdapter</code> - 事务同步器，感知事务是成功还是失败，在事务提交前后通知，这个在做一些需要监听事务状态的业务需求估计会比较有用吧🤨</li>
</ul>
<span id="more"></span>

<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p><code>ProxyTransactionManagementConfiguration</code>是通过<code>@EnableTranSactionManagement</code>注入的核心配置类，内部实际注册了三个Bean，这三个Bean其实是AOP的三部分：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line"><span class="meta">@ImportRuntimeHints(TransactionRuntimeHints.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTransactionManagementConfiguration</span> <span class="keyword">extends</span> <span class="title class_">AbstractTransactionManagementConfiguration</span> {</span><br><span class="line"></span><br><span class="line">  <span class="comment">// AOP的PointcutAdvisor</span></span><br><span class="line">  <span class="comment">// PointcutAdvisor = PointCut + Advice</span></span><br><span class="line">  <span class="meta">@Bean(name = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME)</span></span><br><span class="line">  <span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line">  <span class="keyword">public</span> BeanFactoryTransactionAttributeSourceAdvisor <span class="title function_">transactionAdvisor</span><span class="params">(</span></span><br><span class="line"><span class="params">      TransactionAttributeSource transactionAttributeSource, TransactionInterceptor transactionInterceptor)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="type">BeanFactoryTransactionAttributeSourceAdvisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanFactoryTransactionAttributeSourceAdvisor</span>();</span><br><span class="line">    advisor.setTransactionAttributeSource(transactionAttributeSource);</span><br><span class="line">    advisor.setAdvice(transactionInterceptor);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.enableTx != <span class="literal">null</span>) {</span><br><span class="line">      advisor.setOrder(<span class="built_in">this</span>.enableTx.&lt;Integer&gt;getNumber(<span class="string">"order"</span>));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> advisor;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PointCut</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line">  <span class="keyword">public</span> TransactionAttributeSource <span class="title function_">transactionAttributeSource</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// Accept protected @Transactional methods on CGLIB proxies, as of 6.0.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnnotationTransactionAttributeSource</span>(<span class="literal">false</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Advice</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line">  <span class="keyword">public</span> TransactionInterceptor <span class="title function_">transactionInterceptor</span><span class="params">(TransactionAttributeSource transactionAttributeSource)</span> {</span><br><span class="line">    <span class="type">TransactionInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionInterceptor</span>();</span><br><span class="line">    interceptor.setTransactionAttributeSource(transactionAttributeSource);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.txManager != <span class="literal">null</span>) {</span><br><span class="line">      interceptor.setTransactionManager(<span class="built_in">this</span>.txManager);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> interceptor;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中<code>BeanFactoryTransactionAttributeSourceAdvisor</code>负责将<code>PointCut</code>和<code>Advice</code>注入到AOP中，没有什么复杂的逻辑</p>
<p>下面介绍一下<code>TransactionAttributeSource</code>和<code>TransactionInterceptor</code></p>
<h3 id="TransactionAttributeSource"><a href="#TransactionAttributeSource" class="headerlink" title="TransactionAttributeSource"></a>TransactionAttributeSource</h3><p>上面注入了一个<code>AnnotationTransactionAttributeSource</code>，我们来看看这个Bean做了什么</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 添加解析器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationTransactionAttributeSource</span><span class="params">(<span class="type">boolean</span> publicMethodsOnly)</span> {</span><br><span class="line">  <span class="built_in">this</span>.publicMethodsOnly = publicMethodsOnly;</span><br><span class="line">  <span class="keyword">if</span> (jta12Present || ejb3Present) {</span><br><span class="line">    <span class="built_in">this</span>.annotationParsers = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">this</span>.annotationParsers.add(<span class="keyword">new</span> <span class="title class_">SpringTransactionAnnotationParser</span>());</span><br><span class="line">    <span class="keyword">if</span> (jta12Present) {</span><br><span class="line">      <span class="built_in">this</span>.annotationParsers.add(<span class="keyword">new</span> <span class="title class_">JtaTransactionAnnotationParser</span>());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (ejb3Present) {</span><br><span class="line">      <span class="built_in">this</span>.annotationParsers.add(<span class="keyword">new</span> <span class="title class_">Ejb3TransactionAnnotationParser</span>());</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span> {</span><br><span class="line">    <span class="built_in">this</span>.annotationParsers = Collections.singleton(<span class="keyword">new</span> <span class="title class_">SpringTransactionAnnotationParser</span>());</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> TransactionAttribute <span class="title function_">findTransactionAttribute</span><span class="params">(Method method)</span> {</span><br><span class="line">  <span class="keyword">return</span> determineTransactionAttribute(method);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析方法上的Transactional注解</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> TransactionAttribute <span class="title function_">determineTransactionAttribute</span><span class="params">(AnnotatedElement element)</span> {</span><br><span class="line">  <span class="keyword">for</span> (TransactionAnnotationParser parser : <span class="built_in">this</span>.annotationParsers) {</span><br><span class="line">    <span class="type">TransactionAttribute</span> <span class="variable">attr</span> <span class="operator">=</span> parser.parseTransactionAnnotation(element);</span><br><span class="line">    <span class="keyword">if</span> (attr != <span class="literal">null</span>) {</span><br><span class="line">      <span class="keyword">return</span> attr;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>所以这个类的作用大概就是解析所有方法上的Transactional注解然后封装为<code>TransactionAttributeSource</code>，最后担任<code>PointCut</code>角色</p>
<h3 id="TransactionInterceptor"><a href="#TransactionInterceptor" class="headerlink" title="TransactionInterceptor"></a>TransactionInterceptor</h3><p>执行事务的核心方法，这个方法很长很复杂没有耐心看了🥲，看了网上的博客大概是这么说的：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">invokeWithinTransaction</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass,</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> InvocationCallback invocation)</span> <span class="keyword">throws</span> Throwable {</span><br><span class="line"></span><br><span class="line">  <span class="type">TransactionAttributeSource</span> <span class="variable">tas</span> <span class="operator">=</span> getTransactionAttributeSource();</span><br><span class="line">  <span class="keyword">final</span> <span class="type">TransactionAttribute</span> <span class="variable">txAttr</span> <span class="operator">=</span> (tas != <span class="literal">null</span> ? tas.getTransactionAttribute(method, targetClass) : <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">final</span> <span class="type">PlatformTransactionManager</span> <span class="variable">tm</span> <span class="operator">=</span> determineTransactionManager(txAttr);</span><br><span class="line">  <span class="keyword">final</span> <span class="type">String</span> <span class="variable">joinpointIdentification</span> <span class="operator">=</span> methodIdentification(method, targetClass, txAttr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取事务</span></span><br><span class="line">  <span class="type">TransactionInfo</span> <span class="variable">txInfo</span> <span class="operator">=</span> createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line">  <span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    <span class="comment">//执行目标方法crud</span></span><br><span class="line">    retVal = invocation.proceedWithInvocation();</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">    <span class="comment">// crud执行异常回滚事务</span></span><br><span class="line">    completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">finally</span> {</span><br><span class="line">    cleanupTransactionInfo(txInfo);</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//提交事务</span></span><br><span class="line">  commitTransactionAfterReturning(txInfo);</span><br><span class="line">  <span class="keyword">return</span> retVal;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中调用了<code>PlatformTransactionManager</code>去执行物理事务，是负责执行增强任务的<code>Advice</code></p>
<h3 id="PlatformTransactionManager"><a href="#PlatformTransactionManager" class="headerlink" title="PlatformTransactionManager"></a>PlatformTransactionManager</h3><p>PlatformTransactionManager是Spring对于事务模型的抽象，它代表事务的整体执行过程。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PlatformTransactionManager</span> {</span><br><span class="line">    <span class="comment">// 获取事务的执行状态</span></span><br><span class="line">    TransactionStatus <span class="title function_">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">    <span class="comment">// 提交事务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">    <span class="comment">// 回滚事务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="其他的一些知识点"><a href="#其他的一些知识点" class="headerlink" title="其他的一些知识点"></a>其他的一些知识点</h2><h3 id="Spring中事务的传播行为"><a href="#Spring中事务的传播行为" class="headerlink" title="Spring中事务的传播行为"></a>Spring中事务的传播行为</h3><p>Spring中事务的传播模式有以下几种：</p>
<p><img src="/../images/Spring-%E4%BA%8B%E5%8A%A1%E4%BD%93%E7%B3%BB/%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%A8%A1%E5%BC%8F.png"></p>
<p>事务分为逻辑事务和物理事务：</p>
<ul>
<li>逻辑事务是指代码中事务的操作，即表面的业务逻辑</li>
<li>物理事务是数据库层面的操作，即从获取数据库连接到数据库执行事务完毕整个过程</li>
</ul>
<h3 id="事务失效的几种场景"><a href="#事务失效的几种场景" class="headerlink" title="事务失效的几种场景"></a>事务失效的几种场景</h3><p>这个部分是根据网上的博客总结出来的😎</p>
<ol>
<li>方法为<code>private</code>：事务代理类要求被代理方法必须是<code>public</code>的，否则不进行代理<ul>
<li>从 Spring 6.0 开始，<code>protected</code>方法可以被 CGLIB 代理</li>
</ul>
</li>
<li>方法用<code>final</code>修饰：Spring事务底层是基于AOP的，被final修饰的方法无法被代理类重写</li>
<li>方法内部调用：同理，代理类根据<code>@Transactional</code>代理方法，方法内部调用会绕过代理</li>
<li>多线程调用、异常捕获不对（默认捕获<code>RunningTimeError</code>）、未被Spring管理等等</li>
</ol>
<hr>
<p>参考：</p>
<ul>
<li><a href="https://juejin.cn/post/7106158883055353870">深入浅出Spring事务的实现原理</a></li>
<li><a href="https://juejin.cn/post/7003949263281455112?share_token=1c6f49e0-3d47-4380-af8d-de4d2b72a783">Spring事务不生效的12中场景</a></li>
<li><a href="https://juejin.cn/post/7212142580708802615?from=search-suggest">女朋友不懂Spring事务原理，今天给她讲清楚了！</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1808649">从 AbstractPointcutAdvisor 开始： Spring AOP 之 Advisor、PointcutAdvisor 介绍</a></li>
</ul>
]]></content>
      <categories>
        <category>Spring体系结构</category>
      </categories>
      <tags>
        <tag>Spring源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security架构体系</title>
    <url>/2023/09/12/Spring-Security%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p><em><strong>本文暂未完善</strong></em></p>
<p>SpringSecurity的逻辑架构主要分为两部分：认证架构和授权架构</p>
<h1 id="Servlet-认证架构"><a href="#Servlet-认证架构" class="headerlink" title="Servlet 认证架构"></a>Servlet 认证架构</h1><p>总体架构：</p>
<p><img src="/../images/Spring-Security%E6%9E%B6%E6%9E%84/image_hWPD8lsRmI.png"></p>
<p>关键组件：</p>
<p><code>AuthenticationFilter</code>：用于获取请求中的信息，并创建 <code>Authentication</code>对象</p>
<p><code>AuthenticationProvider</code>：用于验证登录逻辑，对<code>Authentication</code>进行进一步的身份认证</p>
<span id="more"></span>

<p>用户携带认证token进行请求，请求中的用户身份信息会被AuthenTicationFilter提取出来并交给<code>AuthenticationManager</code>，<code>AuthenticationManager</code>负责对用户的身份信息进行认证</p>
<p><img src="/../images/Spring-Security%E6%9E%B6%E6%9E%84/image_67F-kIkJIp.png"></p>
<h2 id="逻辑关系"><a href="#逻辑关系" class="headerlink" title="逻辑关系"></a>逻辑关系</h2><p><img src="/../images/Spring-Security%E6%9E%B6%E6%9E%84/image_BnjQG1hUFj.png"></p>
<h2 id="ProviderManager"><a href="#ProviderManager" class="headerlink" title="ProviderManager"></a>ProviderManager</h2><p>ProviderManager中包含了一系列的Provider，这些Provider负责执行实际的身份验证。例如，<code>DaoAuthenticationProvider</code>支持基于用户名/密码的身份验证，同时<code>JwtAuthenticationProvider</code>支持对 JWT 令牌进行身份验证。每个<code>AuthenticationProvider</code>执行特定类型的身份验证。</p>
<p><img src="/../images/Spring-Security%E6%9E%B6%E6%9E%84/image_3sJrWUgN3w.png"></p>
<p><img src="/../images/Spring-Security%E6%9E%B6%E6%9E%84/image_nA3iwqM0Zb.png"></p>
<h2 id="DaoAuthenticationProvider"><a href="#DaoAuthenticationProvider" class="headerlink" title="DaoAuthenticationProvider"></a>DaoAuthenticationProvider</h2><p>输入Username和Password，返回UserDetails和Authorities</p>
<p>作用：是一个<code>AuthenticationProvider</code>，用于校验账号密码</p>
<p><img src="/../images/Spring-Security%E6%9E%B6%E6%9E%84/image_KiWYyJMnjI.png"></p>
<h1 id="SecurityContextHolder"><a href="#SecurityContextHolder" class="headerlink" title="SecurityContextHolder"></a>SecurityContextHolder</h1><p>Spring Security 身份验证模型的核心是<code>SecurityContextHolder</code>，它存在于TreadLocal中</p>
<p><img src="/../images/Spring-Security%E6%9E%B6%E6%9E%84/image_2QYvifZK3U.png"></p>
<h2 id="设置SecurityContextHolder"><a href="#设置SecurityContextHolder" class="headerlink" title="设置SecurityContextHolder"></a>设置SecurityContextHolder</h2><p>不能直接通过<code>SecurityContextHolder.getContext().setAuthentication(authentication)</code>来设置Holder中的context，否则多线程情况下会出现问题。应该为每个线程创建单独的实例：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">SecurityContext</span> <span class="variable">context</span> <span class="operator">=</span> SecurityContextHolder.createEmptyContext(); </span><br><span class="line"><span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">TestingAuthenticationToken</span>(<span class="string">"username"</span>, <span class="string">"password"</span>, <span class="string">"ROLE_USER"</span>); </span><br><span class="line">context.setAuthentication(authentication);</span><br><span class="line"></span><br><span class="line">SecurityContextHolder.setContext(context); </span><br></pre></td></tr></tbody></table></figure>

<h2 id="访问当前经过身份验证的用户"><a href="#访问当前经过身份验证的用户" class="headerlink" title="访问当前经过身份验证的用户"></a>访问当前经过身份验证的用户</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">SecurityContext</span> <span class="variable">context</span> <span class="operator">=</span> SecurityContextHolder.getContext();</span><br><span class="line"><span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> context.getAuthentication();</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> authentication.getName();</span><br><span class="line"><span class="type">Object</span> <span class="variable">principal</span> <span class="operator">=</span> authentication.getPrincipal();</span><br><span class="line">Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; authorities = authentication.getAuthorities();</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>默认情况下，SecurityContextHolder使用 <code>ThreadLocal</code>来存储这些详细信息。</li>
<li>ThreadLocal如果在处理当前主体的请求后注意清除线程，Spring Security 的<code>FilterChainProxy</code>确保SecurityContext始终清除。</li>
<li>三者包含关系：SecurityContextHolder→ SecurityContext → Authentication</li>
</ul>
<p><code>Authentication</code>中包含：</p>
<ul>
<li><code>principal</code>：标识用户。当使用用户名/密码进行身份验证时，这通常是<a href="https://docs.spring.io/spring-security/reference/servlet/authentication/passwords/user-details.html#servlet-authentication-userdetails" title="UserDetails">UserDetails</a>.</li>
<li><code>credentials</code>: 通常是密码。很多情况下，这个是在用户通过认证后清除的，以保证不被泄露。</li>
<li><code>Collection&lt;? extends GrantedAuthority&gt;</code>：<a href="https://docs.spring.io/spring-security/reference/servlet/authentication/architecture.html#servlet-authentication-granted-authority" title="GrantedAuthority">GrantedAuthority</a>实例是授予用户的高级权限。</li>
</ul>
<blockquote>
<p><code>UserDetails</code>、<code>UserDetailsService</code>关系：</p>
<p>UserDetails由UserDetailsService返回。<code>DaoAuthenticationProvider</code>验证UserDetails，然后返回一个Authentication，该Authentication的主体是配置的UserDetailsService返回的UserDetails。</p>
</blockquote>
<h1 id="Security授权流程"><a href="#Security授权流程" class="headerlink" title="Security授权流程"></a>Security授权流程</h1><p><img src="/../images/Spring-Security%E6%9E%B6%E6%9E%84/image_YR7XuKyby2.png"></p>
]]></content>
      <categories>
        <category>日常小记</category>
      </categories>
      <tags>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring IoC之体系结构</title>
    <url>/2024/02/10/Spring-IoC%E4%B9%8B%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>Spring Bean 的创建是典型的工厂模式，在顶层的结构设计主要围绕着 BeanFactory 和 xxxRegistry 进行：</p>
<ul>
<li><strong>BeanFactory： 工厂模式定义了 IOC 容器的基本功能</strong></li>
<li><strong>BeanRegistry： 提供手动注册 BeanDefinition到容器中的方法</strong></li>
</ul>
<p><img src="/../images/Spring-IoC%E4%B9%8B%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image_etoRGn8l6k.png"></p>
<span id="more"></span>

<h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p><strong>BeanFactory作为最顶层的一个接口类，它定义了IOC容器的基本功能</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanFactory</span> {    </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//用于取消引用实例并将其与FactoryBean创建的bean区分开来。例如，如果命名的bean是FactoryBean，则获取将返回Factory，而不是Factory返回的实例。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">FACTORY_BEAN_PREFIX</span> <span class="operator">=</span> <span class="string">"&amp;"</span>; </span><br><span class="line">        </span><br><span class="line">    <span class="comment">//根据bean的名字和Class类型等来得到bean实例    </span></span><br><span class="line">    Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException;    </span><br><span class="line">    Object <span class="title function_">getBean</span><span class="params">(String name, Class requiredType)</span> <span class="keyword">throws</span> BeansException;    </span><br><span class="line">    Object <span class="title function_">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">    &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">    &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回指定bean的Provider</span></span><br><span class="line">    &lt;T&gt; ObjectProvider&lt;T&gt; <span class="title function_">getBeanProvider</span><span class="params">(Class&lt;T&gt; requiredType)</span>;</span><br><span class="line">    &lt;T&gt; ObjectProvider&lt;T&gt; <span class="title function_">getBeanProvider</span><span class="params">(ResolvableType requiredType)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查工厂中是否包含给定name的bean，或者外部注册的bean</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">containsBean</span><span class="params">(String name)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查所给定name的bean是否为单例/原型</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断所给name的类型与type是否匹配</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isTypeMatch</span><span class="params">(String name, Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取给定name的bean的类型</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回给定name的bean的别名</span></span><br><span class="line">    String[] getAliases(String name);</span><br><span class="line">     </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>BeanFactory 有三个子类：<code>ListableBeanFactory</code>、<code>HierarchicalBeanFactory</code> 和<code>AutowireCapableBeanFactory</code>。</p>
<ul>
<li>**<code>ListableBeanFactory</code>**：该接口定义了访问容器中 Bean 基本信息的若干方法，如查看 Bean 的个数、获取某一类型 Bean 的配置名、查看容器中是否包括某一 Bean 等方法；</li>
<li>**<code>HierarchicalBeanFactory</code>**：父子级联 IoC 容器的接口，子容器可以通过接口方法访问父容器； 通过 HierarchicalBeanFactory 接口， Spring 的 IoC 容器可以建立父子层级关联的容器体系，子容器可以访问父容器中的 Bean，但父容器不能访问子容器的 Bean。Spring 使用父子容器实现了很多功能，比如在 Spring MVC 中，展现层 Bean 位于一个子容器中，而业务层和持久层的 Bean 位于父容器中。这样，展现层 Bean 就可以引用业务层和持久层的 Bean，而业务层和持久层的 Bean 则看不到展现层的 Bean。</li>
<li>**<code>ConfigurableBeanFactory</code>**：是一个重要的接口，增强了 IoC 容器的可定制性，它定义了设置类装载器、属性编辑器、容器初始化后置处理器等方法；</li>
<li><strong><code>ConfigurableListableBeanFactory</code></strong>: ListableBeanFactory 和 ConfigurableBeanFactory 的融合；</li>
<li>**<code>AutowireCapableBeanFactory</code>**：定义了将容器中的 Bean 按某种规则（如按名字匹配、按类型匹配等）进行自动装配的方法</li>
</ul>
<h2 id="BeanRegistry"><a href="#BeanRegistry" class="headerlink" title="BeanRegistry"></a>BeanRegistry</h2><p> BeanDefinitionRegistry 接口提供了向容器手工注册 BeanDefinition 对象的方法</p>
<h2 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h2><p>Bean 对象存在依赖嵌套等关系，所以设计者设计了 BeanDefinition，它用来对 Bean 对象及关系定义；我们在理解时只需要抓住如下三个要点：</p>
<ul>
<li><code>BeanDefinition</code> 定义了各种 Bean 对象及其相互的关系</li>
<li><code>BeanDefinitionReader</code> 这是 BeanDefinition 的解析器</li>
<li><code>BeanDefinitionHolder</code> 这是 BeanDefination 的包装类，用来存储 BeanDefinition，name 以及 aliases 等。</li>
</ul>
<p><img src="/../images/Spring-IoC%E4%B9%8B%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image_bZorDDTlue.png"></p>
<h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><p>ApplicationContext是IoC容器的接口，除了继承了BeanFactory的能力，还拓展了配置资源的加载、应用事件、国际化等功能</p>
<p><img src="/../images/Spring-IoC%E4%B9%8B%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image_LT5sne3EVd.png"></p>
<ul>
<li><strong>ApplicationEventPublisher</strong>：让容器拥有发布应用上下文事件的功能，包括容器启动事件、关闭事件等。</li>
<li><strong>MessageSource</strong>：为应用提供 i18n 国际化消息访问的功能；</li>
<li><strong>ResourcePatternResolver</strong> ：资源模式解析接口，可以通过带前缀的 Ant 风格的资源文件路径装载 Spring 的配置文件。</li>
<li><strong>LifeCycle</strong>：提供了 <code>start()</code> 和 <code>stop()</code> 两个方法，主要用于控制异步处理过程。在具体使用时，该接口同时被 ApplicationContext 实现及具体 Bean 实现， ApplicationContext 会将 start/stop 的信息传递给容器中所有实现了该接口的 Bean，以达到管理和控制 JMX、任务调度等目的。</li>
</ul>
<h3 id="ApplicationContext体系"><a href="#ApplicationContext体系" class="headerlink" title="ApplicationContext体系"></a>ApplicationContext体系</h3><p><img src="/../images/Spring-IoC%E4%B9%8B%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image_-3W-afYUAj.png"></p>
<blockquote>
<p>为什么设计这么多ApplicationContext？</p>
<p><strong>第一，从类结构设计上看， 围绕着是否需要 Refresh 容器衍生出两个抽象类</strong>：</p>
<ul>
<li><code>GenericApplicationContext</code>： 是初始化的时候就创建容器，往后的每次 refresh 都不会更改</li>
<li><code>AbstractRefreshableApplicationContext</code>： <code>AbstractRefreshableApplicationContext</code> 及子类的每次 refresh 都是先清除已有 (如果不存在就创建) 的容器，然后再重新创建，因此无法做到像 <code>GenericApplicationContext</code> <strong>混合搭配从不同源头获取 bean 的定义信息</strong></li>
</ul>
<p><strong>第二， 从加载的源来看（比如 xml,groovy,annotation 等）， 衍生出众多类型的 ApplicationContext, 典型比如</strong>:</p>
<ul>
<li><code>FileSystemXmlApplicationContext</code>： 从文件系统下的一个或多个 xml 配置文件中加载上下文定义，也就是说系统盘符中加载 xml 配置文件。</li>
<li><code>ClassPathXmlApplicationContext</code>： 从类路径下的一个或多个 xml 配置文件中加载上下文定义，适用于 xml 配置的方式。</li>
<li><code>AnnotationConfigApplicationContext</code>： 从一个或多个基于 java 的配置类中加载上下文定义，适用于 java 注解的方式。</li>
<li><code>ConfigurableApplicationContext</code>： 扩展于 ApplicationContext，它新增加了两个主要的方法： <code>refresh()</code> 和 <code>close()</code>，让 ApplicationContext 具有启动、刷新和关闭应用上下文的能力。在应用上下文关闭的情况下调用 <code>refresh()</code> 即可启动应用上下文，在已经启动的状态下，调用 <code>refresh()</code> 则清除缓存并重新装载配置信息，而调用 <code>close()</code> 则可关闭应用上下文。</li>
</ul>
<p><strong>第三， 更进一步理解</strong>：</p>
<p>***设计者在设计时 <code>AnnotationConfigApplicationContext</code> 为什么是继承 <code>GenericApplicationContext</code>***？ 因为基于注解的配置，是不太会被运行时修改的，这意味着不需要进行动态 Bean 配置和刷新容器，所以只需要 <code>GenericApplicationContext</code>。</p>
<p>而基于 XML 这种配置文件，这种文件是容易修改的，需要动态性刷新 Bean 的支持，所以 XML 相关的配置必然继承 <code>AbstractRefreshableApplicationContext</code>； 且存在多种 xml 的加载方式（位置不同的设计），所以必然会设计出 <code>AbstractXmlApplicationContext</code>, 其中包含对 XML 配置解析成 BeanDefination 的过程。</p>
<p>那么细心的你从上图可以***发现 <code>AnnotationWebConfigApplicationContext</code> 却是继承了 <code>AbstractRefreshableApplicationContext</code> 而不是 <code>GenericApplicationContext</code>***？ 因为用户可以通过 ApplicationContextInitializer 来设置 contextInitializerClasses（context-param / init-param）， 在这种情况下用户倾向于刷新 Bean 的，所以设计者选择让 <code>AnnotationWebConfigApplicationContext</code> 继承了 <code>AbstractRefreshableApplicationContext</code>。</p>
</blockquote>
<p>这一段解释封神，我直接复制粘贴😆</p>
<p>参考：</p>
<ul>
<li><a href="https://pdai.tech/md/spring/spring-x-framework-ioc-source-1.html" title="https://pdai.tech/md/spring/spring-x-framework-ioc-source-1.html">https://pdai.tech/md/spring/spring-x-framework-ioc-source-1.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Spring源码系列</category>
      </categories>
      <tags>
        <tag>IoC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot实现GitHub第三方登录</title>
    <url>/2023/05/14/SpringBoot%E5%AE%9E%E7%8E%B0GitHub%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<h2 id="Github登录原理"><a href="#Github登录原理" class="headerlink" title="Github登录原理"></a>Github登录原理</h2><p>Github登录的原理是借助OAuth 2.0协议来实现，具体的流程是：首先用户被重定向到GitHub的授权页面，证明自己的身份并同意授权后获取一个授权码，然后客户端拿着授权码请求授权服务器获得一个Access Token</p>
<p>之后客户端就可以通过Access Token来与资源服务器进行交互，这个token是长期有效的，也可以服务端自行留存。服务端拿着这个token就可以请求GitHub并获得用户信息</p>
<p><img src="/../images/SpringBoot%E5%AE%9E%E7%8E%B0GitHub%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/image_u3kxu-6By6.png"></p>
<p>我们常见的单点登录平台，如Casdoor、logto等等，他们会在保存授权后获得的Access Token，并作为授权服务器提供服务。利用这些平台我们能更方便的管理账号系统，不用再去对不同的第三方平台做不同的授权实</p>
<span id="more"></span>

<p><img src="/../images/SpringBoot%E5%AE%9E%E7%8E%B0GitHub%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/2760332-20220412195835959-694117279_q0bggeLtdi.gif"></p>
<h1 id="SpringBoot实现GitHub登录"><a href="#SpringBoot实现GitHub登录" class="headerlink" title="SpringBoot实现GitHub登录"></a>SpringBoot实现GitHub登录</h1><p>首先，你需要在GitHub上创建一个<a href="https://github.com/settings/applications/new" title="Application">Application</a>，将我们的应用注册到GitHub</p>
<p><img src="/../images/SpringBoot%E5%AE%9E%E7%8E%B0GitHub%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/image_FUKgEjhTXM.png"></p>
<p>注意这个回调地址，它是用户授权后GitHub重定向用户的地址</p>
<p>注册完成后，将<code>client_id</code>和<code>client_secret</code>配置到SpringBoot应用中：</p>
<p><img src="/../images/SpringBoot%E5%AE%9E%E7%8E%B0GitHub%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/image_qoOfOfER8X.png"></p>
<p>下面是Demo：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(path = "oauth")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OAuthController</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value("${github.client.id}")</span></span><br><span class="line">    <span class="keyword">private</span> String clientId;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Value("${github.client.secret}")</span></span><br><span class="line">    <span class="keyword">private</span> String clientSecret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跳转到授权页面</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(path = "github")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">auth</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="type">String</span> <span class="variable">authorizeUri</span> <span class="operator">=</span> <span class="string">"https://github.com/login/oauth/authorize"</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">redirectUri</span> <span class="operator">=</span> <span class="string">"http://localhost:8080/oauth/redirect"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> authorizeUri </span><br><span class="line">                + <span class="string">"?client_id="</span> + githubClientProperties.getClientId()</span><br><span class="line">                + <span class="string">"&amp;redirect_uri="</span> + redirectUri;</span><br><span class="line">        response.sendRedirect(url);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Github回调接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestToken 授权码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(path = "redirect")</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleRedirect</span><span class="params">(<span class="meta">@RequestParam("code")</span> String requestToken, HttpServletResponse response)</span> {</span><br><span class="line">        <span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取Token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">tokenUrl</span> <span class="operator">=</span> <span class="string">"https://github.com/login/oauth/access_token"</span></span><br><span class="line">                + <span class="string">"?client_id="</span> + githubClientProperties.getClientId()</span><br><span class="line">                + <span class="string">"&amp;client_secret="</span> + githubClientProperties.getClientSecret()</span><br><span class="line">                + <span class="string">"&amp;code="</span> + requestToken;</span><br><span class="line"></span><br><span class="line">        <span class="type">AccessTokenResponse</span> <span class="variable">tokenResponse</span> <span class="operator">=</span> restTemplate.postForObject(tokenUrl, <span class="literal">null</span>, AccessTokenResponse.class);</span><br><span class="line">        <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> tokenResponse.getAccessToken();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取用户信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">apiUrl</span> <span class="operator">=</span> <span class="string">"https://api.github.com/user"</span>;</span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">        headers.set(<span class="string">"Authorization"</span>, <span class="string">"Bearer "</span> + accessToken);</span><br><span class="line">        HttpEntity&lt;String&gt; entity = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;&gt;(<span class="string">"parameters"</span>, headers);</span><br><span class="line">        ResponseEntity&lt;String&gt; resp = restTemplate.exchange(apiUrl, HttpMethod.GET, entity, String.class);</span><br><span class="line">        <span class="type">String</span> <span class="variable">userData</span> <span class="operator">=</span> resp.getBody();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将token返回给客户端</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">githubToken</span> <span class="operator">=</span> newCookie(<span class="string">"github_token"</span>, accessToken, <span class="string">"/"</span>, COOKIE_AGE);</span><br><span class="line">        response.addCookie(githubToken);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ResVo.ok(userData);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Cookie <span class="title function_">newCookie</span><span class="params">(String key, String session, String path, <span class="type">int</span> maxAge)</span> {</span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(key, session);</span><br><span class="line">        cookie.setPath(path);</span><br><span class="line">        cookie.setMaxAge(maxAge);</span><br><span class="line">        <span class="keyword">return</span> cookie;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<p>相关文档：</p>
<ul>
<li><a href="https://docs.github.com/zh/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps#web-application-flow" title="https://docs.github.com/zh/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps#web-application-flow">https://docs.github.com/zh/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps#web-application-flow</a></li>
<li><a href="https://casdoor.org/docs/overview" title="https://casdoor.org/docs/overview">https://casdoor.org/docs/overview</a></li>
</ul>
]]></content>
      <categories>
        <category>技术方案</category>
      </categories>
      <tags>
        <tag>oauth</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Environment体系</title>
    <url>/2024/06/21/Spring%20Environment%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><ul>
<li><code>PropertySource</code>：管理各种配置源的抽象类，即属性源</li>
<li><code>PropertySources</code>：用于统一管理和访问多个 PropertySource 实例</li>
<li><code>PropertyResolver</code>：通用属性解析<ul>
<li><code>Environment</code>：应用环境表示，提供属性访问，支持profile。</li>
<li><code>ConfigurablePropertyResolver</code>：属性解析配置，支持占位符解析。</li>
</ul>
</li>
<li><code>Binder</code>：配置绑定工具</li>
</ul>
<p>大致关系图：</p>
<p><img src="/../images/Spring-Environment%E4%BD%93%E7%B3%BB/image_98WWM6BQwA.png"></p>
<span id="more"></span>

<blockquote>
<p>图片来自<a href="https://www.apolloconfig.com/#/zh/design/apollo-design?id=_31-%E5%92%8Cspring%E9%9B%86%E6%88%90%E7%9A%84%E5%8E%9F%E7%90%86" title="https://www.apolloconfig.com/#/zh/design/apollo-design?id=_31-和spring集成的原理">https://www.apolloconfig.com/#/zh/design/apollo-design?id=_31-和spring集成的原理</a></p>
</blockquote>
<h2 id="PropertySource"><a href="#PropertySource" class="headerlink" title="PropertySource"></a>PropertySource</h2><p><img src="/../images/Spring-Environment%E4%BD%93%E7%B3%BB/image_eZgD5dC_Ym.png"></p>
<p>PropertySource是 Spring 框架中的一个关键抽象类，封装了一个属性源，属性源可以是一个<code>Map</code>、<code>Resource</code>对象、系统变量等等</p>
<h2 id="PropertySources"><a href="#PropertySources" class="headerlink" title="PropertySources"></a>PropertySources</h2><p><code>PropertySources</code> 是一个Spring框架中的接口，用于表示和管理一组属性源（<code>PropertySource</code>），这些属性源包含了应用程序环境中的配置数据。该接口提供了一系列方法来检索、添加、替换和删除这些属性源，允许开发者以统一的方式访问不同来源的配置信息，如环境变量、系统属性、配置文件等。</p>
<h2 id="PropertyResolver"><a href="#PropertyResolver" class="headerlink" title="PropertyResolver"></a>PropertyResolver</h2><p><code>PropertyResolver</code>是一个顶层接口，提供了一套灵活且强大的机制来处理应用程序配置属性。它定义了一些获取属性值，以及解析占位符的方法，用于访问和操纵来自各种源的属性值。</p>
<p><img src="/../images/Spring-Environment%E4%BD%93%E7%B3%BB/image_TL0vgbMjbo.png"></p>
<h3 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h3><p><code>Environment</code> 接口是 Spring 框架中的一个核心部分，它提供了一个统一的方式来访问各种外部化的配置数据（继承自<code>PropertyResolver</code>）；支持配置文件（Profiles）的概念，可以在不同环境下进行条件性的配置，管理多个属性源。</p>
<p>可以看到<code>Environment</code>是继承了<code>PropertyResolver</code>接口的，<strong>只是增加了一些环境信息方法(profile)</strong></p>
<p>其中<code>Environment</code>实例关于<code>PropertyResolver</code>接口的方法是通过组合模式实现的，内部持有一个<code>PropertySourcesPropertyResolver</code>实例。</p>
<h3 id="ConfigurablePropertyResolver"><a href="#ConfigurablePropertyResolver" class="headerlink" title="ConfigurablePropertyResolver"></a>ConfigurablePropertyResolver</h3><p><code>ConfigurablePropertyResolver</code> 接口则增加了一些配置方法，在Spring中关键作用是提供灵活的配置属性解析。它支持<strong>占位符解析</strong>，并解析这些占位符为实际的配置值，提升配置的动态性和灵活性。</p>
<h3 id="其他实现"><a href="#其他实现" class="headerlink" title="其他实现"></a>其他实现</h3><ul>
<li><code>ConfigurableEnvironment</code>，增加了一些配置的方法，以及可以获取到内部的<code>PropertySource</code>列表。</li>
<li><code>StandardEnvironment</code>，非web上下文使用的环境实例。</li>
<li><code>StandardServletEnvironment</code>，web上下文使用的环境实例。</li>
</ul>
<h2 id="属性绑定"><a href="#属性绑定" class="headerlink" title="属性绑定"></a>属性绑定</h2><h3 id="ConfigurationPropertySource"><a href="#ConfigurationPropertySource" class="headerlink" title="ConfigurationPropertySource"></a>ConfigurationPropertySource</h3><p>这是一个新的接口，不过它的实现类也是借助了<code>PropertySource</code>来实现，尽管他们之间没有任何继承关系。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConfigurationPropertySource</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据属性名获取对应的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ConfigurationProperty <span class="title function_">getConfigurationProperty</span><span class="params">(ConfigurationPropertyName name)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否包含后代属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> ConfigurationPropertyState <span class="title function_">containsDescendantOf</span><span class="params">(ConfigurationPropertyName name)</span> {</span><br><span class="line">        <span class="keyword">return</span> ConfigurationPropertyState.UNKNOWN;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册别名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> ConfigurationPropertySource <span class="title function_">withAliases</span><span class="params">(ConfigurationPropertyNameAliases aliases)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AliasedConfigurationPropertySource</span>(<span class="built_in">this</span>, aliases);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>ConfigurationPropertySources</code>提供了从environment中获取属性源构建ConfigurationPropertySource的方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Iterable&lt;ConfigurationPropertySource&gt; sources = ConfigurationPropertySources.get(environment);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h3><p>Spring提供了一个很强大的工具类<code>Binder</code>，依赖<code>ConfigurationPropertySource</code></p>
<p>作用：<em><strong>可以将<code>Environment</code>或者<code>ConfigurationPropertySource</code>中的属性绑定到一个Java对象中</strong></em>，且支持占位符，类型转换，宽松绑定。</p>
<p>他有两个重要方法：<code>bind()</code>和<code>bindOrCreate()</code>，两个方法有多重重载方式，这里列举了两种</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Binder</span> {</span><br><span class="line">  <span class="comment">// Binder 维护的属性源，在构造Binder时指定</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Iterable&lt;ConfigurationPropertySource&gt; sources;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将PropertySources绑定到指定的Bindable</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; BindResult&lt;T&gt; <span class="title function_">bind</span><span class="params">(ConfigurationPropertyName name, Bindable&lt;T&gt; target, BindHandler handler)</span> {</span><br><span class="line">    <span class="type">T</span> <span class="variable">bound</span> <span class="operator">=</span> bind(name, target, handler, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> BindResult.of(bound);</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将PropertySources绑定到指定的Bindable，或者如果绑定的结果是null，则使用Bindable的类型创建新实例</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">bindOrCreate</span><span class="params">(ConfigurationPropertyName name, Bindable&lt;T&gt; target, BindHandler handler)</span> {</span><br><span class="line">    <span class="keyword">return</span> bind(name, target, handler, <span class="literal">true</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><code>Binder</code>类还提供一个静态方法<code>get()</code>来构造<code>Binder</code>实例，可以从<code>Environment</code>实例获取<code>PropertySources</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Binder <span class="title function_">get</span><span class="params">(Environment environment)</span> {  </span><br><span class="line">    <span class="keyword">return</span> get(environment, <span class="literal">null</span>);  </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Binder <span class="title function_">get</span><span class="params">(Environment environment, BindHandler defaultBindHandler)</span> {</span><br><span class="line">    Iterable&lt;ConfigurationPropertySource&gt; sources = ConfigurationPropertySources.get(environment);</span><br><span class="line">    <span class="type">PropertySourcesPlaceholdersResolver</span> <span class="variable">placeholdersResolver</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">PropertySourcesPlaceholdersResolver</span>(environment);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Binder</span>(sources, placeholdersResolver, <span class="literal">null</span>, <span class="literal">null</span>, defaultBindHandler);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>我们项目中常用于配置注入的<code>@ConfigurationProperties</code>，实现原理也是通过Binder</p>
<h3 id="ConfigurationProperties实现原理"><a href="#ConfigurationProperties实现原理" class="headerlink" title="@ConfigurationProperties实现原理"></a>@ConfigurationProperties实现原理</h3><p><code>@ConfigurationProperties</code>注解在Spring Boot中常用来绑定属性到Java Bean中，不难猜出内部原理便是使用上面所介绍的<code>Binder</code>类来实现的。</p>
<p>使用该注解时常常搭配<code>@EnableConfigurationProperties</code>注解一起使用，<code>@EnableConfigurationProperties</code>的主要作用就是注册了一个<code>ConfigurationPropertiesBindingPostProcessor</code>Bean</p>
<p>绑定的核心逻辑在<code>ConfigurationPropertiesBindingPostProcessor</code>中</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException {</span><br><span class="line">  <span class="keyword">if</span> (!hasBoundValueObject(beanName)) {</span><br><span class="line">    bind(ConfigurationPropertiesBean.get(<span class="built_in">this</span>.applicationContext, bean, beanName));</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> bean;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(ConfigurationPropertiesBean bean)</span> {</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    <span class="built_in">this</span>.binder.bind(bean);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConfigurationPropertiesBindException</span>(bean, ex);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">BindResult&lt;?&gt; bind(ConfigurationPropertiesBean propertiesBean) {</span><br><span class="line">  Bindable&lt;?&gt; target = propertiesBean.asBindTarget();</span><br><span class="line">  <span class="type">ConfigurationProperties</span> <span class="variable">annotation</span> <span class="operator">=</span> propertiesBean.getAnnotation();</span><br><span class="line">  <span class="type">BindHandler</span> <span class="variable">bindHandler</span> <span class="operator">=</span> getBindHandler(target, annotation);</span><br><span class="line">  <span class="comment">// 绑定ConfigurationPropertySource中的属性源和ConfigurationPropertiesBean对象</span></span><br><span class="line">  <span class="keyword">return</span> getBinder().bind(annotation.prefix(), target, bindHandler);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Binder <span class="title function_">getBinder</span><span class="params">()</span> {</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.binder == <span class="literal">null</span>) {</span><br><span class="line">    <span class="built_in">this</span>.binder = <span class="keyword">new</span> <span class="title class_">Binder</span>(getConfigurationPropertySources(), getPropertySourcesPlaceholdersResolver(),</span><br><span class="line">        getConversionServices(), getPropertyEditorInitializer(), <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.binder;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从注入的属性源构建ConfigurationPropertySource</span></span><br><span class="line"><span class="keyword">private</span> Iterable&lt;ConfigurationPropertySource&gt; <span class="title function_">getConfigurationPropertySources</span><span class="params">()</span> {</span><br><span class="line">  <span class="keyword">return</span> ConfigurationPropertySources.from(<span class="built_in">this</span>.propertySources);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 从注入的属性源构建PropertySourcesResolver, 支持解析占位符</span></span><br><span class="line"><span class="keyword">private</span> PropertySourcesPlaceholdersResolver <span class="title function_">getPropertySourcesPlaceholdersResolver</span><span class="params">()</span> {</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PropertySourcesPlaceholdersResolver</span>(<span class="built_in">this</span>.propertySources);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 类型转换</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ConversionService&gt; <span class="title function_">getConversionServices</span><span class="params">()</span> {</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConversionServiceDeducer</span>(<span class="built_in">this</span>.applicationContext).getConversionServices();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Consumer&lt;PropertyEditorRegistry&gt; <span class="title function_">getPropertyEditorInitializer</span><span class="params">()</span> {</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.applicationContext <span class="keyword">instanceof</span> ConfigurableApplicationContext configurableContext) {</span><br><span class="line">    <span class="keyword">return</span> configurableContext.getBeanFactory()::copyRegisteredEditorsTo;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>关键点在于使用Binder将<code>ConfigurationPropertySource</code>中的属性源和实际的<code>ConfigurationPropertiesBean</code>对象绑定在了一起，实现配置的注入。注意<code>ConfigurationPropertySource</code>中的属性源是带有<code>prefix</code>的</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrefixedConfigurationPropertySource</span> <span class="keyword">implements</span> <span class="title class_">ConfigurationPropertySource</span> {</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ConfigurationPropertySource source;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ConfigurationPropertyName prefix;</span><br><span class="line"></span><br><span class="line">  PrefixedConfigurationPropertySource(ConfigurationPropertySource source, String prefix) {</span><br><span class="line">    Assert.notNull(source, <span class="string">"Source must not be null"</span>);</span><br><span class="line">    Assert.hasText(prefix, <span class="string">"Prefix must not be empty"</span>);</span><br><span class="line">    <span class="built_in">this</span>.source = source;</span><br><span class="line">    <span class="built_in">this</span>.prefix = ConfigurationPropertyName.of(prefix);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<p>参考：</p>
<ul>
<li><a href="https://www.cnblogs.com/wt20/p/17588895.html" title="https://www.cnblogs.com/wt20/p/17588895.html">https://www.cnblogs.com/wt20/p/17588895.html</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2023/06/18/230618-SpringBoot%E4%B9%8B%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%B1%9E%E6%80%A7%E7%BB%91%E5%AE%9ABinder/" title="https://spring.hhui.top/spring-blog/2023/06/18/230618-SpringBoot之编程式属性绑定Binder/">https://spring.hhui.top/spring-blog/2023/06/18/230618-SpringBoot之编程式属性绑定Binder/</a></li>
</ul>
]]></content>
      <categories>
        <category>Spring体系结构</category>
      </categories>
      <tags>
        <tag>Spring源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>✍🏻 Spring源码阅读记录</title>
    <url>/2024/03/31/Spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<blockquote>
<p>标记的表示已读</p>
</blockquote>
<h1 id="Spring-Core"><a href="#Spring-Core" class="headerlink" title="Spring Core"></a>Spring Core</h1><h2 id="资源加载与访问"><a href="#资源加载与访问" class="headerlink" title="资源加载与访问"></a>资源加载与访问</h2><ul>
<li>Resource：抽象接口，表示文件、类路径等，用于访问不同来源的资源。</li>
<li>ResourceLoader：资源获取核心接口，实现统一加载不同位置资源的策略。</li>
<li>ResourcePatternResolver：资源模式解析接口，用于灵活加载应用中的多种资源。</li>
<li>DocumentLoader：XML文档加载解析核心接口，支持后台自动配置Spring应用。</li>
</ul>
<span id="more"></span>

<h2 id="元数据与过滤"><a href="#元数据与过滤" class="headerlink" title="元数据与过滤"></a>元数据与过滤</h2><ul>
<li>MetadataReader：类元数据获取核心，支持组件扫描、条件化注解、AOP等高级功能。</li>
<li>AnnotationMetadata：动态获取和操作运行时类注解信息。</li>
<li>TypeFilter：组件扫描时自定义类筛选，支持复杂条件和精确过滤。</li>
<li>Condition：条件判断，决定Bean创建和配置的灵活机制。</li>
</ul>
<h2 id="验证、数据绑定和类型转换"><a href="#验证、数据绑定和类型转换" class="headerlink" title="验证、数据绑定和类型转换"></a>验证、数据绑定和类型转换</h2><ul>
<li>Validator：提供自定义数据验证逻辑，确保模型对象满足业务规则。</li>
<li>PropertyEditor：自定义JavaBean属性的转换逻辑，处理属性类型转换。</li>
<li>Converter：用于不同类型间的转换，定义简单的源至目标类型转换规则。</li>
<li>ConverterFactory：创建针对特定源类型的转换器，用于类型转换。</li>
<li>GenericConverter：更复杂的转换器，支持多种源和目标类型转换。</li>
<li>ConditionalConverter：根据条件选择是否执行转换的转换器。</li>
<li>ConversionService：提供统一的类型转换服务接口，管理转换器。</li>
<li>Printer：用于将对象格式化为文本，专注于格式化输出。</li>
<li>Parser：用于将文本解析为对象，专注于解析逻辑。</li>
</ul>
<h2 id="Spring-表达式语言（SpEL）"><a href="#Spring-表达式语言（SpEL）" class="headerlink" title="Spring 表达式语言（SpEL）"></a>Spring 表达式语言（SpEL）</h2><ul>
<li>ExpressionParser: 解析字符串形式的 SpEL 表达式，创建并返回 Expression 实例。</li>
<li>Expression: 对表达式字符串进行求值的功能，支持类型转换、获取原始字符串等操作。</li>
<li>EvaluationContext: 管理SpEL表达式的上下文信息。</li>
<li>PropertyAccessor: 用于读取和写入对象的属性，可用于实现自定义的属性访问逻辑。</li>
<li>ConstructorResolver: 解析构造函数确定bean的实例化方式。</li>
<li>MethodResolver: 解析类方法，确保正确调用，处理重载和参数匹配。</li>
<li>BeanResolver: 解析bean定义，包括依赖、属性设置，实例化并返回。</li>
<li>TypeLocator: 动态查找类，返回Class对象，在表达式解析、类型转换等。</li>
<li>TypeConverter: 类型转换功能，将表达式中的数据从一种类型转换为另一种类型。</li>
<li>TypeComparator: 类型比较功能，定义了比较两个对象是否相等的方法。</li>
<li>OperatorOverloader: 运算符重载功能，对表达式中的运算符进行自定义操作的方法。</li>
</ul>
<h2 id="Bean定义与注册"><a href="#Bean定义与注册" class="headerlink" title="Bean定义与注册"></a>Bean定义与注册</h2><ul>
<li><u>BeanDefinition</u>：详细描述Bean，支持依赖注入、AOP、作用域控制等核心功能。</li>
<li><u>BeanDefinitionHolder</u>：管理和操作BeanDefinition的关键类。</li>
<li><u>BeanDefinitionRegistry</u>：Bean定义注册管理关键接口，处理Bean元数据。</li>
</ul>
<h2 id="Bean定义读取与扫描"><a href="#Bean定义读取与扫描" class="headerlink" title="Bean定义读取与扫描"></a>Bean定义读取与扫描</h2><ul>
<li>XmlBeanDefinitionReader：加载解析XML配置，构建IOC容器，注册Bean定义。</li>
<li>PropertiesBeanDefinitionReader：属性文件加载，解析为Bean定义。</li>
<li>GroovyBeanDefinitionReader：Groovy脚本解析为Bean定义。</li>
<li>AnnotatedBeanDefinitionReader：注解配置，自动扫描注册Spring组件，简化Bean定义配置。</li>
<li><u>ClassPathBeanDefinitionScanner</u>：类路径扫描注册Spring Bean，支持自动装配。</li>
</ul>
<h2 id="Bean工厂"><a href="#Bean工厂" class="headerlink" title="Bean工厂"></a>Bean工厂</h2><ul>
<li><u>BeanFactory</u>：Spring的核心接口，提供对Bean的配置、创建、管理的基本功能。</li>
<li>ListableBeanFactory：支持按类型获取Bean的集合。</li>
<li>HierarchicalBeanFactory：支持父子容器关系，实现Bean定义的层次结构。</li>
<li>ConfigurableBeanFactory：提供对BeanFactory配置的扩展，如属性编辑器、作用域等。</li>
<li>AutowireCapableBeanFactory：Bean创建、初始化、注入、销毁的核心功能接口。</li>
<li><u>ConfigurableListableBeanFactory</u>：支持配置和列表操作的可配置Bean工厂接口。</li>
</ul>
<h2 id="容器上下文"><a href="#容器上下文" class="headerlink" title="容器上下文"></a>容器上下文</h2><ul>
<li><u>ClassPathXmlApplicationContext</u>：类路径（classpath）加载 XML 配置文件的上下文。</li>
<li><u>AnnotationConfigApplicationContext</u>：注解配置类中加载配置信息的上下文。</li>
<li><u>GenericApplicationContext</u>：支持多种配置方式，XML、注解、手动注册的上下文。</li>
</ul>
<h2 id="Bean定义导入与组合"><a href="#Bean定义导入与组合" class="headerlink" title="Bean定义导入与组合"></a>Bean定义导入与组合</h2><ul>
<li><u>ImportBeanDefinitionRegistrar</u>：运行时动态注册 Bean，实现灵活配置，扩展配置类功能。</li>
<li><u>ImportSelector</u>：运行时动态导入配置类，实现条件选择和灵活配置。</li>
<li>DeferredImportSelector：运行时动态导入配置，支持条件选择和按组别延迟加载。</li>
</ul>
<h2 id="Bean生命周期"><a href="#Bean生命周期" class="headerlink" title="Bean生命周期"></a>Bean生命周期</h2><ul>
<li><u>Bean的定义注册过程</u>：加载与解析配置文件，注册解析Bean定义，类名、作用域、属性等。</li>
<li><u>Bean的初始化过程</u>：实例化、属性注入、Aware回调、后置处理器、初始化方法调用。</li>
<li><u>Bean的依赖解析过程</u>：声明依赖，查找依赖，注入依赖，处理循环依赖，延迟依赖解析。</li>
<li><u>Bean的销毁过程</u>：销毁方法调用，接口回调，后处理清理，通知触发，GC回收资源。</li>
</ul>
<h2 id="属性解析和环境配置"><a href="#属性解析和环境配置" class="headerlink" title="属性解析和环境配置"></a>属性解析和环境配置</h2><ul>
<li><u>PropertySource</u>：管理各种配置源的抽象类，支持灵活地加载和访问应用配置。</li>
<li><u>PropertySources</u>：用于统一管理和访问多个 PropertySource 实例，简化配置数据的处理。</li>
<li><u>PropertyResolver</u>：通用属性解析，获取配置值，处理属性缺失，简便灵活。</li>
<li><u>ConfigurablePropertyResolver</u>：属性解析配置，占位符设置，适应不同配置需求。</li>
<li><u>Environment</u>：应用环境表示，提供属性访问，支持配置文件，实现动态配置。</li>
<li><u>ConfigurableEnvironment</u>：动态配置应用环境，激活、默认配置，提升应用灵活性。</li>
</ul>
<h2 id="Bean初始化与扩展点"><a href="#Bean初始化与扩展点" class="headerlink" title="Bean初始化与扩展点"></a>Bean初始化与扩展点</h2><ul>
<li><u>InitializingBean</u>：提供Bean初始化时执行自定义逻辑的接口。</li>
<li>DisposableBean：定义Bean销毁前执行清理操作的接口。</li>
<li><u>BeanDefinitionRegistryPostProcessor</u>：在容器启动时，对BeanDefinition动态修改或添加。</li>
<li><u>BeanFactoryPostProcessor</u>：在Bean实例化前，对BeanFactory进行全局修改或配置。</li>
<li><u>BeanPostProcessor</u>：在Bean初始化前后，进行自定义处理，可影响所有Bean。</li>
<li>InstantiationAwareBeanPostProcessor：提供更深层次的实例化和属性注入控制。</li>
<li>DestructionAwareBeanPostProcessor： 允许在Bean销毁前进行额外的清理操作。</li>
<li>MergedBeanDefinitionPostProcessor：在合并Bean定义时对BeanDefinition进行处理。</li>
<li>SmartInstantiationAwareBeanPostProcessor：提供更智能的实例化控制。</li>
<li>SmartInitializingSingleton：在所有单例Bean初始化完成后，执行自定义逻辑。</li>
</ul>
<h2 id="Aware接口系列"><a href="#Aware接口系列" class="headerlink" title="Aware接口系列"></a>Aware接口系列</h2><ul>
<li>BeanNameAware：让Bean获取自身在容器中的名字。</li>
<li>BeanClassLoaderAware：允许Bean获取其类加载器。</li>
<li>BeanFactoryAware：提供Bean获取所属的BeanFactory。</li>
<li><u>EnvironmentAware</u>：允许Bean获取应用程序环境配置。</li>
<li>EmbeddedValueResolverAware：允许Bean解析嵌入式值占位符。</li>
<li>ResourceLoaderAware：允许Bean获取资源加载器。</li>
<li>ApplicationEventPublisherAware：允许Bean发布应用程序事件。</li>
<li>MessageSourceAware：允许Bean获取消息源。</li>
<li><u>ApplicationContextAware</u>：允许Bean获取应用程序上下文。</li>
<li>ImportAware：允许被导入的配置类获取导入它的类的信息。</li>
</ul>
<h2 id="核心注解"><a href="#核心注解" class="headerlink" title="核心注解"></a>核心注解</h2><ul>
<li><u>@Configuration</u>：声明类为配置类，定义Bean和Bean之间的依赖关系。</li>
<li><u>@ComponentScan</u>：启用组件扫描，自动发现并注册标记为组件的类。</li>
<li><u>@Bean</u>：在配置类中声明方法，返回Bean实例。</li>
<li><u>@Import</u>：引入其他配置类，将其Bean定义合并到当前容器。</li>
<li>@PropertySource：指定属性文件，加载外部配置到环境中。</li>
<li>@DependsOn：指定Bean的依赖顺序，确保特定Bean在其他Bean之前初始化。</li>
<li><u>@Conditional</u>：根据条件决定是否创建Bean。</li>
<li>@Lazy：指定Bean的延迟初始化，只有在首次使用时才创建。</li>
<li>@Value：注入简单值或表达式到Bean的字段或方法参数。</li>
<li><u>@Autowired</u>：自动装配Bean依赖。</li>
<li>@Primary：指定在多个候选Bean中优先选择的首选Bean。</li>
<li>@Role：为Bean提供角色提示，用于区分相似类型的Bean。</li>
<li>@Indexed： 标记Bean用于索引。</li>
<li>@Order：指定Bean的加载顺序。</li>
</ul>
<h2 id="JSR规范"><a href="#JSR规范" class="headerlink" title="JSR规范"></a>JSR规范</h2><ul>
<li>@Inject：JSR-330标准的依赖注入注解。</li>
<li>@Named：JSR-330标准的命名注解。</li>
<li>@Resource：Java EE标准的资源注入注解。</li>
<li>@Qualifier：用于限定注入的Bean。</li>
<li>@Scope：指定Bean的作用域。</li>
<li>@Singleton：指定Bean为单例。</li>
<li>@PostConstruct：指定初始化方法。</li>
<li>@PreDestroy：指定销毁方法。</li>
<li>Provider：Java标准库提供的通用Bean工厂接口。</li>
</ul>
<h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><ul>
<li>JDK动态代理：接口实现，动态生成代理类，处理方法调用，统一横切关注点。</li>
<li>Cglib动态代理：基于字节码生成的库，无需接口，可拦截类方法并进行增强。</li>
<li>ClassFilter：确定类是否匹配拦截条件。</li>
<li>MethodMatcher：确定方法是否匹配拦截条件。</li>
<li>Pointcut：定义切入点，匹配被拦截的方法。</li>
<li>Advice：AOP中定义各种通知类型行为的核心接口。</li>
<li>MethodInterceptor：拦截方法执行，允许在前后添加额外逻辑。</li>
<li>MethodBeforeAdvice：允许在方法调用之前插入自定义逻辑。</li>
<li>AfterReturningAdvice：允许在方法调用之后插入自定义逻辑。&lt;</li>
<li>ThrowsAdvice：异常通知，捕获方法抛出的异常，执行额外逻辑。</li>
<li>IntroductionInterceptor：动态地向目标对象引入新的功能或属性。</li>
<li>Advisor：用于将通知和切点结合，实现切面编程的横切关注点。</li>
<li>Advised：配置AOP代理的通知、通知器、目标等。</li>
<li>ProxyFactory：一种便捷的方式来创建代理对象。</li>
<li>AopProxyFactory：创建AOP代理工厂，支持JDK和CGLIB。</li>
<li>AopProxy：创建和管理AOP代理对象。</li>
<li>AdvisorChainFactory：创建Advisor链的工厂接口。</li>
<li>AdvisorAdapterRegistry：适配各种Advice到AOP拦截器，注册和管理Advisor适配器。</li>
<li>AdvisorAdapter：适配不同类型通知到拦截器链。</li>
<li>ProxyMethodInvocation：AOP方法调用代理，处理拦截器链和方法调用。</li>
<li>@EnableAspectJAutoProxy：启用AspectJ切面自动代理。</li>
<li>AnnotationAwareAspectJAutoProxyCreator：创建AOP代理以应用AspectJ风格的切面。</li>
<li>BeanFactoryAdvisorRetrievalHelper：帮助检索并管理Spring AOP 中的 Advisor Beans。</li>
<li>BeanFactoryAspectJAdvisorsBuilder：构建@AspectJ注解切面，生成Spring AOP Advisors。</li>
<li>AspectInstanceFactory：创建切面实例，支持多种实现方式。</li>
<li>MetadataAwareAspectInstanceFactory：管理切面实例和元数据，支持多种实例化策略。</li>
<li>AspectJAdvisorFactory：创建AspectJ通知器实例，管理切面通知的创建和配置。</li>
<li>TargetSource：管理AOP代理对象的获取与释放。</li>
<li>TargetSourceCreator：创建特殊的目标源，定制代理对象的创建和管理。</li>
<li>AopContext：获取Spring AOP代理对象的工具。</li>
<li>ExposeInvocationInterceptor：暴露Spring AOP方法调用上下文的拦截器。</li>
<li>@EnableLoadTimeWeaving：启用Spring加载时编织。</li>
</ul>
<h2 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h2><ul>
<li>Connection：管理数据库连接，执行SQL，处理事务。</li>
<li>DataSource：提供高效管理数据库连接的接口。</li>
<li>DriverManager：管理和建立数据库连接的核心类。</li>
<li>JdbcTemplate：简化了JDBC操作，提供了方便的数据库访问抽象。</li>
<li><u>TransactionDefinition</u>：定义事务的传播行为和隔离级别。</li>
<li><u>TransactionAttributeSource</u>：用于获取事务属性的策略接口。</li>
<li><u>PlatformTransactionManager</u>：用于管理和协调事务的生命周期和执行。</li>
<li><u>TransactionTemplate</u>：简化事务管理，支持编程式事务控制与异常处理。</li>
<li><u>SpringTransactionAnnotationParser</u>：解析 @Transactional注解并转换为事务配置。</li>
<li><u>TransactionInterceptor</u>：事务拦截器，用于管理方法级别的事务处理。</li>
<li><u>EnableTransactionManagement</u>：启用Spring的注解驱动事务管理。</li>
</ul>
]]></content>
      <categories>
        <category>Spring体系结构</category>
      </categories>
      <tags>
        <tag>Spring源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>《深度学习进阶：自然语言处理》阅读笔记</title>
    <url>/2024/04/08/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="1-神经网络"><a href="#1-神经网络" class="headerlink" title="1 神经网络"></a>1 神经网络</h1><h2 id="1-1-向量"><a href="#1-1-向量" class="headerlink" title="1.1 向量"></a>1.1 向量</h2><p>向量内积和矩阵乘积：</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_1bqyqcgBZu.png"></p>
<span id="more"></span>

<h2 id="1-2-激活函数"><a href="#1-2-激活函数" class="headerlink" title="1.2 激活函数"></a>1.2 激活函数</h2><h3 id="1-2-1-sigmoid"><a href="#1-2-1-sigmoid" class="headerlink" title="1.2.1 sigmoid"></a>1.2.1 sigmoid</h3><p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_9HSiif9JfV.png"></p>
<h3 id="1-2-2-tanh"><a href="#1-2-2-tanh" class="headerlink" title="1.2.2 tanh"></a>1.2.2 tanh</h3><p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_QIEQOJAnOF.png"></p>
<h2 id="1-3-Softmax"><a href="#1-3-Softmax" class="headerlink" title="1.3 Softmax"></a>1.3 Softmax</h2><p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_N3Vili_wTq.png"></p>
<p>作用：将输出转化为概率和为1的概率分布（概率标准化</p>
<p>交叉熵误差</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_zZKfBVcMoO.png"></p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_Chw1F7Akcw.png"></p>
<p>链式法则</p>
<p>链式法则的重要之处在于，无论我们要处理的函数有多复杂（无论复合了多少个函数），都可以根据它们各自的导数来求复合函数的导数。</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_haS6PoUyjG.png" alt="计算图" title="计算图"></p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_UXq-rgO7SR.png"></p>
<h2 id="1-4-反向传播"><a href="#1-4-反向传播" class="headerlink" title="1.4 反向传播"></a>1.4 反向传播</h2><p>公式</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_3Nd6MpmQmw.png"></p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_Y-jRNJkCgn.png"></p>
<blockquote>
<p>本书将矩阵乘积称为 MatMul（Matrix Multiply）节点。</p>
</blockquote>
<p>代码</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_ikLUqD3eNu.png"></p>
<p>链式法则：复合函数的导数可以根据各个简单函数的导数来求。</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_FjE1dwS714.png"></p>
<h3 id="1-4-1-Softmax-with-Loss-层"><a href="#1-4-1-Softmax-with-Loss-层" class="headerlink" title="1.4.1 Softmax with Loss 层"></a>1.4.1 Softmax with Loss 层</h3><p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_oi4iYIorJU.png"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Softmax with Loss</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SoftmaxWithLoss</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.parame = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, t</span>):</span><br><span class="line">        <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">        <span class="variable language_">self</span>.t = t</span><br><span class="line">        <span class="variable language_">self</span>.y = np.exp(x) / np.<span class="built_in">sum</span>(np.exp(x))</span><br><span class="line">        <span class="variable language_">self</span>.loss = -np.<span class="built_in">sum</span>(t * np.log(<span class="variable language_">self</span>.y))</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.loss</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">        dx = <span class="variable language_">self</span>.y - <span class="variable language_">self</span>.t</span><br><span class="line">        <span class="keyword">return</span> dx</span><br></pre></td></tr></tbody></table></figure>

<h2 id="1-5-梯度下降"><a href="#1-5-梯度下降" class="headerlink" title="1.5 梯度下降"></a>1.5 梯度下降</h2><p>随机梯度下降法</p>
<p>梯度下降：在训练过程中，反向传播将不断更新权重的梯度，让损失不断降低</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_39HQB-HZlV.png"></p>
<p>首先，选择 mini-batch 数据，根据误差反向传播法获得权重的梯度。这个梯度指向当前的权重参数所处位置中损失增加最多的方向。因此，通过将参数向该梯度的反方向更新，可以降低损失。这就是梯度下降法</p>
<p>权重更新方法：</p>
<ul>
<li><p>随机梯度下降法 SGD</p>
<ul>
<li>“随机”是指使用随机选择的数据（mini-batch）的梯度。<br><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_hqK0eTi6_4.png"></li>
</ul>
<p>η 表示学习率</p>
</li>
<li><p>批量梯度下降算法BGD</p>
</li>
<li><p>小批量 梯度下降算法MBGD</p>
</li>
</ul>
<h2 id="1-6-单层感知机"><a href="#1-6-单层感知机" class="headerlink" title="1.6 单层感知机"></a>1.6 单层感知机</h2><p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_oiKZuVifVq.png"></p>
<p>单层感知器属于单层前向网络，<strong>即除输入层和输出层之外，只拥有一层神经元节点</strong>。前向网络的特点是，输入数据从输入层经过隐藏层向输出层逐层传播，相邻两层的神经元之间相互连接， 同一层的神经元之间则没有连接。</p>
<h1 id="2-自然语言处理"><a href="#2-自然语言处理" class="headerlink" title="2 自然语言处理"></a>2 自然语言处理</h1><p>要想让计算机理解自然语言的前提就是让其理解每个单词的含义。我们主要有3种方法实现：</p>
<ul>
<li>基于同义词词典的方法<ul>
<li><strong>WordNet</strong></li>
</ul>
</li>
<li>基于计数的方法</li>
<li>基于推理的方法（word2vec）</li>
</ul>
<h2 id="单词的分布式表示"><a href="#单词的分布式表示" class="headerlink" title="单词的分布式表示"></a><strong>单词的分布式表示</strong></h2><p>我们能不能将类似于颜色RGB表示方法运用到单词上呢？在单词领域构建紧凑合理的向量表示，在自然语言处理领域，这称为<strong>分布式表示</strong>。单词的分布式表示将单词表示为固定长度的向量。这种向量的特征在于它是用密集向量表示的。</p>
<p><strong>密集向量</strong>：向量的各个元素（大多数）是由非 0 实数表示的。例如三维分布式表示是$[0.21,-0.45,0.83]$</p>
<p><strong>分布式假设</strong>：“某个单词的含义由它周围的单词形成”，称为<strong>分布式假设</strong>。</p>
<h2 id="2-2-基于计数的方法"><a href="#2-2-基于计数的方法" class="headerlink" title="2.2 基于计数的方法"></a>2.2 基于计数的方法</h2><p>基于计数的方法根据一个单词周围的单词的出现频数来表示该单词。具体来说，先生成所有单词的共现矩阵，再对这个矩阵进行SVD，以获得密集向量（单词的分布式表示）。但是，基于计数的方法在处理大规模语料库时会出现问题。</p>
<blockquote>
<p>奇异值分解（Singular Value Decomposition，SVD）是矩阵分解的一种方法，将一个矩阵分解为三个矩阵的乘积：$M = U \Sigma V^T$，其中 $U$ 和 $V$是正交矩阵，$\Sigma$是对角矩阵，包含奇异值。</p>
</blockquote>
<p>通过SVD，可以将原始高维稀疏矩阵压缩为低维稠密矩阵。这些低维矩阵的行向量或列向量就可以作为单词的向量表示。</p>
<p>SVD的作用：降维、去噪、稠密表示等</p>
<p>缺点：计算量太大导致计算机难以处理</p>
<h3 id="语料库的预处理"><a href="#语料库的预处理" class="headerlink" title="语料库的预处理"></a><strong>语料库的预处理</strong></h3><p>现在，我们对一个非常小的文本数据（语料库）进行预处理。这里所说的预处理是指：</p>
<ol>
<li>将文本分割成单词</li>
<li>单词列表转化为单词ID列表</li>
</ol>
<h3 id="2-2-2-共现矩阵"><a href="#2-2-2-共现矩阵" class="headerlink" title="2.2.2 共现矩阵"></a>2.2.2 共现矩阵</h3><p>用表格表示单词的上下文中包含的单词的频数，作为单词的向量表示</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_4rUGq7V2am.png"></p>
<p>对一个句子中所有的单词进行处理，就可以得到如下的共现矩阵：</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_6Te4nILf4k.png"></p>
<h3 id="2-2-3-余弦相似度（cosine-similarity）"><a href="#2-2-3-余弦相似度（cosine-similarity）" class="headerlink" title="2.2.3 余弦相似度（cosine similarity）"></a>2.2.3 余弦相似度（cosine similarity）</h3><p>在测量单词的向量表示的相似度方面，余弦相似度是很常用的。</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_K3SNNXUSNA.png"></p>
<h3 id="2-2-4-点互信息"><a href="#2-2-4-点互信息" class="headerlink" title="2.2.4 点互信息"></a>2.2.4 点互信息</h3><p>共现矩阵的元素表示两个单词同时出现的次数。但是，这种“原始”的次数并不具备好的性质。</p>
<p>比如“the car…”这样的短语，它们的共现次数将会很大。另外，car 和 drive 也明显有很强的相关性。但是，如果只看单词的出现次数，那么与 drive 相比，the 和 car 的相关性更强。这意味着，仅仅因为 the 是个常用词，它就被认为与 car 有很强的相关性，这显然不是我们想要的。</p>
<p>点互信息被用于解决这一问题：</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_VLIsIt84wg.png"></p>
<p>其中，P(x) 表示 x 发生的概率，P(y) 表示 y 发生的概率，P(x, y) 表示 x 和 y 同时发生的概率。PMI 的值越高，表明相关性越强。</p>
<h4 id="2-2-4-1-正的点互信息"><a href="#2-2-4-1-正的点互信息" class="headerlink" title="2.2.4.1 正的点互信息"></a>2.2.4.1 正的点互信息</h4><p>解决当两个单词的共现次数为 0 时，log20 = −∞。</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_mvK3ZF2ygS.png"></p>
<p>尽管PPMI矩阵能够改善之前共现矩阵存在的高频词汇问题，但是这两种方法都存在一个共性问题：<strong>随着单词数目的增加，矩阵的维数也在增加，而其中很多元素都为0(不重要的元素)；向量容易受到噪声的影响，稳定性差。</strong></p>
<hr>
<p>基于计数的方法使用整个语料库的统计数据（共现矩阵和 PPMI 等 ），通过一次处理（SVD 等）获得单词的分布式表示。而基于推理的方法使用神经网络，通常在 mini-batch 数据上进行学习。这意味着神经网络一次只需要看一部分学习数据（mini-batch），并反复更新权重。这种学习机制上的差异如图 3-1 所示。</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_hUDNVonnr_.png"></p>
<h2 id="2-3-基于推理的方法"><a href="#2-3-基于推理的方法" class="headerlink" title="2.3 基于推理的方法"></a>2.3 基于推理的方法</h2><p>基于推理的方法的主要操作是“推理”。当给出周围的单词（上下文）时，预测“？”处会出现什么单词，这就是推理。</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_9BpxVzfK51.png"></p>
<h3 id="2-3-1-word2vec"><a href="#2-3-1-word2vec" class="headerlink" title="2.3.1 word2vec"></a>2.3.1 word2vec</h3><p>word2vec 一词最初用来指程序或者工具，但是随着该词的流行，在某些语境下，也指神经网络的模型。</p>
<p>word2vec 中使用的两个神经网络分别是CBOW 模型和 skip-gram 模型</p>
<h4 id="2-3-1-1-CBOW-模型"><a href="#2-3-1-1-CBOW-模型" class="headerlink" title="2.3.1.1 CBOW 模型"></a>2.3.1.1 CBOW 模型</h4><p>continuous bag-of-words（CBOW）连续词袋模型</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_tDuQKVJFk5.png"></p>
<blockquote>
<p>中间层的神经元数量比输入层少这一点很重要。中间层需要将预测单词所需的信息压缩保存，从而产生密集的向量表示。这时，中间层被写入了我们人类无法解读的代码，这相当于“编码”工作。而从中间层的信息获得期望结果的过程则称为“解码”。这一过程将被编码的信息复原为我们可以理解的形式。</p>
</blockquote>
<hr>
<h5 id="2-3-1-1-1-CBOW模型的学习"><a href="#2-3-1-1-1-CBOW模型的学习" class="headerlink" title="2.3.1.1.1 CBOW模型的学习"></a>2.3.1.1.1 CBOW模型的学习</h5><p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_qsAFx46tbi.png"></p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_IJZAZJ2j13.png"></p>
<p>CBOW模型只是学习语料库中单词的出现模式。如果语料库不一样，学习到的单词的分布式表示也不一样。比如，只使用“体育”相关的文章得到的单词的分布式表示，和只使用“音乐”相关的文章得到的单词的分布式表示将有很大不同。</p>
<h5 id="2-3-1-1-2-CBOW损失函数"><a href="#2-3-1-1-2-CBOW损失函数" class="headerlink" title="2.3.1.1.2 CBOW损失函数"></a>2.3.1.1.2 CBOW损失函数</h5><p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_8RkALBaVVW.png"></p>
<p>CBOW 模型学习的任务就是让损失函数尽可能地小。那时的权重参数就是我们想要的单词的分布式表示。</p>
<h4 id="2-3-1-2-word2vec的权重和分布式表示"><a href="#2-3-1-2-word2vec的权重和分布式表示" class="headerlink" title="2.3.1.2 word2vec的权重和分布式表示"></a>2.3.1.2 word2vec的权重和分布式表示</h4><p>word2vec 中使用的网络有两个权重，分别是输入侧的全连接层的权重（$W_{in} $）和输出侧的全连接层的权重（$W_{out} $）。</p>
<p>就 word2vec（特别是 skip-gram 模型）而言，最受欢迎的是只使用输入侧的权重。</p>
<h3 id="2-3-2-skip-gram模型"><a href="#2-3-2-skip-gram模型" class="headerlink" title="2.3.2 skip-gram模型"></a>2.3.2 skip-gram模型</h3><p>skip-gram 是反转了 CBOW 模型处理的上下文和目标词的模型。</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_NWBJQnGsQh.png"></p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_Nx1lhLuzli.png"></p>
<h1 id="3-word2vec的高速化"><a href="#3-word2vec的高速化" class="headerlink" title="3 word2vec的高速化"></a>3 word2vec的高速化</h1><p>TODO</p>
<h1 id="4-RNN"><a href="#4-RNN" class="headerlink" title="4 RNN"></a>4 RNN</h1><blockquote>
<p>前馈神经网络FNN：最简单的网络，各神经元分层排列，每个神经元只与前一层的神经元相连。接收前一层的输出，并输出给下一层，各层间没有反馈</p>
</blockquote>
<p>到目前为止，我们看到的神经网络都是前馈型神经网络。虽然前馈网络结构简单、易于理解，但是可以应用于许多任务中。不过，这种网络存在一个大问题，就是不能很好地处理时间序列数据。更确切地说，单纯的前馈网络无法充分学习时序数据的性质。于是，RNN（Recurrent Neural Network，循环神经网络）便应运而生。</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_SlgtJLs9XQ.png"></p>
<p>RNN 的特征就在于拥有这样一个环路。这个环路可以使数据不断循环。通过数据的循环，RNN 一边记住过去的数据，一边更新到最新的数据。</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_OYNUHRviQU.png"></p>
<p>RNN 有两个权重，分别是将输入 x 转化为输出 h 的权重$  W_{x}  $和将前一个 RNN 层的输出转化为当前时刻的输出的权重 $W_{h}$。</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_N7X68U_dRV.png" alt="RNN三维表现" title="RNN三维表现"></p>
<p>$$<br>\boldsymbol{h}<em>{t}=\tanh \left(\boldsymbol{h}</em>{t-1} \boldsymbol{W}<em>{h}+\boldsymbol{x}</em>{t} \boldsymbol{W}_{x}+\boldsymbol{b}\right)<br>$$</p>
<p>从另一个角度看，这可以解释为，RNN 具有“状态”$h$，并以上式的形式被更新。这就是说RNN层是“具有状态的层”或“具有存储（记忆）的层”的原因。RNN 的输出 $h_{t}$称为<strong>隐藏状态</strong>或<strong>隐藏状态向量</strong></p>
<p>RNN有两个权重：$W_{h}$和$W_{x}$</p>
<h2 id="4-1-Backpropagation-Through-Time"><a href="#4-1-Backpropagation-Through-Time" class="headerlink" title="4.1 Backpropagation Through Time"></a>4.1 Backpropagation Through Time</h2><p>RNN的误差反向传播法是“按时间顺序展开的神经网络的误差反向传播法”，所以称为 Backpropagation Through Time（基于时间的反向传播），简称 BPTT。</p>
<h3 id="4-1-1-Truncated-BPTT"><a href="#4-1-1-Truncated-BPTT" class="headerlink" title="4.1.1 Truncated BPTT"></a>4.1.1 Truncated BPTT</h3><p>在处理长时序数据时，通常的做法是将网络连接截成适当的长度。具体来说，就是将时间轴方向上过长的网络在合适的位置进行截断，从而创建多个小型网络，然后对截出来的小型网络执行误差反向传播法，这个方法称为 Truncated BPTT（截断的 BPTT）。 </p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_elYrdSfgP7.png"></p>
<p>这里需要注意的是，虽然反向传播的连接会被截断，但是正向传播的连接不会。</p>
<h2 id="4-2-RNN反向传播"><a href="#4-2-RNN反向传播" class="headerlink" title="4.2 RNN反向传播"></a>4.2 RNN反向传播</h2><p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_0FJeCOAdIc.png" alt="RNN正向传播" title="RNN正向传播"></p>
<hr>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_U92MnE7C6K.png" alt="RNN反向传播" title="RNN反向传播"></p>
<h2 id="4-3-RNNLM"><a href="#4-3-RNNLM" class="headerlink" title="4.3  RNNLM"></a>4.3  RNNLM</h2><p>基于 RNN 的语言模型称为 RNNLM（RNN Language Model，RNN 语言模型）</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_CkpsNamznS.png"></p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_tfhaOlgpid.png"></p>
<p> Embedding 层：将单词 ID 转化为单词的分布式表示（单词向量）</p>
<h3 id="4-3-1-梯度消失和梯度爆炸"><a href="#4-3-1-梯度消失和梯度爆炸" class="headerlink" title="4.3.1 梯度消失和梯度爆炸"></a>4.3.1 梯度消失和梯度爆炸</h3><blockquote>
<p>RNN 层通过向过去传递“有意义的梯度”，能够学习时间方向上的依赖关系。此时梯度（理论上）包含了那些应该学到的有意义的信息，通过将这些信息向过去传递，RNN 层学习长期的依赖关系。但是，如果这个梯度在中途变弱（甚至没有包含任何信息），则权重参数将不会被更新。也就是说，RNN 层无法学习长期的依赖关系。不幸的是，随着时间的回溯，这个简单 RNN 未能避免梯度变小（梯度消失）或者梯度变大（梯度爆炸）的命运。</p>
</blockquote>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_TXW0mkOOdJ.png"></p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_Susys1EeV1.png"></p>
<p>当反向传播的梯度经过tanh 节点时，它的值会越来越小。因此，如果经过 tanh 函数 T 次，则梯度也会减小 T 次。</p>
<blockquote>
<p>RNN 层的激活函数一般使用 tanh 函数，但是如果改为 ReLU 函数，则有希望抑制梯度消失的问题（当 ReLU 的输入为 x 时，它的输出是max(0, x)）。这是因为，在 ReLU 的情况下，当 x 大于 0 时，反向传播将上游的梯度原样传递到下游，梯度不会“退化”。</p>
</blockquote>
<h2 id="4-4-Gated-RNN"><a href="#4-4-Gated-RNN" class="headerlink" title="4.4 Gated RNN"></a>4.4 Gated RNN</h2><p>上文提到的RNN 不擅长学习时序数据的长期依赖关系，原因是 BPTT 会发生梯度消失和梯度爆炸的问题。</p>
<p>当我们说 RNN 时，更多的是指 LSTM 层，而不是上一章的 RNN。</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_T4L3lbsK4w.png"></p>
<p>LSTM 与 RNN 的接口的不同之处在于，LSTM 还有路径 c。这个 c 称为记忆单元（或者简称为“单元”），相当于 LSTM 专用的记忆部门。</p>
<p>记忆单元的特点是，仅在 LSTM 层内部接收和传递数据。也就是说，记忆单元在 LSTM 层内部结束工作，不向其他层输出。而 LSTM 的隐藏状态 h 和 RNN 层相同，会被（向上）输出到其他层。</p>
<h2 id="4-5-LSTM"><a href="#4-5-LSTM" class="headerlink" title="4.5 LSTM"></a>4.5 LSTM</h2><h3 id="4-5-1-输出门"><a href="#4-5-1-输出门" class="headerlink" title="4.5.1 输出门"></a>4.5.1 输出门</h3><p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_SOAi8mJDjY.png"></p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_J8SXWBJc3n.png"></p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_kYPB-1QNDR.png"></p>
<blockquote>
<p>sigmoid 函数用 $σ()$ 表示</p>
</blockquote>
<blockquote>
<p>tanh的输出是−1.0 ~ 1.0的实数。我们可以认为这个−1.0 ~ 1.0的数值表示某种被编码的“信息”的强弱（程度）。而sigmoid 函数的输出是0.0~1.0的实数，表示数据流出的比例。因此，在大多数情况下，门使用sigmoid函数作为激活函数，而包含实质信息的数据则使用tanh函数作为激活函数。</p>
</blockquote>
<h3 id="4-5-2-遗忘门"><a href="#4-5-2-遗忘门" class="headerlink" title="4.5.2 遗忘门"></a>4.5.2 遗忘门</h3><p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_YIl0qmaVTK.png"></p>
<h3 id="4-5-3-新的记忆单元"><a href="#4-5-3-新的记忆单元" class="headerlink" title="4.5.3 新的记忆单元"></a>4.5.3 新的记忆单元</h3><p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_h4Nin6H2kA.png"></p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_J-HmVurGyH.png"></p>
<h3 id="4-5-4-输入门"><a href="#4-5-4-输入门" class="headerlink" title="4.5.4 输入门"></a>4.5.4 输入门</h3><p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_ThsOkpY5xe.png"></p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_soLXg37NZ1.png"></p>
<h3 id="4-5-5-LSTM的实现"><a href="#4-5-5-LSTM的实现" class="headerlink" title="4.5.5 LSTM的实现"></a>4.5.5 LSTM的实现</h3><p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_cQJVJXL5NX.png"></p>
<p>简化后：</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_N71KUQFLnj.png"></p>
<h1 id="5-Attention"><a href="#5-Attention" class="headerlink" title="5 Attention"></a>5 Attention</h1><h2 id="5-1-seq2seq改进"><a href="#5-1-seq2seq改进" class="headerlink" title="5.1 seq2seq改进"></a>5.1 seq2seq改进</h2><p>seq2seq存在的问题：无论输入语句多长，编码器都将其塞入固定长度的向量中，有用的信息也会从向量中溢出。</p>
<h3 id="5-1-1-编码器优化"><a href="#5-1-1-编码器优化" class="headerlink" title="5.1.1 编码器优化"></a>5.1.1 编码器优化</h3><p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_7o88_Ids4Y.png"></p>
<p>使用各个时刻（各个单词）的隐藏状态向量，可以获得和输入的单词数相同数量的向量。</p>
<p>编码器输出的 $h_{s}$ 矩阵就可以视为各个单词对应的向量集合。</p>
<p>这样一来，编码器就摆脱了“一个固定长度的向量”的制约。</p>
<h3 id="5-1-2-解码器的改进"><a href="#5-1-2-解码器的改进" class="headerlink" title="5.1.2 解码器的改进"></a>5.1.2 解码器的改进</h3><p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_bSlinKoTI_.png"></p>
<hr>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_HLsC5sqpbj.png"></p>
<p>网络所做的工作是提取单词对齐信息。具体来说，就是从 $h_{s}$ 中选出与各个时刻解码器输出的单词有对应关系的单词向量。但是“选择”这一操作是不可微分的，这里使用了单词重要度的权重$a$，计算$a$和$h_{s}$ 加权和可以获得目标向量：</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_q4blJe5wuo.png"></p>
<p>上下文向量 c 中包含了当前时刻进行变换（翻译）所需的信息。更确切地说，模型要从数据中学习出这种能力。 </p>
<hr>
<p><strong>如何获取</strong>$a$<strong>？</strong></p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_P7kOhf1xaa.png"></p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_onuLtYwAEz.png"></p>
<p> $h$ 表示解码器的 LSTM 层的隐藏状态向量，用$h$和$h_{s}$的内积表示这个 h 在多大程度上和 hs 的各个单词向量“相似”，并将其结果表示为 s，正则化后就得到了a</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_lSZYS8dvFC.png"></p>
<h3 id="5-1-3-Attention结构"><a href="#5-1-3-Attention结构" class="headerlink" title="5.1.3 Attention结构"></a>5.1.3 Attention结构</h3><p>总结：</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_XPq89glvv-.png"></p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_ZxHnftpiMc.png"></p>
<p>我们上面对seq2seq的优化实际就是加了一层Attention层：</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_wE13ZakECp.png"></p>
<hr>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadPoolExecutor详解</title>
    <url>/2024/09/13/ThreadPoolExecutor%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="ThreadPoolExecutor源码阅读"><a href="#ThreadPoolExecutor源码阅读" class="headerlink" title="ThreadPoolExecutor源码阅读"></a>ThreadPoolExecutor源码阅读</h1><blockquote>
<p>最近在准备秋招，复习线程池相关知识点的时候看到了几个比较有意思的面试题：</p>
<ul>
<li>线程池执行任务的时候，不显示的进行异常捕获，任务执行遇到异常会怎么样？线程会崩溃吗？</li>
<li>为什么队列满了再进行创建普通线程执行任务？</li>
</ul>
</blockquote>
<p>看到这两个问题我看到的时候就发现这块是自己知识盲区，不读源码我觉得是搞不明白的🤨，因此本文以此问题为切入点来读读ThreadPoolExecutor的核心源代码</p>
<h2 id="1-Executor-体系"><a href="#1-Executor-体系" class="headerlink" title="1 Executor 体系"></a>1 Executor 体系</h2><p>在阅读源码之前，最好先熟悉一下整个相关体系，可以让我们有一个全局观，不容易被带偏（个人的一点心得）</p>
<p><img src="/../images/ThreadPoolExecutor%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/image_TfZn6_FFY5.png"></p>
<p>ExecutorService提供了线程池的顶级抽象，以下是它的核心方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Executor</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ExecutorService</span> <span class="keyword">extends</span> <span class="title class_">Executor</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span>; </span><br><span class="line">    </span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line">    </span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line">    </span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-ThreadPoolExecutor源码"><a href="#2-ThreadPoolExecutor源码" class="headerlink" title="2 ThreadPoolExecutor源码"></a>2 ThreadPoolExecutor源码</h2><h3 id="2-1-Execute"><a href="#2-1-Execute" class="headerlink" title="2.1 Execute()"></a><code>2.1 Execute()</code></h3><p>ThreadPoolExecutor对ExecutorService的方法做了实现，使用<code>execute()</code>方法提交一个任务。</p>
<p>我们从源码分析一下线程池的任务执行流程：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 这个变量很巧妙，同时存放了线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span> {</span><br><span class="line">    <span class="keyword">return</span> c &amp; CAPACITY;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> {</span><br><span class="line">    <span class="comment">// 如果任务为null，则抛出异常。</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 当前线程数量 &lt; corePoolSize </span></span><br><span class="line">    <span class="comment">// 通过addWorker(command, true)新建一个线程，将任务添加到该线程中并执行</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) {</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 2. 当前线程数量 &gt; corePoolSize </span></span><br><span class="line">    <span class="comment">// 尝试将任务加入队列，如果工作队列未满则加入成功</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 再次获取线程池状态，如果不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span></span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">            <span class="comment">// 如果当前工作线程数量为0，新创建一个线程并执行。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 3.队列已满后尝试添加worker</span></span><br><span class="line">    <span class="comment">// 注意这里是先执行addWorker再判断，如果addWorker返回false（意味着当前线程数超过max）才会走拒绝策略 </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">        <span class="comment">// 4.队列已满且无法添加线程将会拒绝</span></span><br><span class="line">        reject(command);  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>根据上面的源码，线程池大致提交任务的流程如下图所示：</p>
<p><img src="/../images/ThreadPoolExecutor%E8%AF%A6%E8%A7%A3/image_UPNOPts0OI.png"></p>
<p>总结一下就是：</p>
<ol>
<li>如果当前核心线程有空闲，就将任务分配给核心线程执行；</li>
<li>如果核心线程满了，就将任务暂时放在工作队列中；</li>
<li>如果工作队列也满了，创建普通线程来执行任务，核心+普通线程的数量不超过maxPool；</li>
<li>如果都不行，就执行拒绝策略</li>
</ol>
<h3 id="2-2-addWorker"><a href="#2-2-addWorker" class="headerlink" title="2.2 addWorker()"></a><code>2.2 addWorker()</code></h3><p>在上面的源码中，我们看到当需要创建线程时会调用<code>addWorker()</code>方法。<code>addWorker()</code>能够添加新的工作线程到线程池，该方法涉及到线程池的一些重要资源：</p>
<ul>
<li><code>largestPoolSize</code>（线程池最大大小）和<code>workers</code>（工作线程集合）都属于临界资源，会有多线程竞争问题，因此通过全局锁来进行互斥</li>
<li>而<code>ctl</code>（工作线程数量）则是通过CAS去保证线程安全的。</li>
</ul>
<p>以下是内部实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 全局锁，并发操作必备 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"> <span class="comment">// 跟踪线程池的最大大小 ，只有在持有全局锁mainLock的前提下才能访问此集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> largestPoolSize;</span><br><span class="line"> <span class="comment">// 工作线程集合 ，存放线程池中所有的（活跃的）工作线程，只有在持有全局锁mainLock的前提下才能访问此集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 获取线程池状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStateOf</span><span class="params">(<span class="type">int</span> c)</span> { <span class="keyword">return</span> c &amp; ~CAPACITY; }</span><br><span class="line"><span class="comment">// 判断线程池的状态是否为 Running</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isRunning</span><span class="params">(<span class="type">int</span> c)</span> {</span><br><span class="line">    <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加新的工作线程到线程池</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> firstTask 执行的任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> core参数为true的话表示使用线程池的基本大小，为false使用线程池最大大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 添加成功就返回true否则返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> {</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="comment">//这两句用来获取线程池的状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">           <span class="comment">//获取线程池中工作的线程的数量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">            <span class="comment">// core参数为false的话表明队列也满了，线程池大小变为 maximumPoolSize</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           <span class="comment">//原子操作将workcount的数量加1</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">// 如果线程的状态改变了就再次执行上述操作</span></span><br><span class="line">            c = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS失败时因为workerCount改变了，继续内层循环尝试CAS对worker数量+1</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 标记工作线程是否启动成功</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 标记工作线程是否创建成功</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line"></span><br><span class="line">        w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;  <span class="comment">// 这里的thread是worker本身</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) {</span><br><span class="line">          <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">               <span class="comment">//获取线程池状态</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());</span><br><span class="line">               <span class="comment">// 线程池是否是可添加worker状态</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) {</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                   <span class="comment">//更新当前工作线程的最大容量</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                  <span class="comment">// 工作线程是否启动成功</span></span><br><span class="line">                    workerAdded = <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                <span class="comment">// 释放锁</span></span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//// 如果成功添加工作线程，则调用Worker内部的线程实例t的Thread#start()方法启动真实的线程实例</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) {</span><br><span class="line">                t.start();    <span class="comment">// worker.run()调用runWorker() </span></span><br><span class="line">              <span class="comment">/// 标记线程启动成功</span></span><br><span class="line">                workerStarted = <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">       <span class="comment">// 线程启动失败，需要从工作线程中移除对应的Worker</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">} ThreadPoolExecutor.java</span><br></pre></td></tr></tbody></table></figure>

<p>放一个大佬总结的流程图</p>
<p><img src="/../images/ThreadPoolExecutor%E8%AF%A6%E8%A7%A3/image_vaHY6IYtZP.png"></p>
<h3 id="2-3-Worker内部实现"><a href="#2-3-Worker内部实现" class="headerlink" title="2.3 Worker内部实现"></a>2.3 Worker内部实现</h3><p><strong>Worker****是基于AQS实现的，内部实现了一个不可重入锁，这个锁的作用是什么呢？</strong></p>
<p>Worker的锁主要的目的是为了控制中断。这也是为什么不直接执行<code>execute(command)</code>提交的command，而要在外面包一层Worker的原因</p>
<p><em>Tips：worker的锁是用来控制中断的？居然还有这种用法？？我直接惊了</em>😮</p>
<p><strong>如何控制呢？</strong></p>
<p>用AQS锁，当运行时上锁，中断必须获取锁，这样就保证了worker不会在运行的时候被突然噶掉</p>
<p>TreadPoolExecutor在调用<code>shutdown()</code>方法中断worker前都要获取worker锁</p>
<p>已启动的worker只有在处于等待状态，即尝试从workQueue中获取任务<code>getTask()</code>时才能被中断</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Thread thread; <span class="comment">//利用ThreadFactory和Worker这个Runnable创建的线程对象</span></span><br><span class="line">    </span><br><span class="line">    Runnable firstTask;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> completedTasks;</span><br><span class="line"> </span><br><span class="line">    Worker(Runnable firstTask) {</span><br><span class="line">        <span class="comment">// 设置AQS的同步状态state=-1，state是AQS的一个计数器，大于0代表锁已经被获取</span></span><br><span class="line">        <span class="comment">// 在调用runWorker()前，禁止interrupt中断，在interruptIfStarted()方法中会判断 getState()&gt;=0</span></span><br><span class="line">        <span class="comment">// state=-1表示当前worker未启动，线程还没运行，因此不需要中断</span></span><br><span class="line">        setState(-<span class="number">1</span>); </span><br><span class="line">        <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">// 根据当前worker创建一个线程对象</span></span><br><span class="line">        <span class="comment">// 当前worker本身就是一个runnable任务，也就是不会用参数的firstTask创建线程，而是调用当前worker.run()时调用firstTask.run()</span></span><br><span class="line">        <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>); </span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        runWorker(<span class="built_in">this</span>); <span class="comment">//runWorker()是ThreadPoolExecutor的方法，用于启动worker</span></span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 0代表“没被锁定”状态</span></span><br><span class="line">    <span class="comment">// 1代表“锁定”状态</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取锁</span></span><br><span class="line"><span class="comment">     * 重写AQS的tryAcquire()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> unused)</span> {</span><br><span class="line">        <span class="comment">//尝试一次将state从0设置为1，即“锁定”状态，但由于每次都是state 0-&gt;1，而不是+1，那么说明不可重入</span></span><br><span class="line">        <span class="comment">//且state==-1时也不会获取到锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) {</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread()); <span class="comment">//设置exclusiveOwnerThread=当前线程</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试释放锁</span></span><br><span class="line"><span class="comment">     * 不是state-1，而是置为0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> unused)</span> {</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>); </span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>        { acquire(<span class="number">1</span>); }</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>  { <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>      { release(<span class="number">1</span>); }</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLocked</span><span class="params">()</span> { <span class="keyword">return</span> isHeldExclusively(); }</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中断（如果运行）</span></span><br><span class="line"><span class="comment">     * shutdownNow时会循环对worker线程执行</span></span><br><span class="line"><span class="comment">     * 且不需要获取worker锁，即使在worker运行时也可以中断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">interruptIfStarted</span><span class="params">()</span> {</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="comment">//如果state&gt;=0、t!=null、且t没有被中断</span></span><br><span class="line">        <span class="comment">//new Worker()时state==-1，说明不能中断</span></span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="literal">null</span> &amp;&amp; !t.isInterrupted()) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                t.interrupt();</span><br><span class="line">            } <span class="keyword">catch</span> (SecurityException ignore) {</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意，worker内部的锁是<strong>不可重入的互斥锁</strong>，而不是用ReentrantLock可重入锁</p>
<p>这是因为我们不想让在调用比如<code>setCorePoolSize()</code>这种线程池控制方法时可以再次获取锁(重入)，因为<code>setCorePoolSize()</code>时可能会<code>interruptIdleWorkers()</code>，在对一个线程interrupt时会要<code>w.tryLock()</code>。如果可重入，就可能会在对线程池操作的方法中中断线程，类似方法还有：</p>
<ul>
<li><code>setMaximumPoolSize()</code></li>
<li><code>setKeppAliveTime()</code></li>
<li><code>allowCoreThreadTimeOut()</code></li>
<li><code>shutdown()</code></li>
</ul>
<p>还有一个细节，在<code>new Worker()</code>时初始state=-1，这是为了让线程真正开始后才可以中断，初始化state=-1，在开始<code>runWorker()</code>时将state置为0，而state&gt;=0才可以被中断</p>
<h3 id="2-4-runWorker"><a href="#2-4-runWorker" class="headerlink" title="2.4 runWorker()"></a><code>2.4 runWorker()</code></h3><p>worker的启动方法，一旦启动后，会一直循环从队列中获取任务执行，执行任务时会锁住worker，只有在<code>getTask()</code>方法阶段才会释放锁</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> {</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">    w.firstTask = <span class="literal">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) {</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    task.run();</span><br><span class="line">                    afterExecute(task, <span class="literal">null</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">                    afterExecute(task, ex);</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                task = <span class="literal">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>流程图</p>
<p><img src="/../images/ThreadPoolExecutor%E8%AF%A6%E8%A7%A3/image_PolOIn-pLa.png"></p>
<h3 id="2-5-getTask"><a href="#2-5-getTask" class="headerlink" title="2.5 getTask()"></a><code>2.5 getTask()</code></h3><p>下面来看一下<code>getTask()</code>方法，这里面涉及到<code>keepAliveTime</code>的使用以及空闲worker的销毁</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 是否超时</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) {</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// allowCoreThreadTimeOut=false，线程即使空闲也不会被销毁；倘若为ture，在keepAliveTime内仍空闲则会被销毁。</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) {</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="literal">true</span>;</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException retry) {</span><br><span class="line">            timedOut = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>如果<strong>线程允许空闲并且当前线程数大于核心线程数</strong>，则执行<code>workQueue.take</code>：如果阻塞队列为空，当前线程会被挂起等待；当队列中有任务加入时，线程被唤醒，take方法返回任务，并执行；</li>
<li>如果<strong>线程不允许空闲或者当前线程数小于核心线程数****，</strong> 则执行<code>workQueue.poll</code>: 如果在<code>keepAliveTime</code>时间内，阻塞队列还是没有任务，则返回null并删除一个worker；</li>
</ul>
<blockquote>
<p><strong>只有在线程数小于coreSize并且没有任务的情况下才会删除worker</strong></p>
</blockquote>
<h2 id="3-ThreadPoolExecutor关闭"><a href="#3-ThreadPoolExecutor关闭" class="headerlink" title="3 ThreadPoolExecutor关闭"></a>3 ThreadPoolExecutor关闭</h2><p>线程池有两个关闭的方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 阻止提交任务，在所有线程执行完后结束</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用shutdownNow()后触发，线程池不再接受新的任务，尝试终止所有正在执行的任务</span></span><br><span class="line">List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span>; </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>那么有以下几个问题：</p>
<ul>
<li>线程池关闭的流程是怎么样的呢？</li>
<li>线程池的探活机制？（快手面试原题）</li>
</ul>
<h3 id="3-1-shutdown"><a href="#3-1-shutdown" class="headerlink" title="3.1 shutdown"></a>3.1 shutdown</h3><p><code>shutdown()</code>方法的步骤：</p>
<ol>
<li>CAS更新线程池状态为shutdown</li>
<li><code>interruptIdleWorkers()</code>中断所有空闲线程</li>
<li><code>tryTerminated()</code>尝试终止线程池</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock(); <span class="comment">//上锁</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">//判断调用者是否有权限shutdown线程池</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//CAS循环设置线程池状态为shutdown</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//中断所有空闲线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">         </span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    } </span><br><span class="line">    <span class="keyword">finally</span> {</span><br><span class="line">        mainLock.unlock(); <span class="comment">//解锁</span></span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//尝试终止线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>interruptIdleWorkers()</code>会中断所有可能正在等待任务的线程，即未被锁定的worker</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">interruptIdleWorkers</span><span class="params">(<span class="type">boolean</span> onlyOne)</span> {</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) {</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                } <span class="keyword">catch</span> (SecurityException ignore) {</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    w.unlock();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-2-shutdownNow"><a href="#3-2-shutdownNow" class="headerlink" title="3.2 shutdownNow"></a>3.2 shutdownNow</h3><p><code>shutdown()</code>方法的步骤：</p>
<ol>
<li>CAS更新线程池状态为STOP</li>
<li><code>interruptWorkers()</code>中断所有空闲线程</li>
<li><code>tryTerminated()</code>尝试终止线程池</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span> {</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        interruptWorkers();</span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    }</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>interruptWorkers()</code>会中断所有已启动的worker，即使worker处于活跃状态</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">interruptWorkers</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// assert mainLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">        w.interruptIfStarted();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="4-拓展面试题"><a href="#4-拓展面试题" class="headerlink" title="4 拓展面试题"></a>4 拓展面试题</h2><p>了解了上面的核心原理，现在就可以回答最开始的面试题了：</p>
<h3 id="4-1-一个线程池中的线程异常了，那么线程池会怎么处理这个线程"><a href="#4-1-一个线程池中的线程异常了，那么线程池会怎么处理这个线程" class="headerlink" title="4.1 一个线程池中的线程异常了，那么线程池会怎么处理这个线程?"></a>4.1 一个线程池中的线程异常了，那么线程池会怎么处理这个线程?</h3><blockquote>
<p>📌主要分三点回答：</p>
<ol>
<li>是否会抛出堆栈异常？</li>
<li>是否会影响其他线程任务？</li>
<li>异常线程被丢弃还是放回？</li>
</ol>
</blockquote>
<h4 id="4-1-1-是否会抛出堆栈异常？"><a href="#4-1-1-是否会抛出堆栈异常？" class="headerlink" title="4.1.1 是否会抛出堆栈异常？"></a>4.1.1 是否会抛出堆栈异常？</h4><p>是否会抛出堆栈异常跟任务提交方式有关。ExecutorService提供了两种任务提交的方式：<code>execute()</code>和<code>submit()</code>。上面已经介绍过了<code>execute()</code>，我们再来看看<code>submit()</code>方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) {</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="literal">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// FutureTask</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTask</span>&lt;V&gt; <span class="keyword">implements</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; {</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">      <span class="keyword">if</span> (state != NEW || !UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, runnerOffset,</span><br><span class="line">                                       <span class="literal">null</span>, Thread.currentThread()))</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">try</span> {</span><br><span class="line">          Callable&lt;V&gt; c = callable;</span><br><span class="line">          <span class="comment">// 1、状态检查</span></span><br><span class="line">          <span class="keyword">if</span> (c != <span class="literal">null</span> &amp;&amp; state == NEW) {</span><br><span class="line">              V result;</span><br><span class="line">              <span class="type">boolean</span> ran;</span><br><span class="line">              <span class="keyword">try</span> {</span><br><span class="line">                  <span class="comment">// 2、调用包装前的实际方法执行并获取返回值</span></span><br><span class="line">                  result = c.call();</span><br><span class="line">                  ran = <span class="literal">true</span>;</span><br><span class="line">              } <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">                  <span class="comment">// 3、如果执行失败，则保存异常信息</span></span><br><span class="line">                  result = <span class="literal">null</span>;</span><br><span class="line">                  ran = <span class="literal">false</span>;</span><br><span class="line">                  setException(ex);</span><br><span class="line">              }</span><br><span class="line">              <span class="comment">// 4、如果执行成功，则将返回值保存起来</span></span><br><span class="line">              <span class="keyword">if</span> (ran)</span><br><span class="line">                  set(result);</span><br><span class="line">          }</span><br><span class="line">      } <span class="keyword">finally</span> {</span><br><span class="line">          runner = <span class="literal">null</span>;</span><br><span class="line">          <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">          <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">              handlePossibleCancellationInterrupt(s);</span><br><span class="line">      }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"> AbstractExecutorService.java</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到<code>submit()</code>将任务封装成了<code>RunnableFuture</code>（无论是Runnable还是Callable），但本质上还是执行了<code>execute()</code></p>
<p>因此两者最根本的区别在<code>RunnableFuture.run()</code>方法里，FutureTask会捕获异常并保存堆栈信息。<em><strong>因此如果遇到线程执行异常，执行</strong></em>***<code>submit()</code><strong><strong><strong>任务的线程不会崩溃退出，并能通过</strong></strong></strong><code>get()</code><strong><strong><strong>获取到异常信息，如果不get就啥也不会发生，而</strong></strong></strong><code>execute()</code>***<em><strong>内部是没有进行异常捕获的，因此会让线程崩溃</strong></em></p>
<h4 id="4-1-2-是否会影响其他线程任务？"><a href="#4-1-2-是否会影响其他线程任务？" class="headerlink" title="4.1.2 是否会影响其他线程任务？"></a>4.1.2 是否会影响其他线程任务？</h4><p>答案是不会的，自己实验一下就知道了，这里不多赘述</p>
<h4 id="4-1-3-异常线程被丢弃还是放回？"><a href="#4-1-3-异常线程被丢弃还是放回？" class="headerlink" title="4.1.3 异常线程被丢弃还是放回？"></a>4.1.3 异常线程被丢弃还是放回？</h4><p>除了报错信息外，线程池会怎么处理异常线程呢？</p>
<p>其实线程池是可以设置异常处理器的，也就是<code>uncaughtException</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// new Thread()</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>();</span><br><span class="line">t.setUncaughtExceptionHandler(<span class="keyword">new</span> <span class="title class_">Thread</span>.UncaughtExceptionHandler() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> {</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    }</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>, thread -&gt; {</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(thread);</span><br><span class="line">    t.setUncaughtExceptionHandler((t1, e) -&gt; {</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    });</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/../images/ThreadPoolExecutor%E8%AF%A6%E8%A7%A3/image_S273_MFQcN.png"></p>
<p>注意，这里任务执行异常后，异常会继续向上抛出，<code>processWorkerExit()</code>会被执行。而<code>processWorkerExit()</code>的核心操作就是<em><strong>移除异常的worker，并创建一个新的worker</strong></em>：</p>
<p><img src="/../images/ThreadPoolExecutor%E8%AF%A6%E8%A7%A3/image_1f4ENk9yEy.png"></p>
<p>这也就会造成一个很有意思的现象：</p>
<p><img src="/../images/ThreadPoolExecutor%E8%AF%A6%E8%A7%A3/image_fMZrKPWUAu.png"></p>
<h3 id="4-2-为什么队列满了再进行创建普通线程执行任务？"><a href="#4-2-为什么队列满了再进行创建普通线程执行任务？" class="headerlink" title="4.2 为什么队列满了再进行创建普通线程执行任务？"></a>4.2 为什么队列满了再进行创建普通线程执行任务？</h3><p>普通线程有一个别名，叫急救线程，意在面临工作队列溢出的情况下帮助处理任务。他们就相当于厂里的临时工，只有在正式员工（核心线程）忙不过来且仓库（工作队列）没空间的时候才会用到，因此这样设计的好处是节约系统的资源，创建线程需要获取全局锁，开销较大；而放入队列开销相对较低</p>
<p>但是像 Tomcat 线程池的做法是，遇到超量的任务，先创建普通线程，普通线程不够了再往队列里丢 ，这样做的原因是Tomcat 面临大量网络I/O请求、短连接，放入队列意味着用户需要一直等待，用户肯定不乐意，本着物尽其用的道理，谁也别想闲着。</p>
<h3 id="4-3-Tomcat线程池是如何做的"><a href="#4-3-Tomcat线程池是如何做的" class="headerlink" title="4.3 Tomcat线程池是如何做的?"></a>4.3 T<strong>omcat线程池是如何做的?</strong></h3><p>简单的说：</p>
<ol>
<li>新线程池继承JDK线程池接口，重写了<code>execute()</code>方法：当抛出拒绝策略了再给一次机会，尝试往阻塞队列里插任务，尽最大努力的去执行任务 <em>(意思是不抛弃不放弃，免得用户请求失败)</em></li>
<li>新阻塞队列继承了LinkedBlockingQueue，重写了<code>offer()</code>方法：每次向队列插入任务，判断如果当前线程数小于最大线程数则插入失败，插入失败后就会尝试创建新的线程，以此来逼迫线程池创建新线程来处理任务 <em>(意思你别想偷懒，把任务丢到队列就不管了)</em></li>
</ol>
<h3 id="4-4-shutDown的探活机制？"><a href="#4-4-shutDown的探活机制？" class="headerlink" title="4.4 shutDown的探活机制？"></a>4.4 shutDown的探活机制？</h3><p>探活机制指shutDown如何发现正在执行任务的worker并且不直接中断他们</p>
<p>worker在执行任务时，会锁定内部的AQS锁，并且是不可重入的，shutDown关闭worker时，会调用<code>interruptIdleWorkers()</code>方法，该方法会先尝试获取内部锁，获取到后再执行中断</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="https://www.cnblogs.com/thisiswhy/p/12221335.html" title="有的线程它死了，于是它变成一道面试题">有的线程它死了，于是它变成一道面试题</a></li>
<li><a href="https://www.cnblogs.com/trust-freedom/p/6681948.html#label_3_3" title="Java线程池ThreadPoolExecutor使用和分析(二) - execute()原理 ">Java线程池ThreadPoolExecutor使用和分析(二) - execute()原理 </a></li>
<li><a href="https://www.cnblogs.com/ttaall/p/15220042.html" title="浅聊Tomcat线程池">浅聊Tomcat线程池</a></li>
</ul>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>JUC</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务理论体系</title>
    <url>/2023/02/08/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<blockquote>
<p>教程来自 极客时间《从0开始学微服务》</p>
</blockquote>
<h1 id="1-微服务发展历史"><a href="#1-微服务发展历史" class="headerlink" title="1 微服务发展历史"></a>1 微服务发展历史</h1><ul>
<li><p><em><strong>单体应用阶段</strong></em></p>
<p>早期互联网公司的架构：</p>
<ul>
<li>LAMP（Linux + Apache + MySQL + PHP）</li>
<li>MVC（Spring + iBatis/Hibernate + Tomcat）</li>
</ul>
<p>特点：团队规模一般不超过5人</p>
</li>
<li><p><em><strong>服务化思想</strong></em></p>
<p>把原来整个大的项目粗略分为不同的业务模块，拆分出来进行独立部署，并以RPC接口的形式对外提供服务。这样原来的模块就会由进程内调用变为远程RPC调用，也就可以独立开发、测试、上线和运维，甚至交给不同的团队去做。</p>
</li>
<li><p><em><strong>微服务阶段</strong></em></p>
<p>相比于服务化，微服务拆分粒度更细，服务之间更加独立，并且由于拆分后的服务更多，需要有一个同一个管理平台去维护，需要做服务监控、服务追踪、服务治理等去管理</p>
</li>
</ul>
<span id="more"></span>

<h2 id="1-1-服务发布和引用"><a href="#1-1-服务发布和引用" class="headerlink" title="1.1 服务发布和引用"></a>1.1 服务发布和引用</h2><blockquote>
<p>📌最常见的服务发布和引用的方式有三种：</p>
<ul>
<li>RESTful API</li>
<li>XML配置</li>
<li>IDL文件</li>
</ul>
</blockquote>
<h3 id="1-1-1-RESTful-API"><a href="#1-1-1-RESTful-API" class="headerlink" title="1.1.1 RESTful API"></a>1.1.1 RESTful API</h3><p>主要被<strong>用作HTTP或者HTTPS协议的接口定义</strong>，即使在非微服务架构体系下，也被广泛采用。</p>
<p>服务提供者和消费者间通过HTTP协议进行交互，适合需要向其他业务部分提供服务或者给外网提供服务的场景</p>
<h3 id="1-1-2-XML配置"><a href="#1-1-2-XML配置" class="headerlink" title="1.1.2 XML配置"></a>1.1.2 XML配置</h3><p>这种方式的服务发布和引用主要分三个步骤：</p>
<ul>
<li>服务提供者定义接口，并实现接口。</li>
<li>服务提供者进程启动时，通过加载server.xml配置文件将接口暴露出去。</li>
<li>服务消费者进程启动时，通过加载client.xml配置文件来引入要调用的接口。</li>
</ul>
<p>服务提供者和服务消费者之间维持一份对等的XML配置文件，来保证服务消费者按照服务提供者的约定来进行服务调用。在这种方式下，如果服务提供者变更了接口定义，不仅需要更新server.xml，还需要同时更新client.xml。</p>
<p>适用场景：</p>
<ul>
<li>私有RPC框架（性能要求高）</li>
<li>公司内部联系比较紧密的业务</li>
</ul>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context-2.5.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">motan:service</span> <span class="attr">ref</span>=<span class="string">"userLastStatusLocalService"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">requestTimeout</span>=<span class="string">"50"</span> <span class="attr">retries</span>=<span class="string">"2"</span>    <span class="attr">interface</span>=<span class="string">"com.weibo.api.common.status.service.UserLastStatusService"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">basicService</span>=<span class="string">"serviceBasicConfig"</span> <span class="attr">export</span>=<span class="string">"motan:8882"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">"getLastStatusId"</span> <span class="attr">requestTimeout</span>=<span class="string">"300"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">retries</span>=<span class="string">"0"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">"getLastStatusIds"</span> <span class="attr">requestTimeout</span>=<span class="string">"300"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">retries</span>=<span class="string">"0"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">motan:service</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="1-1-3-IDL文件"><a href="#1-1-3-IDL文件" class="headerlink" title="1.1.3 IDL文件"></a>1.1.3 IDL文件</h3><p>通过一种中立的方式来描述接口，使得在不同的平台上运行的对象和不同语言编写的程序可以相互通信交流。</p>
<p>有两种最常用的IDL：</p>
<ul>
<li>Facebook开源的<strong>Thrift协议</strong></li>
<li>Google开源的<strong>gRPC协议</strong>。</li>
</ul>
<h2 id="1-2-注册中心"><a href="#1-2-注册中心" class="headerlink" title="1.2 注册中心"></a>1.2 注册中心</h2><ul>
<li>服务注册</li>
<li>服务发现</li>
</ul>
<h3 id="1-2-1-注册中心原理"><a href="#1-2-1-注册中心原理" class="headerlink" title="1.2.1 注册中心原理"></a>1.2.1 注册中心原理</h3><p><img src="/../images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB/image_qRiIliPDtc.png"></p>
<ul>
<li>RPC Server提供服务，在启动时，根据服务发布文件server.xml中的配置的信息，向Registry注册自身服务，并向Registry定期发送心跳汇报存活状态。</li>
<li>RPC Client调用服务，在启动时，根据服务引用文件client.xml中配置的信息，向Registry订阅服务，把Registry返回的服务节点列表缓存在本地内存中，并与RPC Sever建立连接。</li>
<li>当RPC Server节点发生变更时，Registry会同步变更，RPC Client感知后会刷新本地内存中缓存的服务节点列表。</li>
<li>RPC Client从本地缓存的服务节点列表中，<strong>基于负载均衡算法</strong>选择一台RPC Sever发起调用。</li>
</ul>
<h3 id="1-2-2-注册中心实现方式"><a href="#1-2-2-注册中心实现方式" class="headerlink" title="1.2.2 注册中心实现方式"></a>1.2.2 注册中心实现方式</h3><h4 id="注册中心API"><a href="#注册中心API" class="headerlink" title="注册中心API"></a><strong>注册中心API</strong></h4><ul>
<li>服务注册接口：服务提供者通过调用服务注册接口来完成服务注册。</li>
<li>服务反注册接口：服务提供者通过调用服务反注册接口来完成服务注销。</li>
<li>心跳汇报接口：服务提供者通过调用心跳汇报接口完成节点存活状态上报。</li>
<li>服务订阅接口：服务消费者通过调用服务订阅接口完成服务订阅，获取可用的服务提供者节点列表。</li>
<li>服务变更查询接口：服务消费者通过调用服务变更查询接口，获取最新的可用服务节点列表。</li>
<li>服务查询接口：查询注册中心当前注册了哪些服务信息。</li>
<li>服务修改接口：修改注册中心中某一服务的信息。</li>
</ul>
<h4 id="1-2-2-2-集群部署"><a href="#1-2-2-2-集群部署" class="headerlink" title="1.2.2.2 集群部署"></a>1.2.2.2 集群部署</h4><p>注册中心作为服务提供者和服务消费者之间沟通的桥梁，它的重要性不言而喻。所以注册中心一般都是采用集群部署来保证高可用性，并通过分布式一致性协议来确保集群中不同节点之间的数据保持一致。</p>
<p>以ZooKeeper为例，ZooKeeper集群中包含多个节点，服务提供者和服务消费者可以同任意一个节点通信，因为它们的数据一定是相同的。ZooKeeper的工作原理：</p>
<p><img src="/../images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB/image_o-_tuXD8rn.png"></p>
<ul>
<li>每个Server在内存中存储了一份数据，Client的读请求可以请求任意一个Server</li>
<li>ZooKeeper启动时，将从实例中选举一个leader（Paxos协议）</li>
<li>Leader负责处理数据更新等操作（ZAB协议）</li>
<li>一个更新操作成功，当且仅当大多数Server在内存中成功修改 </li>
</ul>
<p>通过上面这种方式，ZooKeeper保证了<strong>高可用性</strong>以及<strong>数据一致性</strong></p>
<h4 id="目录存储"><a href="#目录存储" class="headerlink" title="目录存储"></a><strong>目录存储</strong></h4><p>还是以ZooKeeper为例，注册中心存储服务信息一般采用层次化的目录结构：</p>
<ul>
<li>每个目录在ZooKeeper中叫作znode，并且其有一个唯一的路径标识。</li>
<li>znode可以包含数据和子znode。</li>
<li>znode中的数据可以有多个版本，比如某一个znode下存有多个数据版本，那么查询这个路径下的数据需带上版本信息。</li>
</ul>
<p><img src="/../images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB/image_gn7reAdS58.png"></p>
<h4 id="服务健康状态检测"><a href="#服务健康状态检测" class="headerlink" title="服务健康状态检测"></a><strong>服务健康状态检测</strong></h4><p>一旦注册中心探测到有服务提供者节点新加入或者被剔除，就必须立刻通知所有订阅该服务的服务消费者，刷新本地缓存的服务节点信息，确保服务调用不会请求不可用的服务提供者节点。</p>
<p>继续以ZooKeeper为例，基于ZooKeeper的<strong>Watcher机制</strong>，来实现服务状态变更通知给服务消费者的。服务消费者在调用ZooKeeper的getData方法订阅服务时，还可以通过监听器Watcher的process方法获取服务的变更，然后调用getData方法来获取变更后的数据，刷新本地缓存的服务节点信息。</p>
<h4 id="1-2-2-5-白名单机制"><a href="#1-2-2-5-白名单机制" class="headerlink" title="1.2.2.5 白名单机制"></a>1.2.2.5 白名单机制</h4><p>在实际应用中，注册中心可以提供一个白名单机制，只有添加到注册中心白名单内的RPC Server，才能够调用注册中心的注册接口，这样的话可以避免测试环境中的节点意外跑到线上环境中去。</p>
<h2 id="1-3-RPC远程调用"><a href="#1-3-RPC远程调用" class="headerlink" title="1.3 RPC远程调用"></a>1.3 RPC远程调用</h2><blockquote>
<p>RPC协议的主要目的是做到不同服务间调用方法像同一服务间调用本地方法一样</p>
</blockquote>
<p>由服务提供者给出业务接口声明，在调用方的程序里面，RPC框架根据调用的服务接口提前生成动态代理实现类，并通过依赖注入等技术注入到声明了该接口的相关业务逻辑里面。该代理实现类会拦截所有的方法调用，在提供的方法处理逻辑里面完成一整套的远程调用，并把远程调用结果返回给调用方，这样调用方在调用远程方法的时候就获得了像调用本地接口一样的体验。</p>
<p><img src="/../images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB/image_cSeWjwsfhb.png"></p>
<p>要完成一次RPC调用，就必须先建立网络连接。建立连接后，双方还必须按照某种约定的协议进行网络通信，这个协议就是通信协议。双方能够正常通信后，服务端接收到请求时，需要以某种方式进行处理，处理成功后，把请求结果返回给客户端。为了减少传输的数据大小，还要对数据进行压缩，也就是对数据进行序列化。</p>
<h3 id="1-3-1-客户端和服务端如何建立网络连接？"><a href="#1-3-1-客户端和服务端如何建立网络连接？" class="headerlink" title="1.3.1 客户端和服务端如何建立网络连接？"></a>1.3.1 客户端和服务端如何建立网络连接？</h3><ol>
<li><p>HTTP通信</p>
</li>
<li><p>Socket通信</p>
<p>Socket通信是基于TCP/IP协议的封装，建立一次Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket；另一个运行于服务器端，称为ServerSocket。Socket通信的过程分为四个步骤：服务器监听、客户端请求、连接确认、数据传输。</p>
</li>
</ol>
<h3 id="1-3-2-服务端如何处理请求？"><a href="#1-3-2-服务端如何处理请求？" class="headerlink" title="1.3.2 服务端如何处理请求？"></a>1.3.2 服务端如何处理请求？</h3><p>三种处理方式：</p>
<ul>
<li><p>同步阻塞方式（BIO）：客户端每发一次请求，服务端就生成一个线程去处理。</p>
<p>适用于连接数比较小的业务场景，这样的话不至于系统中没有可用线程去处理请求。这种方式写的程序也比较简单直观，易于理解。</p>
</li>
<li><p>同步非阻塞方式 (NIO)：客户端每发一次请求，服务端并不是每次都创建一个新线程来处理，而是通过I/O多路复用技术进行处理。就是把多个I/O的阻塞复用到同一个select的阻塞上，从而使系统在单线程的情况下可以同时处理多个客户端请求。</p>
<p>适用于连接数比较多并且请求消耗比较轻的业务场景，比如聊天服务器。这种方式相比BIO，相对来说编程比较复杂。</p>
</li>
<li><p>异步非阻塞方式（AIO）：客户端只需要发起一个I/O操作然后立即返回，等I/O操作真正完成以后，客户端会得到I/O操作完成的通知，此时客户端只需要对数据进行处理就好了，不需要进行实际的I/O读写操作，因为真正的I/O读取或者写入操作已经由内核完成了。</p>
<p>适用于连接数比较多而且请求消耗比较重的业务场景，比如涉及I/O操作的相册服务器。这种方式相比另外两种，编程难度最大，程序也不易于理解。</p>
</li>
</ul>
<p>上面两个问题就是“<em><strong>通信框架</strong></em>”要解决的问题，常用开源通信框架有Netty、MINA等</p>
<h3 id="1-3-3-数据传输采用什么协议？"><a href="#1-3-3-数据传输采用什么协议？" class="headerlink" title="1.3.3 数据传输采用什么协议？"></a>1.3.3 数据传输采用什么协议？</h3><ul>
<li>开放协议：如最常用的Http</li>
<li>私有协议：如Dubbo</li>
</ul>
<p>协议的作用就是“约定”。消费者按照约定对数据进行加密传输，提供者按照约定解码数据并进行处理，最后再加密发给消费者。</p>
<h3 id="1-3-4-数据该如何序列化和反序列化？"><a href="#1-3-4-数据该如何序列化和反序列化？" class="headerlink" title="1.3.4 数据该如何序列化和反序列化？"></a>1.3.4 数据该如何序列化和反序列化？</h3><p>常用的序列化方式分为两类：文本类如<code>XML/JSON</code>等，二进制类如<code>PB/Thrift</code>等，而具体采用哪种序列化方式，主要取决于三个方面的因素。</p>
<h2 id="1-4-服务监控"><a href="#1-4-服务监控" class="headerlink" title="1.4 服务监控"></a>1.4 服务监控</h2><p>服务监控的三个关键点：</p>
<h3 id="1-4-1-监控对象"><a href="#1-4-1-监控对象" class="headerlink" title="1.4.1 监控对象"></a>1.4.1 监控对象</h3><ul>
<li>用户端监控</li>
<li>接口监控</li>
<li>资源监控</li>
<li>基础监控</li>
</ul>
<h3 id="1-4-2-监控指标"><a href="#1-4-2-监控指标" class="headerlink" title="1.4.2 监控指标"></a>1.4.2 监控指标</h3><ul>
<li>请求量</li>
<li>响应时间</li>
<li>错误率</li>
</ul>
<h3 id="1-4-3-监控系统原理"><a href="#1-4-3-监控系统原理" class="headerlink" title="1.4.3 监控系统原理"></a>1.4.3 监控系统原理</h3><p>监控系统主要包括四个环节：数据采集、数据传输、数据处理和数据展示</p>
<h4 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a><strong>数据采集</strong></h4><p>通常有两种数据采集方式：</p>
<ul>
<li>服务主动上报</li>
<li>代理收集</li>
</ul>
<h4 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a><strong>数据传输</strong></h4><ul>
<li>UDP传输</li>
<li>Kafka传输</li>
</ul>
<h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a><strong>数据处理</strong></h4><ul>
<li>接口维度聚合</li>
<li>机器维度聚合</li>
</ul>
<p><strong>数据展示</strong></p>
<p>如常见的曲线图、饼状图等等，以Dashboard方式展示给用户</p>
<p>补充：</p>
<p><strong>①监控架构</strong></p>
<blockquote>
<p>下面的图是大部分公司的一种监控架构图。每一个服务都有一个 Agent，Agent 收集到关键信息，会传到一些 MQ 中，为了解耦。</p>
<p>同时将日志传入 ELK，将 Metrics 传入 InfluxDB 时间序列库。而像 Nagios，可以定期向 Agent 发起信息检查微服务。</p>
<p><img src="https://pic4.zhimg.com/v2-2b4b839b0246785af5e3f47872a81987_b.jpg"></p>
</blockquote>
<h2 id="1-5-服务追踪"><a href="#1-5-服务追踪" class="headerlink" title="1.5 服务追踪"></a>1.5 服务追踪</h2><p>服务追踪可以跟踪记录用户的一次请求都发起了哪些调用，经过哪些服务处理，并记录每一次调用所涉及的服务的详细信息。在出现调用失败的时候，就可以第一时间定位到问题出现的地方。</p>
<p><img src="/../images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB/image_jNdoYfL_Si.png"></p>
<h3 id="1-5-1-服务追踪系统原理"><a href="#1-5-1-服务追踪系统原理" class="headerlink" title="1.5.1 服务追踪系统原理"></a>1.5.1 服务追踪系统原理</h3><p>服务追踪系统的鼻祖：Google发布的一篇的论文<a href="http://bigbully.github.io/Dapper-translation/" title="Dapper, a Large-Scale Distributed Systems Tracing Infrastructure">Dapper, a Large-Scale Distributed Systems Tracing Infrastructure</a>，里面详细讲解了服务追踪系统的实现原理。它的核心理念就是<strong>调用链</strong>：通过一个全局唯一的ID将分布在各个服务节点上的同一次请求串联起来，从而还原原有的调用关系，可以追踪系统问题、分析调用数据并统计各种系统指标。</p>
<p>可以说后面的诞生各种服务追踪系统都是基于Dapper衍生出来的，比较有名的有Twitter的<a href="http://zipkin.io/" title="Zipkin">Zipkin</a>、阿里的<a href="http://www.slideshare.net/terryice/eagleeye-with-taobaojavaone" title="鹰眼">鹰眼</a>、美团的<a href="http://tech.meituan.com/mt_mtrace.html" title="MTrace">MTrace</a>等。</p>
<p>基本概念：<code>traceId</code>、<code>spanId</code>、<code>annonation</code></p>
<ul>
<li><code>traceId</code>，用于标识某一次具体的请求ID。当用户的请求进入系统后，会在RPC调用网络的第一层生成一个全局唯一的traceId，并且会随着每一层的RPC调用，不断往后传递，这样的话通过traceId就可以把一次用户请求在系统中调用的路径串联起来。</li>
<li><code>spanId</code>，用于标识一次RPC调用在分布式请求中的位置。当用户的请求进入系统后，处在RPC调用网络的第一层A时spanId初始值是0，进入下一层RPC调用B的时候spanId是0.1，继续进入下一层RPC调用C时spanId是0.1.1，而与B处在同一层的RPC调用E的spanId是0.2，这样的话通过spanId就可以定位某一次RPC请求在系统调用中所处的位置，以及它的上下游依赖分别是谁。</li>
<li><code>annotation</code>，用于业务自定义埋点数据，可以是业务感兴趣的想上传到后端的数据，比如一次请求的用户UID。</li>
</ul>
<p><img src="/../images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB/image_CSQOKCBHqX.png"></p>
<h3 id="1-5-2-服务追踪系统实现"><a href="#1-5-2-服务追踪系统实现" class="headerlink" title="1.5.2 服务追踪系统实现"></a>1.5.2 服务追踪系统实现</h3><p><img src="/../images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB/image_HPN1q5xycN.png"></p>
<ul>
<li>数据采集层，负责数据埋点并上报。</li>
<li>数据处理层，负责数据的存储与计算。</li>
<li>数据展示层，负责数据的图形化展示。</li>
</ul>
<h4 id="1-5-2-1-数据埋点的流程"><a href="#1-5-2-1-数据埋点的流程" class="headerlink" title="1.5.2.1 数据埋点的流程"></a>1.5.2.1 数据埋点的流程</h4><p><img src="/../images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB/image_eKHdGZHbKl.png"></p>
<p>以红色方框里圈出的A调用B的过程为例，一次RPC请求可以分为四个阶段。</p>
<ul>
<li>CS（Client Send）阶段 : 客户端发起请求，并生成调用的上下文。</li>
<li>SR（Server Recieve）阶段 : 服务端接收请求，并生成上下文。</li>
<li>SS（Server Send）阶段 : 服务端返回请求，这个阶段会将服务端上下文数据上报，下面这张图可以说明上报的数据有：<code>traceId=123456，spanId=0.1，appKey=B，method=B.method，start=103，duration=38</code></li>
<li>CR（Client Recieve）阶段 : 客户端接收返回结果，这个阶段会将客户端上下文数据上报，上报的数据有：<code>traceid=123456，spanId=0.1，appKey=A，method=B.method，start=103，duration=38</code></li>
</ul>
<h2 id="1-6-服务治理"><a href="#1-6-服务治理" class="headerlink" title="1.6 服务治理"></a>1.6 服务治理</h2><p>服务调用出现问题：</p>
<ul>
<li>注册中心宕机；</li>
<li>服务提供者有节点宕机；</li>
<li>服务消费者/提供者与注册中心之间的网络不通；</li>
<li>服务消费者和服务提供者之间的网络不通；</li>
</ul>
<h3 id="1-6-1-节点管理"><a href="#1-6-1-节点管理" class="headerlink" title="1.6.1 节点管理"></a>1.6.1 节点管理</h3><ol>
<li>注册中心主动摘除机制</li>
<li>服务消费者摘除机制</li>
</ol>
<h3 id="1-6-2-负载均衡"><a href="#1-6-2-负载均衡" class="headerlink" title="1.6.2 负载均衡"></a>1.6.2 负载均衡</h3><ul>
<li><strong>随机算法</strong></li>
<li><strong>轮询算法</strong></li>
<li><strong>最少活跃调用算法</strong></li>
<li><strong>一致性Hash算法</strong></li>
</ul>
<h1 id="2-DevOps"><a href="#2-DevOps" class="headerlink" title="2 DevOps"></a>2 DevOps</h1><p>传统业务流程：开发→测试→运维</p>
<p>DevOps：</p>
<ul>
<li>CI（Continuous Integration），持续集成。开发完成代码开发后，能自动地进行代码检查、单元测试、打包部署到测试环境，进行集成测试，跑自动化测试用例。</li>
<li>CD（Continuous Deploy），持续部署/持续交付。代码测试通过后，能自动部署到类生产环境中进行集成测试，测试通过后再进行小流量的灰度验证，验证通过后代码就达到线上发布的要求了，就可以把代码自动部署到线上。</li>
</ul>
<p><img src="/../images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB/image_kcPQoyjIJ3.png"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池在业务中的实践以及对应参数如何设计</title>
    <url>/2024/02/03/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9C%A8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5%E4%BB%A5%E5%8F%8A%E5%AF%B9%E5%BA%94%E5%8F%82%E6%95%B0%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<blockquote>
<p>参考：<a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">Java线程池实现原理及其在美团业务中的实践 - 美团技术团队</a></p>
</blockquote>
<h1 id="线程池核心参数"><a href="#线程池核心参数" class="headerlink" title="线程池核心参数"></a>线程池核心参数</h1><ol>
<li>核心线程数<code>corePoolSize</code><br>如果项目有固定的线程开销可以使用核心线程</li>
<li>最大线程<code>maximumPoolSize</code><br>如果项目中多线程的场景不是很多，将线程池中的线程全部设置为普通线程，用完后就释放，减少资源占用</li>
<li>工作队列<code>workQueue</code><br>指定有界或无界队列，队列长度，一般我们选择有界队列，无界队列容易导致OOM</li>
</ol>
<span id="more"></span>

<h3 id="场景一：快速响应用户请求"><a href="#场景一：快速响应用户请求" class="headerlink" title="场景一：快速响应用户请求"></a>场景一：快速响应用户请求</h3><p>场景：需要快速响应的场景，如<strong>首屏加载</strong>、商品详情页加载这种越快越好的场景</p>
<p><strong>应该不设置队列去缓冲并发任务，而是调高<code>corePoolSize</code>和<code>maxPoolSize</code>去尽可能创造多的线程快速执行任务。</strong></p>
<p><img src="/../images/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9C%A8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5%E4%BB%A5%E5%8F%8A%E5%AF%B9%E5%BA%94%E5%8F%82%E6%95%B0%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1/image_dAKT_1wRJI.png"></p>
<h3 id="场景2：快速处理批量任务"><a href="#场景2：快速处理批量任务" class="headerlink" title="场景2：快速处理批量任务"></a>场景2：快速处理批量任务</h3><p><strong>描述</strong>：离线的大量计算任务，需要快速执行。比如说，统计某个报表，需要计算出全国各个门店中有哪些商品有某种属性，用于后续营销策略的分析，那么我们需要查询全国所有门店中的所有商品，并且记录具有某属性的商品，然后快速生成报表。</p>
<p><strong>分析</strong>：这种场景需要执行大量的任务，我们也会希望任务执行的越快越好。这种情况下，也应该使用多线程策略，并行计算。但与响应速度优先的场景区别在于，<strong>这类场景任务量巨大，并不需要瞬时的完成，而是关注如何使用有限的资源，尽可能在单位时间内处理更多的任务，也就是吞吐量优先的问题。</strong>所以<strong>应该设置队列去缓冲并发任务，调整合适的corePoolSize去设置处理任务的线程数</strong>。<strong>在这里，设置的线程数过多可能还会引发线程上下文切换频繁的问题，也会降低处理任务的速度，降低吞吐量。</strong></p>
<p><img src="/../images/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9C%A8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5%E4%BB%A5%E5%8F%8A%E5%AF%B9%E5%BA%94%E5%8F%82%E6%95%B0%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1/image_uK86I9zjp7.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>考虑到在实际应用中我们获取并发性的场景主要是两种：</p>
<ol>
<li>并行执行子任务，提高响应速度。这种情况下，应该使用同步队列，没有什么任务应该被缓存下来，而是应该立即执行</li>
<li>并行执行大批次任务，提升吞吐量。这种情况下，应该使用有界队列，使用队列去缓冲大批量的任务，队列容量必须声明，防止任务无限制堆积。所以线程池只需要提供这三个关键参数的配置，并且提供两种队列的选择，就可以满足绝大多数的业务需求，Less is More</li>
</ol>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>😎手搓一个动态配置管理器</title>
    <url>/2024/07/31/%E6%89%8B%E6%90%93%E4%B8%80%E4%B8%AA%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>最近又在我的论坛项目中造轮子，场景是由于一些业务原因，比如接入了ChatGPT，<code>openai_key</code>可能会频繁的更新，或者添加新的敏感词等等都会造成项目中配置的变化，每次变动都需要修改配置文件并重新部署应用，这样是非常不方便的，动态的更新这些内存中的配置是需要解决的问题。</p>
<p>常见的做法是接入一个配置中心，如Apollo、ZK等等，但是目前项目中是没有用到这些中间件的，接入这些配置中心可能会给项目带来一些风险，况且我这是个单体项目，用这些复杂的配置中心有点大材小用了，再说直接拿来就用没什么意思</p>
<p>鉴于此，我参考了网上和Apollo配置中心的一些技术方案，实现了一个非常实用的配置拓展，支持从自定义数据源中获取配置，并注入到Environment中，且优先级最高，同时也支持配置的动态刷新😎</p>
<span id="more"></span>

<blockquote>
<p>为了更好的理解本文的逻辑，你可能需要以下前置知识点：<a href="/2024/06/21/Spring%20Environment%E4%BD%93%E7%B3%BB/">Spring Environment体系</a></p>
</blockquote>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><u><em><strong>直接说思路：</strong></em></u></p>
<ol>
<li>借助Mysql，维护一个配置表<code>global_config</code>，方便我们构造自定义属性源和持久化用户配置</li>
<li>在Spring启动时，读取数据库中的配置构造一个自定义属性源，注入到<code>Environment</code>中，并设置优先级为最高</li>
<li>再<strong>利用<code>Binder</code>更新</strong>内存中的<code>ConfigurationProperties</code>对象，这样就可以实现覆盖<code>properties</code>文件中的配置</li>
</ol>
<h2 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h2><p>我的项目中配置的使用姿势主要分两种：</p>
<ol>
<li>通过<code>@ConfigurationProperties</code>注入的<code>Property</code>对象</li>
<li>通过<code>@Value</code>注入的配置字段</li>
</ol>
<p>两个部分需要不同的更新方式，因此配置的更新方式分为以下两部分：</p>
<h3 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a><code>@ConfigurationProperties</code></h3><ul>
<li>在初始化阶段：读取数据库中的配置表 → 生成自定义<code>MapPropertySource</code> → <strong>将自定义<code>MapPropertySource</code>添加到Environment中并设置为最高优先级</strong></li>
<li>监听到配置变更：检查DB中的数据库与当前缓存中的<code>MapPropertySource</code>是否一致 ，如果不一致就调用<code>refresh()</code>方法刷新Environment中的<code>MapPropertySource</code>。refresh方法的逻辑其实就是<strong>重新使用Binder绑定内存中的<code>ConfigurationProperties</code></strong></li>
</ul>
<h3 id="Value"><a href="#Value" class="headerlink" title="@Value"></a><code>@Value</code></h3><p>这部分的配置更新参考了<a href="https://github.com/apolloconfig/apollo/pull/972">Apollo PR#972</a>的实现：利用一个<strong>括号匹配</strong>算法，在<code>BeanPostProcessor</code>阶段扫描所有带<code>@Value</code>占位符的Bean，包括表达式、占位符等等，连带对应的Bean引用全部存起来</p>
<p>当有相关的key变化时，通过Bean的引用反射更新对应的Bean字段，你也可以使用观察者模式监听对应的key的变化，就可以做到当配置变化后自动触发对应Bean字段的更新</p>
<blockquote>
<p> 📌 这里两种方式不同是因为<code>@ConfigurationProperties</code>是借助<code>Environment</code>中的属性源实现的，而<code>@Value</code>的实现则是依赖于<code>ConfigurablePropertyResolver</code>，两者虽然都实现了PropertyResolver但是没有任何直接关系，属于不同的属性解析器，因此改变<code>Environment</code>中的属性源并不能影响<code>@Value</code>，需要额外对<code>@Value</code>配置的属性做更新</p>
<p><img src="/../images/Spring%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E9%85%8D%E7%BD%AE/image_env.png"></p>
</blockquote>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>这部分的代码具体实现其实也参考了<code>ConfigurationProperties</code>的注入原理——</p>
<p>（<code>ConfigurationPropertiesBindingPostProcessor</code>）的实现。为了缩减篇幅删除了一些非核心逻辑：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义的动态配置工厂类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> qing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024/8/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicConfigContainer</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span>, InitializingBean, EnvironmentAware, CommandLineRunner {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConfigurableEnvironment environment;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储db中的全局配置，优先级最高</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DynamicConfigBinder binder;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        cache = Maps.newHashMap();</span><br><span class="line">        <span class="built_in">this</span>.binder = <span class="keyword">new</span> <span class="title class_">DynamicConfigBinder</span>(<span class="built_in">this</span>.applicationContext, environment.getPropertySources());</span><br><span class="line">        bindBeansFromLocalCache(<span class="string">"dbConfig"</span>, cache);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从db中获取全量的配置信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 表示有信息变更; false 表示无信息变更</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">loadAllConfigFromDb</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">"select `key`, `value` from global_conf where deleted = 0"</span>;</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; list = applicationContext.getBean(JdbcTemplate.class).queryForList(sql);</span><br><span class="line">        Map&lt;String, Object&gt; val = Maps.newHashMapWithExpectedSize(list.size());</span><br><span class="line">        <span class="keyword">for</span> (Map&lt;String, Object&gt; conf : list) {</span><br><span class="line">            val.put(conf.get(<span class="string">"key"</span>).toString(), conf.get(<span class="string">"value"</span>).toString());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (val.equals(cache)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        cache.clear();</span><br><span class="line">        cache.putAll(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bindBeansFromLocalCache</span><span class="params">(String namespace, Map&lt;String, Object&gt; cache)</span> {</span><br><span class="line">        <span class="comment">// 将内存的配置信息设置为最高优先级</span></span><br><span class="line">        <span class="type">MapPropertySource</span> <span class="variable">propertySource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapPropertySource</span>(namespace, cache);</span><br><span class="line">        environment.getPropertySources().addFirst(propertySource);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Bindable bindable)</span> {</span><br><span class="line">        binder.bind(bindable);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听配置的变更</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reloadConfig</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">before</span> <span class="operator">=</span> JsonUtil.toStr(cache);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">toRefresh</span> <span class="operator">=</span> loadAllConfigFromDb();</span><br><span class="line">        <span class="keyword">if</span> (toRefresh) {</span><br><span class="line">            refreshConfig();</span><br><span class="line">            log.info(<span class="string">"config update! Old:{}, New:{}"</span>, before, JsonUtil.toStr(cache));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持配置的动态刷新</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">refreshConfig</span><span class="params">()</span> {</span><br><span class="line">        applicationContext.getBeansWithAnnotation(ConfigurationProperties.class).values().forEach(bean -&gt; {</span><br><span class="line">            Bindable&lt;?&gt; target = Bindable.ofInstance(bean).withAnnotations(AnnotationUtils.findAnnotation(bean.getClass(), ConfigurationProperties.class));</span><br><span class="line">            bind(target);</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 应用启动之后，执行的动态配置初始化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        reloadConfig();</span><br><span class="line">        <span class="comment">// SpringValueRegistry.updateAll();</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicConfigBinder</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PropertySources propertySources;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Binder binder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicConfigBinder</span><span class="params">(ApplicationContext applicationContext, PropertySources propertySources)</span> {</span><br><span class="line">        <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">        <span class="built_in">this</span>.propertySources = propertySources;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Bindable&lt;T&gt; bindable)</span> {</span><br><span class="line">        <span class="type">ConfigurationProperties</span> <span class="variable">propertiesAno</span> <span class="operator">=</span> bindable.getAnnotation(ConfigurationProperties.class);</span><br><span class="line">        <span class="keyword">if</span> (propertiesAno != <span class="literal">null</span>) {</span><br><span class="line">            <span class="type">BindHandler</span> <span class="variable">bindHandler</span> <span class="operator">=</span> getBindHandler(propertiesAno);</span><br><span class="line">            getBinder().bind(propertiesAno.prefix(), bindable, bindHandler);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(String prefix, Bindable&lt;T&gt; bindable, BindHandler bindHandler)</span> {</span><br><span class="line">        getBinder().bind(prefix, bindable, bindHandler);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BindHandler <span class="title function_">getBindHandler</span><span class="params">(ConfigurationProperties annotation)</span> {</span><br><span class="line">        <span class="type">BindHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IgnoreTopLevelConverterNotFoundBindHandler</span>();</span><br><span class="line">        <span class="keyword">if</span> (annotation.ignoreInvalidFields()) {</span><br><span class="line">            handler = <span class="keyword">new</span> <span class="title class_">IgnoreErrorsBindHandler</span>(handler);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!annotation.ignoreUnknownFields()) {</span><br><span class="line">            <span class="type">UnboundElementsSourceFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnboundElementsSourceFilter</span>();</span><br><span class="line">            handler = <span class="keyword">new</span> <span class="title class_">NoUnboundElementsBindHandler</span>(handler, filter);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参考ConfigurationPropertiesBindingPostProcessor</span></span><br><span class="line">    <span class="keyword">private</span> Binder <span class="title function_">getBinder</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.binder == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) {</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.binder == <span class="literal">null</span>) {</span><br><span class="line">                    <span class="built_in">this</span>.binder = <span class="keyword">new</span> <span class="title class_">Binder</span>(getConfigurationPropertySources(),</span><br><span class="line">                            getPropertySourcesPlaceholdersResolver(), getConversionService(),</span><br><span class="line">                            getPropertyEditorInitializer());</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.binder;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><img src="/../images/Spring%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E9%85%8D%E7%BD%AE/image_Spring%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E9%85%8D%E7%BD%AE.png"></p>
<p>这里就可以看到我们自定义的属性源<code>dbConfig</code>已经被注入成功啦😃</p>
<p>除此之外，当监听到对应的配置更新时，除了更新数据库，还需要推送对应的消息，在这里由于我项目中使用的是Spring Event实现的消息机制，因此监听者的操作如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ConfigRefreshEvent event)</span> {</span><br><span class="line">    dynamicConfigContainer.reloadConfig();</span><br><span class="line">    <span class="comment">// SpringValueRegistry.updateValue(event.getKey());</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>至于<code>@Value</code>的部分，代码比较多就不贴了，具体可以参考在<a href="https://github.com/qing-wq/SAI-Forum-backend/tree/rabbitmq/sai-core/src/main/java/ink/whi/core/autoconf/apollo">https://github.com/qing-wq/SAI-Forum-backend/tree/rabbitmq/sai-core/src/main/java/ink/whi/core/autoconf/apollo</a></p>
<h2 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h2><p>通过上面的操作，很方便的实现了配置动态更新的问题，但是经过实际使用后发现该方案还是存在一些隐患：不统一的配置可能会带来的难以管理的问题</p>
<p>相比于传统的配置管理方案，要么使用统一的注册中心，要么都写在配置文件中，上述方案同时使用两份配置（MySQL和配置文件），会存在优先级问题，可能会造成难以定位的线上Bug。但是对于一个用户量不大的一个小项目来说，该方案能快速实现迭代更新，我认为还是一个不错的选择</p>
<hr>
<blockquote>
<p>写在最后：其实在上文「解决方案」中存在一个问题，就是如果能在<code>PropertySourcesPropertyResolver</code>的配置解析阶段就将自定义的属性源注入，那么初始化后的<code>ConfigurationProperties</code>对象标记的字段本身就是我们自定义数据源中的配置，也就不需要第三步——即启动时用Binder再次更新一遍<code>ConfigurationProperties</code>对象</p>
<p>但我尝试后发现无论如何都无法在解析前将自定义数据源注入到Environment中，因此目前的做法只能在项目完全启动后刷新所有配置（留个坑），如果有大佬知道解决方案欢迎指出🥳<br><img src="/../images/Spring%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E9%85%8D%E7%BD%AE/image_Secure2_Image.png"></p>
</blockquote>
]]></content>
      <categories>
        <category>技术方案</category>
      </categories>
  </entry>
  <entry>
    <title>SpringMVC 处理流程</title>
    <url>/2024/03/12/SpringMVC-%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>先看一下SpringMVC的处理流程：</p>
<p><img src="/../images/SpringMVC-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/image_HJ0Hg7mzst.png"></p>
<p>各个组件的作用：</p>
<ul>
<li><code>DispatcherServlet</code>：分发请求</li>
<li><code>HandlerMapping</code>：根据URL匹配能够处理当前<code>request</code>的<code>Handler</code>（也就是我们的 <code>Controller</code> ）和拦截器</li>
<li><code>HandlerAdapter</code>：负责实际执行<code>Handler</code>的处理方法，并返回<code>ModelAndView</code></li>
<li><code>ViewResolver</code>：将<code>ModelAndView</code>解析为实际的视图</li>
</ul>
<span id="more"></span>

<h2 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h2><ol>
<li><strong>首先用户发送请求 —&gt; DispatcherServlet</strong>，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行 处理，作为统一访问点，进行全局的流程控制；</li>
<li><strong>DispatcherServlet —&gt; HandlerMapping</strong>， HandlerMapping 将会把请求映射为 <code>HandlerExecutionChain</code> 对象（包含Handler 处理器和<code>HandlerInterceptor</code> 拦截器）对象</li>
<li><strong>DispatcherServlet —&gt; HandlerAdapter</strong>，HandlerAdapter 将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理，并返回 ModelAndView；</li>
<li><strong>ModelAndView —&gt; ViewResolver</strong>，ViewResolver 将把ModelAndView中的逻辑视图名解析为具体的 View</li>
<li><strong>View —&gt; 渲染</strong>，View 会根据传进来的 Model 模型数据进行渲染</li>
<li><strong>返回控制权给 DispatcherServlet</strong>，由 DispatcherServlet 返回响应给用户，到此一个流程结束。</li>
</ol>
<hr>
<p>上面的流程有两个关键点：<code>HandlerMapping</code>和<code>HandlerAdapter</code>，<code>HandlerAdapter</code>据说是使用了适配器模式，但具体适配了什么，我一直不知道🤨，直到后面看到了一篇博客才明白。至于它俩的作用，还得从Controller的定义方式说起</p>
<p>SpringMVC中定义Controller的方式有三种：</p>
<ul>
<li><code>@RequestMapping</code>最最最常用的方式，除了这个都不知道其他的了🤣</li>
<li>继承 org.springframework.web.servlet.mvc.Controller接口，大概是这样：</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component("/home")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomeController</span> <span class="keyword">implements</span> <span class="title class_">Controller</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handleRequest</span><span class="params">(HttpServletRequest request, </span></span><br><span class="line"><span class="params">            HttpServletResponse response)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>继承 org.springframework.web.HttpRequestHandler接口</li>
</ul>
<p>不管后面两个怎么实现，总之，他们仨的处理方式是不一样的，需要用到不同的<code>HandlerMapping</code>和<code>HandlerAdapter</code>处理，比如：</p>
<ul>
<li><code>@RequestMapping</code>→<code>RequestMappingHandlerMapping</code>和<code>RequestMappingHandlerAdapter</code></li>
<li><code>Controller</code>接口 → <code>BeanNameUrlHandlerMapping</code>和<code>HttpRequestHandlerAdapter</code></li>
<li><code>HttpRequestHandler</code>接口 → <code>BeanNameUrlHandlerMapping</code>和<code>HttpRequestHandlerAdapter</code></li>
</ul>
<h2 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h2><p><code>HandlerMapping</code>处理后所有的URL和对应的Handler都会被放在一个Map里做映射，这里其实是用了一个<em><strong>策略模式</strong></em>，<u><em><strong>根据Controller定义方式的不同使用不同策略的<code>HandlerMapping</code>去处理</strong></em></u></p>
<p>  <code>HandlerMapping</code> 是一个策略接口，<code>RequestMappingHandlerMapping</code>和<code>BeanNameUrlHandlerMapping</code>是对应的具体策略</p>
<p>  <code>HandlerExecutionChain</code>是一个封装策略的上下文角色</p>
<p>来看一下如何根据<code>request</code>来获取<code>HandlerMapping</code>：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerExecutionChain <span class="title function_">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.handlerMappings != <span class="literal">null</span>) {</span><br><span class="line">      <span class="keyword">for</span> (HandlerMapping mapping : <span class="built_in">this</span>.handlerMappings) {</span><br><span class="line">        <span class="type">HandlerExecutionChain</span> <span class="variable">handler</span> <span class="operator">=</span> mapping.getHandler(request);</span><br><span class="line">        <span class="keyword">if</span> (handler != <span class="literal">null</span>) {</span><br><span class="line">          <span class="keyword">return</span> handler;</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h2><p>说完<code>HandlerMapping</code>之后，下面就要来介绍<code>HandlerAdapter</code>了。</p>
<p>既然<code>Handler</code>有多种实现形式，但是Servlet需要的处理方法的结构却是固定的，都是以<code>request</code>和<code>response</code>作为方法入参，因此<code>HandlerAdapter</code>的实现类都实现了统一的<code>handle()</code>方法来处理Servlet</p>
<p>不过由于上面提到的<code>Handler</code>的形式不同，<u><em><strong><code>@RequestMapping</code>对应的<code>Handler</code>是一个方法，而其他两个对应的<code>Handler</code>是一个类，</strong></em></u>而HandlerAdapter使用了<em><strong>适配器模式</strong></em>能够模糊掉具体的实现，从而就能提供统一访问接口（妙😎）</p>
<p>我们来看一下<code>getHandlerAdapter()</code>方法，注意<code>Handler</code>是Object类型：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerAdapter <span class="title function_">getHandlerAdapter</span><span class="params">(Object handler)</span> </span><br><span class="line">        <span class="keyword">throws</span> ServletException {</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.handlerAdapters != <span class="literal">null</span>) {</span><br><span class="line">    <span class="keyword">for</span> (HandlerAdapter adapter : <span class="built_in">this</span>.handlerAdapters) {</span><br><span class="line">      <span class="keyword">if</span> (adapter.supports(handler)) {</span><br><span class="line">        <span class="keyword">return</span> adapter;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="DispatcherServlet的分发流程"><a href="#DispatcherServlet的分发流程" class="headerlink" title="DispatcherServlet的分发流程"></a>DispatcherServlet的分发流程</h2><p>最后看一下<code>DispatcherServlet#doDispatch()</code>的分发流程，注意<code>DispatcherServlet</code>是如何使用<code>HandlerMapping</code>和<code>HandlerAdapter</code>：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//1、根据URL（当然不一定非得是URL）匹配到一个处理器</span></span><br><span class="line">    mappedHandler = getHandler(processedRequest);</span><br><span class="line">    <span class="keyword">if</span> (mappedHandler == <span class="literal">null</span>) {</span><br><span class="line">      <span class="comment">// 若匹配不到Handler处理器，就404了</span></span><br><span class="line">      noHandlerFound(processedRequest, response);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、从HandlerExecutionChain里拿出Handler，然后找到属于它的适配器</span></span><br><span class="line">    <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//3、执行Handler上的所有拦截器的Pre方法</span></span><br><span class="line">    <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) {</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//4、真正执行handle方法，得到一个ModelAndView</span></span><br><span class="line">    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、视图渲染</span></span><br><span class="line">    applyDefaultViewName(processedRequest, mv);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6、执行拦截器的post方法（视图渲染完成后执行）</span></span><br><span class="line">    mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//7、执行拦截器的afterCompletion方法（不管抛出与否）</span></span><br><span class="line">  }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/zxd1435513775/article/details/103000992">https://blog.csdn.net/zxd1435513775/article/details/103000992</a></li>
</ul>
]]></content>
      <categories>
        <category>Spring源码系列</category>
      </categories>
      <tags>
        <tag>Spring源码阅读</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>凤凰架构-笔记Part1-分布式事务</title>
    <url>/2024/10/12/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<blockquote>
<p>参考：<a href="https://icyfenix.cn/">https://icyfenix.cn/</a></p>
</blockquote>
<h1 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h1><p>我们都知道事务有四大原则：原子性、一致性、隔离性、持久性。具体是如何实现的呢？</p>
<h2 id="实现原子性和持久性"><a href="#实现原子性和持久性" class="headerlink" title="实现原子性和持久性"></a>实现原子性和持久性</h2><p><strong>事务的原子性和持久性实现方式</strong></p>
<ul>
<li>通过日志：常见，主流方案</li>
<li>Shadow Paging（影子分页），SQLite就采用该种方式</li>
</ul>
<p><strong>日志两种实现方式：</strong></p>
<ul>
<li>Commit Logging（提交日志）<ul>
<li>在日志没有提交之前不允许持久化数据，原因是如果事务回滚，那么持久化的数据是错误的</li>
<li>存在的问题：会占用非常多的磁盘缓冲区，严重拖垮效率</li>
</ul>
</li>
<li>Write-Ahead Logging（提前写入）<ul>
<li><p>允许事务未提交就持久化数据，利用undo log实现持久化数据回滚的能力</p>
</li>
<li><p>崩溃恢复步骤：</p>
<p>从最后一次checkpoint（checkpoint之前的所有数据都已经安全落盘）开始扫描日志，将扫描到的事务分为两个队列：</p>
<ul>
<li>Redo list：对于已经提交的事务，按照日志进行重做；</li>
<li>Undo list：对于未提交的事务，将已经执行的操作回滚；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="实现隔离性"><a href="#实现隔离性" class="headerlink" title="实现隔离性"></a>实现隔离性</h2><p>通过加锁</p>
<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>根据ARIES 理论中定义：</p>
<ul>
<li><strong>可串行化</strong>：对事务所有读、写的数据全都加上读锁、写锁和范围锁</li>
<li><strong>可重复读</strong>：对事务所涉及的数据加读锁和写锁，且一直持有至事务结束，但不再加范围锁。<ul>
<li>出现幻读问题<blockquote>
<p>✍🏻MySQL InnoDB 的可重复读级别在只读事务中可以完全避免幻读问题</p>
</blockquote>
</li>
</ul>
</li>
<li><strong>读已提交</strong>：对事务涉及的数据加的写锁会一直持续到事务结束，但加的读锁在查询操作完成后就马上会释放<ul>
<li>不可重复读问题</li>
</ul>
</li>
<li><strong>读未提交</strong>：对事务涉及的数据只加写锁，会一直持续到事务结束，但完全不加读锁。<ul>
<li>脏读问题</li>
</ul>
</li>
</ul>
<p><em><strong>以锁为手段来实现隔离性才是数据库表现出不同隔离级别的根本原因。</strong></em></p>
<h1 id="全局事务XA"><a href="#全局事务XA" class="headerlink" title="全局事务XA"></a>全局事务XA</h1><p>XA（ eXtended Architecture）是最早提出的分布式事务处理架构，其核心内容是定义了全局的事务管理器（Transaction Manager）和局部的资源管理器（Resource Manager，用于驱动本地事务）之间的通信接口</p>
<p>XA 接口是双向的，能在一个事务管理器和多个资源管理器之间形成通信桥梁，通过协调多个数据源的一致动作，实现全局事务的统一提交或者统一回滚。</p>
<p>JAT（<strong>JSR 907 Java Transaction API）</strong>定义了基于 XA 模式在 Java 语言中的实现了全局事务处理的标准。JTA 最主要的两个接口是：</p>
<ul>
<li>事务管理器的接口： <code>javax.transaction.TransactionManager</code> </li>
<li>满足 XA 规范的资源定义接口：<code>javax.transaction.xa.XAResource</code>，任何资源（JDBC、JMS 等等）如果想要支持 JTA，只要实现 XAResource 接口中的方法即可。</li>
</ul>
<p>全局事务建立在<strong>单个服务多个数据源</strong>的场景下，如用户买书，而书店的用户、商家、仓库分别处于不同的数据源中：</p>
<p><img src="/../images/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image_MsOVu4dKys.png"></p>
<h3 id="两段式提交"><a href="#两段式提交" class="headerlink" title="两段式提交"></a>两段式提交</h3><p>XA 将事务提交拆分成为两阶段过程（<em><strong>两段式提交，2 Phase Commit，2PC</strong></em>）：</p>
<ul>
<li><strong>准备阶段</strong>：又叫作投票阶段，在这一阶段，协调者询问事务的所有参与者是否准备好提交，参与者如果已经准备好提交则回复 Prepared，否则回复 Non-Prepared。<ul>
<li><em>这个阶段离真正的提交只差了一个Commit日志记录</em></li>
</ul>
</li>
<li><strong>提交阶段</strong>：又叫作执行阶段<ul>
<li>协调者如果在上一阶段收到所有事务参与者回复的 Prepared 消息，则先自己在本地持久化事务状态为 Commit，完成后向所有参与者发送 Commit 指令，所有参与者立即执行提交操作；<ul>
<li><em>持久化一条 Commit 记录</em></li>
</ul>
</li>
<li>否则，任意一个参与者回复了 Non-Prepared 消息或者超时未回复，协调者将自己的事务状态持久化为 Abort 之后，向所有参与者发送 Abort 指令，参与者立即执行回滚操作。<ul>
<li><em>根据回滚日志清理已提交的数据</em></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/../images/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image_t2l87tkvf3.png"></p>
<p><strong>两段式提交存在的问题</strong></p>
<ul>
<li><p>单点问题：协调者宕机</p>
</li>
<li><p>性能问题：多次服务调用</p>
<p><strong>木桶效应</strong>：准备阶段必须等待所有数据源都返回成功后，协调者才能统一发出 Commit 命令，所有涉及的锁和资源都需要等待到最慢的事务完成后才能统一释放</p>
</li>
<li><p>一致性风险：没有宕机恢复能力。</p>
<p>如果协调者在提交了本地的事务后突然断开，就会导致部分数据（协调者的）已提交，但部分数据（参与者的）既未提交，也没有办法回滚，产生了数据不一致的问题。</p>
</li>
</ul>
<p><em><strong>FLP 不可能原理</strong></em><em>：如果不能保证宕机恢复能力，那就不存在任何一种分布式协议可以正确地达成一致性结果。（我的理解）</em></p>
<h3 id="三段式提交"><a href="#三段式提交" class="headerlink" title="三段式提交"></a>三段式提交</h3><p>三段式提交把准备阶段再细分为两个阶段，分别称为 CanCommit、PreCommit，把提交阶段改称为 DoCommit 阶段。这样做的目的是为了减少两段式中<strong>准备阶段</strong>这一重量操作带来的开销</p>
<ul>
<li><strong>CanCommit</strong>：询问阶段，协调者让每个参与者根据自身状态，评估该事务是否有可能顺利完成。</li>
<li><strong>PreCommit</strong>：准备阶段，准备提交事务</li>
<li><strong>DoCommit</strong>：提交阶段，协调者发送Commit指令</li>
</ul>
<p><img src="/../images/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image_BDrIsTxVGB.png"></p>
<p><strong>三段式提交的影响</strong></p>
<ul>
<li>改善单点问题：如果协调者故障，那么参与者默认会提交事务</li>
<li>减少回滚：先让参与者判断自身是否有能力提交事务，避免故障导致其他参与者做Prepared无用功</li>
<li>一致性问题没有解决，反而加重</li>
</ul>
<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><p>这里特指<strong>多个服务同时访问多个数据源</strong>的事务处理机制</p>
<h2 id="CAP和Base"><a href="#CAP和Base" class="headerlink" title="CAP和Base"></a><strong>CAP和</strong>Base</h2><p>一个分布式的系统中，涉及共享数据问题时，以下三个特性最多只能同时满足其中两个</p>
<ul>
<li>一致性</li>
<li>可用性</li>
<li>分区容忍性</li>
</ul>
<hr>
<ul>
<li>CA架构：意味着假设节点之间的通信永远是可靠的，必定不可能实现<ul>
<li>例子：传统的关系数据库集群，他们不依赖网络实现共享，而是通过日志，如MySQL的bin log</li>
</ul>
</li>
<li>CP架构：一般用于对数据质量很高的场合中<ul>
<li>eg：HBase、前面讨论的全局事务</li>
</ul>
</li>
<li>AP架构：主流选择，放弃强一致性，选择最终一致性</li>
</ul>
<p>最终一致性的起源：<strong>BASE理论</strong></p>
<p>BASE 分别是基本可用性、柔性事务和最终一致性的缩写</p>
<h2 id="可靠事件队列"><a href="#可靠事件队列" class="headerlink" title="可靠事件队列"></a>可靠事件队列</h2><p>可靠消息队列是通过<em><strong>持续重试来保证可靠性</strong></em>的一种方案，也被称为<strong>「最大努力交付」</strong>，如TCP的ACK重传机制</p>
<p>可靠事件队列只要第一步业务完成了，后续就没有失败回滚的概念，只许成功，不许失败。</p>
<p>可靠消息队列虽然能保证最终的结果是相对可靠的，但完全没有隔离性可言，如可能导致「超售」问题</p>
<p><img src="/../images/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image_y2pcU-VxsW.png"></p>
<h2 id="TCC-事务"><a href="#TCC-事务" class="headerlink" title="TCC 事务"></a>TCC 事务</h2><p>TCC （Try-Confirm-Cancel）是另一种常见的分布式事务机制，具有较强的<strong>隔离性</strong></p>
<p>TCC的三个阶段：</p>
<ul>
<li><strong>Try</strong>：尝试执行阶段，完成所有业务可执行性的检查<strong>（保障一致性）</strong>，并且预留好全部需用到的业务资源<strong>（保障隔离性）</strong>。</li>
<li><strong>Confirm</strong>：确认执行阶段，不进行任何业务检查，直接使用 Try 阶段准备的资源来完成业务处理。Confirm 阶段可能会重复执行，需要具备<strong>幂等性</strong>。</li>
<li><strong>Cancel</strong>：取消执行阶段，释放 Try 阶段预留的业务资源。Cancel 阶段也需要满足<strong>幂等性</strong></li>
</ul>
<p><img src="/../images/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image_d3MwlmWL0j.png"></p>
<p>优势：TCC 在业务执行时只操作预留资源，几乎不会涉及锁和资源的争用，具有很高的性能潜力。</p>
<p>缺点：与业务耦合较高</p>
<h2 id="SAGA-事务"><a href="#SAGA-事务" class="headerlink" title="SAGA 事务"></a>SAGA 事务</h2><p>解决TCC第一步无法施行的场景</p>
<blockquote>
<p> 由于中国网络支付日益盛行，现在用户和商家在书店系统中可以选择不再开设充值账号，如果用户、商家的账号余额由银行管理的话，通常无法完成冻结款项、解冻、扣减这样的操作，因为银行一般不会配合你的操作。所以 TCC 中的第一步 Try 阶段往往无法施行。</p>
</blockquote>
<p>SAGA 由两部分操作组成：</p>
<ul>
<li><p>大事务拆分若干个小事务，将整个分布式事务 T 分解为 n 个子事务，命名为 T1，T2，…，Ti，…，Tn。每个子事务都应该是或者能被视为是原子行为。如果分布式事务能够正常提交，其对数据的影响（最终一致性）应与连续按顺序成功提交 Ti等价。</p>
</li>
<li><p>为每一个子事务设计对应的补偿动作，命名为 C1，C2，…，Ci，…，Cn。Ti与 Ci必须满足以下条件：</p>
<ul>
<li><p>Ti与 Ci都具备幂等性。</p>
</li>
<li><p>Ti与 Ci满足交换律，即先执行 Ti还是先执行 Ci，其效果都是一样的。</p>
</li>
<li><p>Ci必须能成功提交，即不考虑 Ci本身提交失败被回滚的情形，如出现就必须持续重试直至成功，或者要人工介入。</p>
</li>
</ul>
</li>
</ul>
<p>如果 T1到 Tn均成功提交，那事务顺利完成，否则，要采取以下两种恢复策略之一：</p>
<ul>
<li><strong>正向恢复</strong>：如果 Ti事务提交失败，则一直对 Ti进行重试，直至成功为止（最大努力交付）。这种恢复方式不需要补偿，适用于事务最终都要成功的场景，譬如在别人的银行账号中扣了款，就一定要给别人发货。正向恢复的执行模式为：T1，T2，…，Ti（失败），Ti（重试）…，Ti+1，…，Tn。</li>
<li><strong>反向恢复</strong>：如果 Ti事务提交失败，则一直执行 Ci对 Ti进行补偿，直至成功为止（最大努力交付）。这里要求 Ci必须（在持续重试后）执行成功。反向恢复的执行模式为：T1，T2，…，Ti（失败），Ci（补偿），…，C2，C1。</li>
</ul>
<p><em><strong>SAGA 必须保证所有子事务都得以提交或者补偿</strong></em></p>
<hr>
<p> GTS的AT事务模式：基于数据补偿来代替回滚的思路</p>
<p>解决了XA 2PC带来的木桶效应</p>
<p>基于这种补偿方式，分布式事务中所涉及的每一个数据源都可以单独提交，然后立刻释放锁和资源。这种异步提交的模式，相比起 2PC 极大地提升了系统的吞吐量水平。而代价就是大幅度地牺牲了隔离性，甚至直接影响到了原子性。因为在缺乏隔离性的前提下，以补偿代替回滚并不一定是总能成功的。譬如，当本地事务提交之后、分布式事务完成之前，该数据被补偿之前又被其他操作修改过，即出现了脏写（Dirty Writ e），这时候一旦出现分布式事务需要回滚，就不可能再通过自动的逆向 SQL 来实现补偿，只能由人工介入处理了。🤨</p>
]]></content>
      <categories>
        <category>分布式理论体系</category>
      </categories>
  </entry>
</search>
