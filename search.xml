<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Bean的生命周期</title>
    <url>/2023/08/31/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p><img src="/../images/bean.svg"></p>
<p><em><strong><u>大致过程：实例化→属性注入→初始化→销毁</u></strong></em></p>
<h1 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h1><ol>
<li>Spring扫描所有的Bean（通过xml配置文件或者注解）得到BeanDefinition</li>
<li>根据得到的BeanDefinition去生成bean<ol>
<li>首先根据class推断构造方法</li>
<li>根据推断出来的构造方法，反射，得到一个对象（暂时叫做<strong>原始对象</strong>）</li>
</ol>
</li>
</ol>
<blockquote>
<p>总结：扫描Bean，获取构造方法并生成原始对象，分配内存空间</p>
</blockquote>
<h1 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h1><p>填充原始对象中的属性（即依赖注入）</p>
<span id="more"></span>

<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><ol>
<li><p><strong>实现了<code>ApplicationContextAware</code>接口</strong>  </p>
<p> 使用ApplicationContext来生成并管理Bean的话，才有此步；否则，没有。  </p>
<p> 如果这个Bean已经实现了ApplicationContextAware接口，会调用<code>setApplicationContext()</code>方法，传入Spring上下文（同样这个方式也可以实现上一步的内容，但比上一步更好，因为ApplicationContext是BeanFactory的子接口，有更多的实现方法）；</p>
</li>
<li><p><strong><code>BeanPostProcessors</code>的<code>ProcessBeforeInitialization()</code></strong></p>
<p> 如果有BeanPostProcessors和Bean关联，那么其<code>postProcessBeforeInitialization()</code>方法将被将被调用。</p>
</li>
<li><p><strong><code>@PostConstruct</code></strong></p>
<p> 这里插入一个不属于Spring的生命周期，但是实际项目中会经常用到的方法。它在执行依赖项注入后被执行，即<strong>构造函数之后，<code>init()</code>方法之前执行</strong></p>
</li>
<li><p><strong><code>initializingBean</code>的<code>afterPropertiesSet()</code></strong></p>
<p> 如果Bean类已实现InitializingBean接口，则执行他的<code>afterProPertiesSet()</code>方法。</p>
</li>
<li><p>Bean的<code>init-method</code>  </p>
</li>
<li><p><strong><code>BeanPostProcessors</code>的<code>ProcessaAfterInitialization()</code></strong></p>
<p> 容器中如果有实现BeanPostProcessors接口的实例，则Bean在初始化之前都会执行这个实例的<code>processAfterInitialization()</code>方法。</p>
</li>
<li><p>如果原始对象中的某个方法被AOP了，那么则需要根据原始对象生成一个代理对象</p>
</li>
<li><p>把最终生成的代理对象放入单例池（源码中叫做<code>singletonObjects</code>）中，下次getBean时就直接从单例池拿即可</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Go generic VS Java generic</title>
    <url>/2024/02/14/Go%20generic%20VS%20Java%20generic/</url>
    <content><![CDATA[<p>随着Go 1.18版本的发布，Go语言正式引入了泛型这一重要特性。本文将对Go泛型与Java泛型进行对比分析，探讨它们之间的异同。</p>
<h2 id="Go泛型概述"><a href="#Go泛型概述" class="headerlink" title="Go泛型概述"></a>Go泛型概述</h2><h3 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h3><h4 id="类型参数"><a href="#类型参数" class="headerlink" title="类型参数"></a>类型参数</h4><p>类型参数是泛型函数或类型中的占位符，表示一个未知的具体类型。类型参数使用方括号<code>[]</code>括起来，并放在函数名或类型名之后。例如，在<code>func MyFunc[T any](a T) {}</code>中，<code>T</code>就是一个类型参数。</p>
<h4 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h4><p>约束是用来限制类型参数的方式，指定了类型参数必须满足的条件。约束可以是接口类型或其他带有类型参数的类型。例如，<code>func MyFunc[T io.Reader](a T) {}</code>中的<code>io.Reader</code>就是一个约束，表示类型参数<code>T</code>必须实现<code>io.Reader</code>接口。</p>
<span id="more"></span>

<h4 id="预定义约束"><a href="#预定义约束" class="headerlink" title="预定义约束"></a>预定义约束</h4><p>Go 1.18提供了一些预定义的约束，用于表示常见的类型集合。例如，<code>any</code>约束表示任何类型，而<code>comparable</code>约束表示可比较的类型（支持<code>==</code>和<code>!=</code>操作符）。</p>
<h4 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h4><p>泛型函数是一种使用类型参数的函数，可以处理不同类型的参数。泛型函数的定义类似于普通函数，只是在函数名后面添加了类型参数列表。例如，<code>func MyFunc[T any](a, b T) T {}</code>。</p>
<h4 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h4><p>泛型类型是一种使用类型参数的类型，可以表示不同类型的数据结构。泛型类型的定义类似于普通类型，只是在类型名后面添加了类型参数列表。例如，<code>type MySlice[T any] []T</code>。</p>
<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><ul>
<li>匿名函数不支持泛型，但可以使用别处定义好的类型作为实参。</li>
<li>不支持泛型方法。</li>
</ul>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>Go的泛型使用<code>interface</code>实现</p>
<ul>
<li>an approximation element <code>~T</code> restricts to all types whose underlying type is T: 代表底层类型是<code>T</code></li>
<li>a union element <code>T1 | T2 | ...</code> restricts to any of the listed elements: 代表<code>或</code>,类型列表之一。</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 任意类型 any</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span>[<span class="title">T1</span>, <span class="title">T2</span> <span class="title">any</span>]<span class="params">(x <span class="type">int</span>, y T1)</span></span> T2 {</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Integer <span class="keyword">interface</span> {</span><br><span class="line">  Signed | Unsigned</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Signed <span class="keyword">interface</span> {</span><br><span class="line">  ~<span class="type">int</span> | ~<span class="type">int8</span> | ~<span class="type">int16</span> | ~<span class="type">int32</span> | ~<span class="type">int64</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Unsigned <span class="keyword">interface</span> {</span><br><span class="line">  ~<span class="type">uint</span> | ~<span class="type">uint8</span> | ~<span class="type">uint16</span> | ~<span class="type">uint32</span> | ~<span class="type">uint64</span> | ~<span class="type">uintptr</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型抽象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span>[<span class="title">T</span> <span class="title">Integer</span>]<span class="params">(input T)</span></span> T {</span><br><span class="line">  <span class="keyword">if</span> input &lt; <span class="number">0</span> {</span><br><span class="line">    <span class="keyword">return</span> -input</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> input</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Java泛型概述"><a href="#Java泛型概述" class="headerlink" title="Java泛型概述"></a>Java泛型概述</h2><p>Java的泛型是在JDK 5中引入的，它的设计目标是为了提高类型安全性和代码重用性。</p>
<h3 id="关键概念-1"><a href="#关键概念-1" class="headerlink" title="关键概念"></a>关键概念</h3><ul>
<li><strong>泛型类型</strong>：定义了一个类型参数，如<code>List&lt;T&gt;</code>。</li>
<li><strong>泛型方法</strong>：可以在方法级别使用类型参数，如<code>public &lt;T&gt; void method(T t)</code>。</li>
<li><strong>类型擦除</strong>：Java编译器会在编译阶段消除类型参数，替换为实际类型，这保证了向后兼容性。</li>
</ul>
<h3 id="限制-1"><a href="#限制-1" class="headerlink" title="限制"></a>限制</h3><ul>
<li>Java泛型支持泛型方法。</li>
<li>Java泛型有类型擦除的概念，这意味着在运行时无法获取类型参数的实际类型。</li>
</ul>
<h2 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h2><h3 id="泛型定义"><a href="#泛型定义" class="headerlink" title="泛型定义"></a>泛型定义</h3><ul>
<li><strong>Go</strong>：类型参数、约束和预定义约束提供了明确的类型约束机制。</li>
<li><strong>Java</strong>：类型参数和泛型方法提供了灵活的类型抽象。</li>
</ul>
<h3 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h3><ul>
<li><strong>Go</strong>：没有类型擦除，泛型类型在运行时保留类型信息。</li>
<li><strong>Java</strong>：存在类型擦除，编译后的字节码不包含类型参数信息。</li>
</ul>
<h3 id="其他特点"><a href="#其他特点" class="headerlink" title="其他特点"></a>其他特点</h3><ul>
<li><strong>Go</strong>：不支持泛型方法，匿名函数不支持泛型。</li>
<li><strong>Java</strong>：支持泛型方法，匿名内部类可以使用泛型。</li>
</ul>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://www.kunkkawu.com/archives/shen-ru-li-jie-golang-de-fan-xing">深入理解Go的泛型</a></li>
<li><a href="https://tonybai.com/2022/03/25/intro-generics/">Go 1.18 泛型入门</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Go语言基础</title>
    <url>/2023/09/01/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li><strong>GOPATH</strong>：代表 Go 语言项目的工作目录，在 Go Module 模式之前非常重要，现在基本上用来存放使用 go get 命令获取的项目。</li>
<li><strong>GOBIN</strong>：代表 Go 编译生成的程序的安装目录，比如通过 go install 命令，会把生成的 Go 程序安装到 GOBIN 目录下，以供你在终端使用。</li>
<li>Go代理：<code>GOPROXY=https://goproxy.cn</code></li>
</ul>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> GOROOT=/usr/local/go </span><br><span class="line"><span class="built_in">export</span> GOPATH=<span class="variable">$HOME</span>/MyDoucument/code/goProject</span><br><span class="line"><span class="built_in">export</span> GOBIN=<span class="variable">$GOPATH</span>/bin</span><br><span class="line"><span class="built_in">export</span> GO111MODULE=on</span><br></pre></td></tr></tbody></table></figure>

<h3 id="编译发布"><a href="#编译发布" class="headerlink" title="编译发布"></a>编译发布</h3><p><code>go build</code>编译生成可执行文件</p>
<p><code>go install</code>把它安装到 <code>$GOBIN</code> 目录或者任意位置</p>
<span id="more"></span>

<h3 id="跨平台编译"><a href="#跨平台编译" class="headerlink" title="跨平台编译"></a>跨平台编译</h3><p>Go 语言通过两个环境变量来控制跨平台编译，它们分别是 <code>GOOS</code> 和 <code>GOARCH</code> 。</p>
<ul>
<li><strong>GOOS</strong>：代表要编译的目标操作系统，常见的有 Linux、Windows、Darwin 等。</li>
<li><strong>GOARCH</strong>：代表要编译的目标处理器架构，常见的有 386、AMD64、ARM64 等。</li>
</ul>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">GOOS=linux GOARCH=amd64 go build ./ch01/main.go</span><br></pre></td></tr></tbody></table></figure>

<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><ul>
<li><strong>有符号整型</strong>：如 <code>int</code>、<code>int8</code>、<code>int16</code>、<code>int32</code> 和 <code>int64</code>。</li>
<li><strong>无符号整型</strong>：如 <code>uint</code>、<code>uint8</code>、<code>uint16</code>、<code>uint32</code> 和 <code>uint64</code>。</li>
</ul>
<p>除了有用“位”（bit）大小表示的整型外，还有 int 和 uint 这两个没有具体 bit 大小的整型，它们的大小可能是 32bit，也可能是 64bit，和硬件设备 CPU 有关。</p>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><ul>
<li><code>float32</code> </li>
<li><code>float64</code></li>
</ul>
<h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><ul>
<li><code>complex64</code></li>
<li><code>complex128</code></li>
</ul>
<p>复数有实部和虚部，<code>complex64</code>的实部和虚部为32位，<code>complex128</code>的实部和虚部为64位</p>
<h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p><code>bool</code></p>
<ul>
<li>布尔类型变量的默认值为false。</li>
<li>Go 语言中不允许将整型强制转换为布尔型.</li>
<li>布尔型无法参与数值运算，也无法与其他类型进行转换</li>
</ul>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>*** Go 语言里的字符串的内部实现使用UTF-8编码，每个字符串的底层都是byte数组***​</p>
<ul>
<li><em><strong>byte：相当于uint8</strong></em></li>
<li><em><strong>rune：相当于int32</strong></em><ul>
<li>Go 使用了特殊 <code>rune</code> 类型来处理 <code>Unicode</code>（复合字符，包括中文、日文等用多字节表示字符）</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//utf-8遍历</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str); i++ {</span><br><span class="line">    ch := str[i]</span><br><span class="line">    fmt.Printf(<span class="string">"%c \n"</span>, ch)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//Unicode遍历</span></span><br><span class="line"><span class="keyword">for</span> _, ch1 := <span class="keyword">range</span> str {</span><br><span class="line">    fmt.Printf(<span class="string">"%c \n"</span>, ch1)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="Array、Slice、Map"><a href="#Array、Slice、Map" class="headerlink" title="Array、Slice、Map"></a>Array、Slice、Map</h2><p><img src="/../images/image_hekea8NFLl.png"></p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">array1:=[<span class="number">5</span>]<span class="type">string</span>{<span class="number">1</span>:<span class="string">"b"</span>,<span class="number">3</span>:<span class="string">"d"</span>}</span><br><span class="line"></span><br><span class="line">slice:=array[start:end]</span><br><span class="line"></span><br><span class="line">slice1:=<span class="built_in">make</span>([]<span class="type">string</span>,<span class="number">4</span>,<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">slice2:=<span class="built_in">append</span>(slice1,<span class="string">"f"</span>)</span><br><span class="line"></span><br><span class="line">nameAgeMap:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">nameAgeMap:=<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>{<span class="string">"飞雪无情"</span>:<span class="number">20</span>}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>📌提示</p>
<p>在创建新切片的时候，最好要让新切片的长度和容量一样，这样在追加操作的时候就会生成新的底层数组，从而和原有数组分离，就不会因为共用底层数组导致修改内容的时候影响多个切片。</p>
</blockquote>
<h2 id="函数和方法"><a href="#函数和方法" class="headerlink" title="函数和方法"></a>函数和方法</h2><p>在 Go 语言中，方法和函数是两个概念，但又非常相似，不同点在于方法必须要有一个接收者，这个接收者是一个类型，这样方法就和这个类型绑定在一起，称为这个类型的方法。</p>
<ul>
<li>函数：正常的代码逻辑</li>
<li>方法：特定类型才有，相当于对象的方法</li>
</ul>
<h3 id="值类型接收者和指针类型接收者"><a href="#值类型接收者和指针类型接收者" class="headerlink" title="值类型接收者和指针类型接收者"></a>值类型接收者和指针类型接收者</h3><ul>
<li>值类型接收者：不会改变原来的对象，相当于操作对象的拷贝</li>
<li>指针类型接收者：通过指针可以获取对象地址，可以直接改变原来的对象</li>
</ul>
<blockquote>
<p>提示：在调用方法的时候，传递的接收者本质上都是副本，只不过一个是这个值的副本，一是指向这个值指针的副本。指针具有指向原有值的特性，所以修改了指针指向的值，也就修改了原有的值。<em><strong>我们可以简单地理解为值接收者使用的是值的副本来调用方法，而指针接收者使用实际的值来调用方法。</strong></em></p>
</blockquote>
<blockquote>
<p>📌值接受者方法不会改变原始结构体实例</p>
</blockquote>
<ul>
<li>如果使用一个值类型变量调用指针类型接收者的方法，Go 语言编译器会自动帮我们取指针调用，以满足指针接收者的要求。</li>
<li>同样的原理，如果使用一个指针类型变量调用值类型接收者的方法，Go 语言编译器会自动帮我们解引用调用，以满足值类型接收者的要求。</li>
</ul>
<h3 id="值类型调用者和指针类型调用者"><a href="#值类型调用者和指针类型调用者" class="headerlink" title="值类型调用者和指针类型调用者"></a>值类型调用者和指针类型调用者</h3><p>在官方effective go文档中，对两者区别描述如下：</p>
<ul>
<li><em><strong>值方法（value methods）可以通过指针和值调用，但是指针方法（pointer methods）只能通过指针来调用</strong></em>** <em>。</em>** ​</li>
<li>但有一个例外，如果某个值是可寻址的（addressable，或者说<em>左值</em>），那么编译器会在值调用指针方法时自动插入取地址符，使得在此情形下看起来像指针方法也可以通过值来调用。</li>
</ul>
<hr>
<p>总结：</p>
<ul>
<li>不管是普通对象还是指针，都可以调用他们的值方法和指针方法，因为编译器会自行处理（语法糖</li>
<li><strong>遇事不决请用pointer method！！！</strong></li>
</ul>
<h3 id="通过变量调用方法"><a href="#通过变量调用方法" class="headerlink" title="通过变量调用方法"></a>通过变量调用方法</h3><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">student := Student(<span class="string">"my name is xiaoming, I am "</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法赋值给变量</span></span><br><span class="line">sm := Student.stu</span><br><span class="line">sm2 := (*Student).stu2</span><br><span class="line">sm(student, <span class="number">2</span>)</span><br><span class="line">sm2(&amp;student)</span><br><span class="line">student.stu(<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="结构体和接口"><a href="#结构体和接口" class="headerlink" title="结构体和接口"></a>结构体和接口</h2><p>结构体定义：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">type Stu <span class="class"><span class="keyword">struct</span>{</span></span><br><span class="line">  name <span class="built_in">string</span></span><br><span class="line">  age <span class="type">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名结构体 变量 </span></span><br><span class="line">var stu <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">  name <span class="built_in">string</span></span><br><span class="line">  age <span class="type">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名结构体变量另一种写法</span></span><br><span class="line">newCar := <span class="keyword">struct</span> {</span><br><span class="line">  Make    <span class="built_in">string</span> `json:<span class="string">"make"</span>`</span><br><span class="line">  Model   <span class="built_in">string</span> `json:<span class="string">"model"</span>`</span><br><span class="line">  Mileage <span class="type">int</span>    `json:<span class="string">"mileage"</span>`</span><br><span class="line">}{}</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyStringer interface</span></span><br><span class="line">type MyStringer interface{</span><br><span class="line">  myString() <span class="built_in">string</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><em><strong>以指针类型接收者实现接口的时候，只有对应的指针类型实例才被认为实现了该接口。</strong></em></p>
<p><img src="/../images/Ciqc1F-yPMSAZ4k7AABU_GW4VxE080_J3w0-tF9PU.png"></p>
<h3 id="工厂函数（构造函数）"><a href="#工厂函数（构造函数）" class="headerlink" title="工厂函数（构造函数）"></a>工厂函数（构造函数）</h3><p>工厂函数一般用于创建自定义的结构体，便于使用者调用</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="type">string</span>)</span></span> *person {</span><br><span class="line">    <span class="keyword">return</span> &amp;person{name:name}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="继承和组合"><a href="#继承和组合" class="headerlink" title="继承和组合"></a>继承和组合</h3><p>在 Go 语言中没有继承的概念，所以结构、接口之间也没有父子关系，Go 语言提倡的是组合，利用组合达到代码复用的目的，这也更灵活。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 组合</span></span><br><span class="line">p:=person{</span><br><span class="line">    age:<span class="number">30</span>,</span><br><span class="line">    name:<span class="string">"飞雪无情"</span>,</span><br><span class="line">    address:address{</span><br><span class="line">        province: <span class="string">"北京"</span>,</span><br><span class="line">        city:     <span class="string">"北京"</span>,</span><br><span class="line">    },</span><br><span class="line">}</span><br><span class="line"><span class="comment">//像使用自己的字段一样，直接使用</span></span><br><span class="line">fmt.Println(p.province)</span><br></pre></td></tr></tbody></table></figure>

<p>类型组合后，外部类型不仅可以使用内部类型的字段，也可以使用内部类型的方法，就像使用自己的方法一样。<br><strong>方法覆写</strong>：如果外部类型定义了和内部类型同样的方法，那么外部类型的会覆盖内部类型，这就是。</p>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>类型断言用来判断一个接口的值是否是实现该接口的某个具体类型。</p>
<p>接口引用拥有断言能力，用于判断当前引用是否属于某个对象的实例</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 接口引用指向子类实例</span></span><br><span class="line"><span class="keyword">var</span> myInterface MyInterface = NewTest(<span class="string">"test"</span>, <span class="number">18</span>, <span class="string">"test"</span>)</span><br><span class="line"><span class="comment">// 判断myInterface是否是Test类型</span></span><br><span class="line"><span class="keyword">if</span> _, ok := myInterface.(*Test);!ok {</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">"myInterface 不是 Test实例"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>在类型断言的时候，同时完成了类型转换</strong></p>
<h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><p>在 Go 语言中，错误是通过内置的 error 接口表示的：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// error 定义</span></span><br><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> {</span><br><span class="line">   Error() <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂函数</span></span><br><span class="line">errors.New(<span class="string">"error"</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong>自定义异常</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> commonError <span class="keyword">struct</span> {</span><br><span class="line">  errorCode <span class="type">int</span>    <span class="comment">//错误码</span></span><br><span class="line">  errorMsg  <span class="type">string</span> <span class="comment">//错误信息</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 实现了Error()就是自定义异常 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ce *commonError)</span></span> Error() <span class="type">string</span> {</span><br><span class="line">  <span class="keyword">return</span> ce.errorMsg</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Error-Wrapping"><a href="#Error-Wrapping" class="headerlink" title="Error Wrapping"></a>Error Wrapping</h3><p>上述自定义异常可以满足我们的需求，但是非常烦琐，因为既要定义新的类型还要实现 error 接口。</p>
<p> Go 语言 1.13 版本开始，Go 标准库新增了 Error Wrapping 功能，让我们可以基于一个存在的 error 生成新的 error，并且可以保留原 error 信息。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// wrap</span></span><br><span class="line">e := errors.New(<span class="string">"原始错误e"</span>)</span><br><span class="line">w := fmt.Errorf(<span class="string">"Wrap了一个错误:%w"</span>, e)</span><br><span class="line">fmt.Println(w)   <span class="comment">// wrap了一个错误:原始错误e</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Unwrap</span></span><br><span class="line">fmt.Println(errors.Unwrap(w))   <span class="comment">// 原始错误e</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="errors-Is"><a href="#errors-Is" class="headerlink" title="errors.Is"></a>errors.Is</h3><p>有了 Error Wrapping 后，你会发现原来用的判断两个 error 是不是同一个 error 的方法失效了，比如 Go 语言标准库经常用到的如下代码中的方式：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">fmt.Println(errors.Is(w, e))  <span class="comment">// true</span></span><br><span class="line">fmt.Println(e == os.ErrExist) <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>errors.ls</code></p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Is</span><span class="params">(err, target <span class="type">error</span>)</span></span> <span class="type">bool</span></span><br></pre></td></tr></tbody></table></figure>

<p>以上就是errors.Is 函数的定义，可以解释为：</p>
<ul>
<li>如果 err 和 target 是同一个，那么返回 true。</li>
<li>如果 err 是一个 wrapping error，target 也包含在这个嵌套 error 链中的话，也返回 true。</li>
</ul>
<blockquote>
<p>📌可以简单地概括为，两个 error 相等或 err 包含 target 的情况下返回 true，其余返回 false。</p>
</blockquote>
<h3 id="errors-As"><a href="#errors-As" class="headerlink" title="errors.As"></a>errors.As</h3><p>同样的原因，有了 error 嵌套后，error 断言也不能用了，因为你不知道一个 error 是否被嵌套，又嵌套了几层。所以 Go 语言为解决这个问题提供了 errors.As 函数，比如前面 error 断言的例子，可以使用  errors.As 函数重写，效果是一样的，如下面的代码所示：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cm *commonError</span><br><span class="line"><span class="keyword">if</span> errors.As(err,&amp;cm){</span><br><span class="line">   fmt.Println(<span class="string">"错误代码为:"</span>,cm.errorCode,<span class="string">"，错误信息为："</span>,cm.errorMsg)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">   fmt.Println(sum)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Deferred"><a href="#Deferred" class="headerlink" title="Deferred"></a>Deferred</h3><p>defer 语句常被用于成对的操作，如文件的打开和关闭，加锁和释放锁，连接的建立和断开等。不管多么复杂的操作，都可以保证资源被正确地释放。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(filename <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) {</span><br><span class="line">   f, err := os.Open(filename)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">defer</span> f.Close()</span><br><span class="line">   <span class="comment">//省略无关代码</span></span><br><span class="line">   <span class="keyword">return</span> readAll(f, n)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>在一个方法或者函数中，可以有多个 defer 语句；</li>
<li>defer 有一个调用栈，多个 defer 语句的执行顺序依照<strong>后进先出</strong>的原则。</li>
</ol>
<h3 id="Panic"><a href="#Panic" class="headerlink" title="Panic"></a>Panic</h3><p>Go 语言是一门静态的强类型语言，很多问题都尽可能地在编译时捕获，但是有一些只能在运行时检查，比如数组越界访问、不相同的类型强制转换等，这类运行时的问题会引起 panic 异常。除了运行时可以产生 panic 外，我们自己也可以抛出 panic 异常。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panic</span><span class="params">(v <span class="keyword">interface</span>{})</span></span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p><code>interface{}</code> 是空接口的意思，在 Go 语言中代表任意类型。</p>
</blockquote>
<p>panic 异常是一种非常严重的情况，会让程序中断运行，使程序崩溃，所以<strong>如果是不影响程序运行的错误，不要使用 panic，使用普通错误 error 即可。</strong></p>
<h4 id="Recover-捕获-Panic-异常"><a href="#Recover-捕获-Panic-异常" class="headerlink" title="Recover 捕获 Panic 异常"></a>Recover 捕获 Panic 异常</h4><p>通常情况下，我们不对 panic 异常做任何处理，因为既然它是影响程序运行的异常，就让它直接崩溃即可。但是也的确有一些特例，比如<strong>在程序崩溃前做一些资源释放的处理</strong>，这时候就需要从 panic 异常中恢复，才能完成处理。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connectMySQL</span><span class="params">(ip, username, password <span class="type">string</span>)</span></span> {</span><br><span class="line">  <span class="keyword">if</span> ip == <span class="string">""</span> {</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"ip不能为空"</span>)</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//省略其他代码</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> {</span><br><span class="line">      fmt.Println(p)</span><br><span class="line">    }</span><br><span class="line">  }()</span><br><span class="line">  connectMySQL(<span class="string">""</span>, <span class="string">"root"</span>, <span class="string">"123456"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="并发基础"><a href="#并发基础" class="headerlink" title="并发基础"></a>并发基础</h1><h2 id="协程（Goroutine）"><a href="#协程（Goroutine）" class="headerlink" title="协程（Goroutine）"></a>协程（Goroutine）</h2><p>Go 语言中没有线程的概念，只有协程，也称为 goroutine。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> function()</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">ch:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>接收：获取 chan 中的值，操作符为<code> &lt;- chan</code>。</li>
<li>发送：向 chan 发送值，把值放在 chan 中，操作符为 <code>chan &lt;-</code>。</li>
</ol>
<h3 id="无缓冲-channel"><a href="#无缓冲-channel" class="headerlink" title="无缓冲 channel"></a><strong>无缓冲 channel</strong></h3><p>无缓冲 channel，它的容量是 0，不能存储任何数据。所以无缓冲 channel 只起到传输数据的作用，数据并不会在 channel 中做任何停留。这也意味着，无缓冲 channel 的发送和接收操作是同时进行的，它也可以称为同步 channel。</p>
<h3 id="有缓冲-channel"><a href="#有缓冲-channel" class="headerlink" title="有缓冲 channel"></a>有缓冲 channel</h3><p>有缓冲 channel 类似一个可阻塞的队列，内部的元素<em><strong>先进先出</strong></em>。通过 make 函数的第二个参数可以指定 channel 容量的大小，进而创建一个有缓冲 channel。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">cacheCh:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">5</span>)</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/../images/CgqCHl-7fzmAVLu0AACSjW-neAE188_KyDQkHLLjx.png"></p>
<p>一个有缓冲 channel 具备以下特点：</p>
<ol>
<li>有缓冲 channel 的内部有一个缓冲队列；</li>
<li>发送操作是向队列的尾部插入元素，如果队列已满，则阻塞等待，直到另一个 goroutine 执行，接收操作释放队列的空间；</li>
<li>接收操作是从队列的头部获取元素并把它从队列中删除，如果队列为空，则阻塞等待，直到另一个 goroutine 执行，发送操作插入新的元素。</li>
</ol>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 获取队列容量和元素个数：</span></span><br><span class="line">fmt.Println(<span class="string">"cacheCh容量为:"</span>,<span class="built_in">cap</span>(cacheCh),<span class="string">",元素个数为："</span>,<span class="built_in">len</span>(cacheCh))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭 channel</span></span><br><span class="line"><span class="built_in">close</span>(cacheCh)</span><br></pre></td></tr></tbody></table></figure>

<p>如果一个 channel 被关闭了，就不能向里面发送数据了，如果发送的话，会引起 painc 异常。但是还可以接收 channel 里的数据，如果 channel 里没有数据的话，接收的数据是元素类型的零值。</p>
<h3 id="单向-channel"><a href="#单向-channel" class="headerlink" title="单向 channel"></a>单向 channel</h3><p>有时候，我们有一些特殊的业务需求，比如限制一个 channel 只可以接收但是不能发送，或者限制一个 channel 只能发送但不能接收，这种 channel 称为单向 channel。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">onlySend := <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span><br><span class="line">onlyReceive:=<span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="select-多路复用"><a href="#select-多路复用" class="headerlink" title="select 多路复用"></a>select 多路复用</h3><blockquote>
<p>小提示：多路复用可以简单地理解为，N 个 channel 中，任意一个 channel 有数据产生，select 都可以监听到，然后执行相应的分支，接收数据并处理。</p>
</blockquote>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> {</span><br><span class="line">   <span class="keyword">case</span> i1 = &lt;-c1:</span><br><span class="line">     <span class="comment">//todo</span></span><br><span class="line">   <span class="keyword">case</span> c2 &lt;- i2:</span><br><span class="line">     <span class="comment">//todo</span></span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">     <span class="comment">// default todo</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="sync-包"><a href="#sync-包" class="headerlink" title="sync 包"></a>sync 包</h2><blockquote>
<p>小技巧：使用 go build、go run、go test 这些 Go 语言工具链提供的命令时，添加 <code>-race</code> 标识可以帮你检查 Go 语言代码是否存在资源竞争。</p>
</blockquote>
<h3 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a><strong>sync.Mutex</strong></h3><p>互斥锁，顾名思义，指的是在同一时刻只有一个协程执行某段代码，其他协程都要等待该协程执行完毕后才能继续执行。</p>
<p>Mutex 的 <code>Lock</code> 和 <code>Unlock</code> 方法总是成对出现，而且要确保 Lock 获得锁后，一定执行 UnLock 释放锁</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>(</span><br><span class="line">   sum <span class="type">int</span></span><br><span class="line">   mutex sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(i <span class="type">int</span>)</span></span> {</span><br><span class="line">   mutex.Lock()</span><br><span class="line">   sum += i</span><br><span class="line">   mutex.Unlock()</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>小提示：以上被加锁保护的 sum+=i 代码片段又称为<strong>临界区</strong>。在同步的程序设计中，临界区段指的是一个访问共享资源的程序片段，而这些共享资源又有无法同时被多个协程访问的特性。</p>
</blockquote>
<h3 id="sync-RWMutex"><a href="#sync-RWMutex" class="headerlink" title="sync.RWMutex"></a>sync.RWMutex</h3><p>go中的读写锁。使用：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mutex sync.RWMutex</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readSum</span><span class="params">()</span></span> <span class="type">int</span> {</span><br><span class="line"></span><br><span class="line">   <span class="comment">//只获取读锁</span></span><br><span class="line">   mutex.RLock()</span><br><span class="line">   <span class="keyword">defer</span> mutex.RUnlock()</span><br><span class="line">   b:=sum</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h3><p>相当于Java中的***<code>CountDownLatch</code>** *，用于最终完成的场景，关键点在于一定要等待所有协程都执行完毕。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">   <span class="comment">//因为要监控110个协程，所以设置计数器为110</span></span><br><span class="line">   wg.Add(<span class="number">110</span>)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ {</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">         <span class="comment">//计数器值减1</span></span><br><span class="line">         <span class="keyword">defer</span> wg.Done()</span><br><span class="line">         add(<span class="number">10</span>)</span><br><span class="line">      }()</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>;i++ {</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">         <span class="comment">//计数器值减1</span></span><br><span class="line">         <span class="keyword">defer</span> wg.Done()</span><br><span class="line">         fmt.Println(<span class="string">"和为:"</span>,readSum())</span><br><span class="line">      }()</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">//一直等待，直到计数器值为0</span></span><br><span class="line">   wg.Wait()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h3><p>让代码只执行一次，哪怕是在高并发的情况下，比如创建一个单例。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">   doOnce()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doOnce</span><span class="params">()</span></span> {</span><br><span class="line">   <span class="keyword">var</span> once sync.Once</span><br><span class="line">   onceBody := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">      fmt.Println(<span class="string">"Only once"</span>)</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">//用于等待协程执行完毕</span></span><br><span class="line">   done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//启动10个协程执行once.Do(onceBody)</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">         <span class="comment">//把要执行的函数(方法)作为参数传给once.Do方法即可</span></span><br><span class="line">         once.Do(onceBody)</span><br><span class="line">         done &lt;- <span class="literal">true</span></span><br><span class="line">      }()</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">      &lt;-done</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="sync-Cond"><a href="#sync-Cond" class="headerlink" title="sync.Cond"></a>sync.Cond</h3><p>sync.Cond 可以用于发号施令，一声令下所有协程都可以开始执行，关键点在于协程开始的时候是等待的，要等待 sync.Cond 唤醒才能执行。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//10个人赛跑，1个裁判发号施令</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">race</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">   cond :=sync.NewCond(&amp;sync.Mutex{})</span><br><span class="line">   <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">   wg.Add(<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>; i++ {</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(num <span class="type">int</span>)</span></span> {</span><br><span class="line">         <span class="keyword">defer</span>  wg.Done()</span><br><span class="line">         fmt.Println(num,<span class="string">"号已经就位"</span>)</span><br><span class="line">         cond.L.Lock()</span><br><span class="line">         cond.Wait()<span class="comment">//等待发令枪响</span></span><br><span class="line">         fmt.Println(num,<span class="string">"号开始跑……"</span>)</span><br><span class="line">         cond.L.Unlock()</span><br><span class="line">      }(i)</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">//等待所有goroutine都进入wait状态</span></span><br><span class="line">   time.Sleep(<span class="number">2</span>*time.Second)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">      <span class="keyword">defer</span>  wg.Done()</span><br><span class="line">      fmt.Println(<span class="string">"裁判已经就位，准备发令枪"</span>)</span><br><span class="line">      fmt.Println(<span class="string">"比赛开始，大家准备跑"</span>)</span><br><span class="line">      cond.Broadcast()<span class="comment">//发令枪响</span></span><br><span class="line">   }()</span><br><span class="line">   <span class="comment">//防止函数提前返回退出</span></span><br><span class="line">   wg.Wait()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><strong>Wait</strong>，阻塞当前协程，直到被其他协程调用 Broadcast 或者 Signal 方法唤醒，使用的时候需要加锁，使用 sync.Cond 中的锁即可，也就是 L 字段。</li>
<li><strong>Signal</strong>，唤醒一个等待时间最长的协程。</li>
<li><strong>Broadcast</strong>，唤醒所有等待的协程。</li>
</ol>
<blockquote>
<p>注意：在调用 Signal 或者 Broadcast 之前，要确保目标协程处于 Wait 阻塞状态，不然会出现死锁问题。</p>
</blockquote>
<p>如果你以前学过 Java，会发现 sync.Cond 和 Java 的等待唤醒机制很像，它的三个方法 Wait、Signal、Broadcast 就分别对应 Java 中的 wait、notify、notifyAll。</p>
<h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><blockquote>
<p>一个任务会有很多个协程协作完成，一次 HTTP 请求也会触发很多个协程的启动，而这些协程有可能会启动更多的子协程，并且无法预知有多少层协程、每一层有多少个协程。</p>
<p>如果因为某些原因导致任务终止了，HTTP 请求取消了，那么它们启动的协程怎么办？该如何取消呢？因为取消这些协程可以节约内存，提升性能，同时避免不可预料的 Bug。</p>
<p>Context 就是用来简化解决这些问题的，并且是并发安全的。Context 是一个接口，它具备手动、定时、超时发出取消信号、传值等功能，主要用于控制多个协程之间的协作，尤其是取消操作。一旦取消指令下达，那么被 Context 跟踪的这些协程都会收到取消信号，就可以做清理和退出操作。</p>
</blockquote>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> {</span><br><span class="line"></span><br><span class="line">   Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">   Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{}</span><br><span class="line">   Err() <span class="type">error</span></span><br><span class="line">   Value(key <span class="keyword">interface</span>{}) <span class="keyword">interface</span>{}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Context-树"><a href="#Context-树" class="headerlink" title="Context 树"></a>Context 树</h3><p>Go 语言提供了函数可以帮助我们生成不同的 Context，通过这些函数可以生成一颗 Context 树，这样 Context 才可以关联起来，父 Context 发出取消信号的时候，子 Context 也会发出，这样就可以控制不同层级的协程退出。</p>
<p>从使用功能上分，有四种实现好的 Context。</p>
<ol>
<li><strong>空 Context</strong>：不可取消，没有截止时间，主要用于 Context 树的根节点。</li>
<li><strong>可取消的 Context</strong>：用于发出取消信号，当取消的时候，它的子 Context 也会取消。</li>
<li><strong>可定时取消的 Context</strong>：多了一个定时的功能。</li>
<li><strong>值 Context</strong>：用于存储一个 key-value 键值对。</li>
</ol>
<p><img src="/../images/CgqCHl_EyHOARbBqAAKzKmhclWo807_A5KZtclRKo.png"></p>
<p><code> context.Background()</code>获取一个根节点 Context。</p>
<hr>
<p> Context 树要怎么生成呢？</p>
<ol>
<li>**<code>WithCancel(parent Context)</code>**：生成一个可取消的 Context。<ol>
<li>**<code>WithDeadline(parent Context, d time.Time)</code>**：生成一个可定时取消的 Context，参数 d 为定时取消的具体时间。<ol>
<li>**<code>WithTimeout(parent Context, timeout time.Duration)</code>**：生成一个可超时取消的 Context，参数 timeout 用于设置多久后取消</li>
</ol>
</li>
</ol>
</li>
<li>**<code>WithValue(parent Context, key, val interface{})</code>**：生成一个可携带 key-value 键值对的 Context。</li>
</ol>
<p>以上四个生成 Context 的函数中，前三个都属于可取消的 Context，它们是一类函数，最后一个是值 Context，用于存储一个 key-value 键值对。</p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    name:=<span class="string">"xiaoming"</span></span><br><span class="line">    <span class="keyword">var</span> nameP *<span class="type">string</span> = &amp;name</span><br><span class="line">    fmt.Println(*nameP)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>获取一个变量的指针非常容易，使用取地址符 &amp; 就可以</p>
</li>
<li><p>指针类型就是在对应的类型前加 * 号</p>
</li>
<li><p>指针类型非常廉价，只占用 4 个或者 8 个字节的内存大小。</p>
</li>
<li><p><em><strong>通过 var 声明的指针变量还没有分配内存</strong></em>，因为这时候它仅仅是个变量，是不能直接赋值和取值的，它的值是 nil </p>
<p><img src="/../images/image_t8e3mEYUbE.png" alt="直接赋值和取值" title="直接赋值和取值"></p>
<p>解决方法：将一块内存地址<code>&amp;m</code>赋值给指针变量<code>*p</code></p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> m <span class="type">int</span></span><br><span class="line">p = &amp;m</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>通过new创建的指针是存在内存地址的，可以直接赋值</p>
<ul>
<li><code>var intP *int = new(int)</code></li>
</ul>
</li>
</ul>
<h1 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h1><p><strong>严格来说，Go 语言没有引用类型</strong>，但是我们可以把 map、chan 称为引用类型，这样便于理解。除了 map、chan 之外，Go 语言中的函数、接口、slice 切片、指针都可以称为引用类型。</p>
<p><img src="/../images/image_trx0_Qi29q.png"></p>
<p>总结：</p>
<p>在 Go 语言中，<strong>函数的参数传递只有值传递</strong>，而且传递的实参都是原始数据的一份拷贝。</p>
<p>如果拷贝的内容是值类型的，那么在函数中就无法修改原始数据；</p>
<p>如果拷贝的内容是指针（或者可以理解为引用类型 map、chan 等），那么就可以在函数中修改原始数据。</p>
<h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1><ul>
<li>指针类型的变量如果没有分配内存，就默认是零值 nil，它没有指向的内存，所以无法使用，强行使用就会得到以上 nil 指针错误</li>
<li>对于值类型来说，即使只声明一个变量，没有对其初始化，该变量也会有分配好的内存。</li>
<li>两个关键函数：new和make</li>
</ul>
<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>new 函数只用于分配内存，并且把内存清零，也就是返回一个指向对应类型零值的指针。new 函数一般用于需要显式地返回指针的情况，不是太常用。</p>
<h2 id="make"><a href="#make" class="headerlink" title="make"></a>make</h2><p>make 函数只用于 slice、chan 和 map 这三种内置类型的创建和初始化，因为这三种类型的结构比较复杂，比如 slice 要提前初始化好内部元素的类型，slice 的长度和容量等，这样才可以更好地使用它们。</p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><ul>
<li><p><strong><code>reflect.Value</code></strong> 和**<code>reflect.Type</code>**</p>
<p>在 Go 语言的反射定义中，任何接口都由两部分组成：接口的具体类型，以及具体类型对应的值。比如 var i int = 3，因为 <code>interface{}</code> 可以表示任何类型，所以变量 i 可以转为 interface{}。其中 Value 为变量的值，即 3，而 Type 为变量的类型，即 int。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">i:=<span class="number">3</span></span><br><span class="line">iv:=reflect.ValueOf(i)</span><br><span class="line">it:=reflect.TypeOf(i)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>修改变量</p>
<p>要修改一个变量的值，有几个关键点：传递指针（可寻址），通过 Elem 方法获取指向的值，才可以保证值可以被修改，reflect.Value 为我们提供了 CanSet 方法判断是否可以修改该变量。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">ipv := reflect.ValueOf(&amp;i)</span><br><span class="line">ipv.Elem().SetInt(<span class="number">4</span>)</span><br><span class="line">fmt.Println(i)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>反射的三大定律</p>
<ol>
<li>任何接口值 <code>interface{}</code> 都可以反射出反射对象，也就是 reflect.Value 和 reflect.Type，通过函数 reflect.ValueOf 和 reflect.TypeOf 获得。</li>
<li>反射对象也可以还原为 interface{} 变量，也就是第 1 条定律的可逆性，通过 reflect.Value 结构体的 Interface 方法获得。</li>
<li>要修改反射的对象，该值必须可设置，也就是可寻址，参考上节课修改变量的值那一节的内容理解。</li>
</ol>
</li>
</ul>
<h1 id="SliceHeader"><a href="#SliceHeader" class="headerlink" title="SliceHeader"></a>SliceHeader</h1><ul>
<li><p>在 Go 语言中，切片其实是一个结构体，定义如下：</p>
<p><img src="/../images/image_X_Cyk8TKPo.png"></p>
<p>SliceHeader 是切片在运行时的表现形式，它有三个字段 Data、Len 和 Cap。</p>
<ol>
<li>Data 用来指向存储切片元素的数组。</li>
<li>Len 代表切片的长度。</li>
<li>Cap 代表切片的容量。</li>
</ol>
</li>
<li><p>优点</p>
<ol>
<li>支持动态扩容</li>
<li>切片的本质是 SliceHeader，又因为函数的参数是值传递，所以传递的是 SliceHeader 的副本，而不是底层数组的副本。这时候切片的优势就体现出来了，因为 SliceHeader 的副本内存占用非常少，即使是一个非常大的切片，也顶多占用 24 个字节的内存，这就解决了大数组在传参时内存浪费的问题。</li>
</ol>
</li>
</ul>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ul>
<li>测试文件以_test.go结尾</li>
<li>测试函数以Testxxx（xxx为测试函数名）开头</li>
</ul>
<p>假设编写的函数在<em>ch18/main.go</em>中：<code>go test -v ./ch18</code></p>
<hr>
<ul>
<li>go test -v –coverprofile=ch18.cover ./ch18：得到一个单元测试覆盖率文件</li>
</ul>
<h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h2><p>衡量代码的性能</p>
<ul>
<li><p>函数必须以 Benchmark 开头</p>
</li>
<li><p>函数的签名必须接收一个指向 testing.B 类型的指针，并且不能返回任何值；</p>
</li>
<li><p>最后的 for 循环很重要，被测试的代码要放到循环里；</p>
</li>
<li><p>b.N 是基准测试框架提供的，表示循环的次数，因为需要反复调用测试的代码，才可以评估性能。</p>
</li>
<li><p>运行：<code>go test -bench=. ./ch18</code></p>
<p><img src="/../images/image_JlVijZWatR.png"></p>
</li>
<li><p>计时方法</p>
<p><img src="/../images/image_01f3cRZXVK.png"></p>
</li>
<li><p>内存统计</p>
<p><img src="/../images/image_0VABPfND_h.png"></p>
</li>
<li><p>并发基准测试</p>
<p><img src="/../images/image_KLlXB9vavX.png"></p>
</li>
</ul>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>Go的泛型使用<code>interface</code>实现</p>
<ul>
<li>an approximation element <code>~T</code> restricts to all types whose underlying type is T: 代表底层类型是<code>T</code></li>
<li>a union element <code>T1 | T2 | ...</code> restricts to any of the listed elements: 代表<code>或</code>,类型列表之一。</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 任意类型 any</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span>[<span class="title">T1</span>, <span class="title">T2</span> <span class="title">any</span>]<span class="params">(x <span class="type">int</span>, y T1)</span></span> T2 {</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Integer <span class="keyword">interface</span> {</span><br><span class="line">  Signed | Unsigned</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Signed <span class="keyword">interface</span> {</span><br><span class="line">  ~<span class="type">int</span> | ~<span class="type">int8</span> | ~<span class="type">int16</span> | ~<span class="type">int32</span> | ~<span class="type">int64</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Unsigned <span class="keyword">interface</span> {</span><br><span class="line">  ~<span class="type">uint</span> | ~<span class="type">uint8</span> | ~<span class="type">uint16</span> | ~<span class="type">uint32</span> | ~<span class="type">uint64</span> | ~<span class="type">uintptr</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型抽象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span>[<span class="title">T</span> <span class="title">Integer</span>]<span class="params">(input T)</span></span> T {</span><br><span class="line">  <span class="keyword">if</span> input &lt; <span class="number">0</span> {</span><br><span class="line">    <span class="keyword">return</span> -input</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> input</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>LangChain入门笔记</title>
    <url>/2024/03/27/LangChain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>基本架构</p>
<p><img src="/../images/langchain_stack_dark_NdLaDhZn28.svg"></p>
<span id="more"></span>

<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>LangChain是一个用于开发由语言模型驱动的应用程序的框架。</p>
<p>主要功能：</p>
<ul>
<li><p>调用语言模型</p>
</li>
<li><p>将不同数据源接入到语言模型的交互中</p>
</li>
<li><p>允许语言模型与运行环境交互</p>
</li>
</ul>
<p>LangChain中提供的模块</p>
<ul>
<li><p>Modules：支持的模型类型和集成。</p>
</li>
<li><p>Prompt：提示词管理、优化和序列化。</p>
</li>
<li><p>Memory：内存是指在链/代理调用之间持续存在的状态。</p>
</li>
<li><p>Indexes：当语言模型与特定于应用程序的数据相结合时，会变得更加强大-此模块包含用于加载、查询和更新外部数据的接口和集成。</p>
</li>
<li><p>Chain：链是结构化的调用序列（对LLM或其他实用程序）。</p>
</li>
<li><p>Agents：代理是一个链，其中LLM在给定高级指令和一组工具的情况下，反复决定操作，执行操作并观察结果，直到高级指令完成。</p>
</li>
<li><p>Callbacks：回调允许您记录和流式传输任何链的中间步骤，从而轻松观察、调试和评估应用<br>程序的内部。</p>
</li>
</ul>
</blockquote>
<p>应用场景：</p>
<ul>
<li>文档问答</li>
<li>个人助理</li>
<li>查询数据表格（CSV、SQL、DataFrame等）</li>
<li>与API交互</li>
<li>信息提取</li>
<li>文档总结</li>
</ul>
<h1 id="Model-I-O"><a href="#Model-I-O" class="headerlink" title="Model I/O"></a>Model I/O</h1><p>四个核心组件：</p>
<ul>
<li>Prompts 提示词</li>
<li>Chat Models 聊天模型<ul>
<li>擅长对话</li>
</ul>
</li>
<li>LLMs 纯文本模型<ul>
<li>擅长理解和合成文本方面，例如总结文档、PDF、概念页面等</li>
</ul>
</li>
<li>Output parsers 输出转换器</li>
</ul>
<blockquote>
<p>📌Chat Models 和 LLMs 的区别：</p>
<p>Chat models和LLMs都是LangChain中的语言模型抽象，但是LLMs是纯语言模型，Chat models是针对对话做了优化的聊天模型</p>
</blockquote>
<h1 id="Agents"><a href="#Agents" class="headerlink" title="Agents"></a>Agents</h1><blockquote>
<p>大型语言模型（LLMs）非常强大，但它们缺乏“最笨”的计算机程序可以轻松处理的特定能力。LLM 对逻辑推理、计算和检索外部信息的能力较弱，这与最简单的计算机程序形成对比。例如，语言模型无法准确回答简单的计算问题，还有当询问最近发生的事件时，其回答也可能过时或错误，因为无法主动获取<br>最新信息。这是由于当前语言模型仅依赖预训练数据，与外界“断开”。要克服这一缺陷， LangChain 框<br>架提出了 “代理”(Agent) 的解决方案。</p>
</blockquote>
<p>Agent作为语言模型的外部模块，可提供计算、逻辑、检索等功能的支持，使语言模型获得异常强大的推理和获取信息的超能力。</p>
<hr>
<p>Agents的核心思想是使用语言模型来选择要采取的一系列Action</p>
<p>在langchain中，一系列Action被硬编码（在代码中）。</p>
<p>在Agents中，语言模型被用作推理引擎来确定要采取哪些操作以及按什么顺序。</p>
<p>不同Agents的区别：不同的推理提示风格、不同的编码输入方式以及不同的解析输出方式。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h3><p>构建代理的核心组件</p>
<ul>
<li><code>AgentAction</code> 即Action，表示代理执行的操作，通常表示调用tools<ul>
<li>我们将想让对Agents的操作封装成Action（tools），再让Agents在被调用时选择应该使用哪些tools</li>
<li>在<code>AgentAction</code>中有两个属性：<code>tool</code>和<code>tool_input</code>，分别代表工具的名字和工具输入</li>
</ul>
</li>
<li><code>AgentFinish</code>  Agents返回的最终结果</li>
<li><code>Intermediate Steps</code> 中间步骤。代表<code>AgentAction</code>以及当前Agents运行的相应输出</li>
</ul>
<h3 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h3><ul>
<li><code>Agent Inputs</code> Agents的输入，键值对类型<ul>
<li>required：<code>intermediate_steps</code></li>
</ul>
</li>
<li><code>Agent Outputs</code> Agents的响应，分为<code>Union[AgentAction, List[AgentAction], AgentFinish]</code><ul>
<li>输出解析器负责获取原始 LLM 输出并将其转换为这三种类型之一</li>
</ul>
</li>
</ul>
<p>demo：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">agent = (</span><br><span class="line">    {</span><br><span class="line">        <span class="string">"input"</span>: <span class="keyword">lambda</span> x: x[<span class="string">"input"</span>],</span><br><span class="line">        <span class="string">"agent_scratchpad"</span>: <span class="keyword">lambda</span> x: format_to_openai_tool_messages(</span><br><span class="line">            x[<span class="string">"intermediate_steps"</span>]</span><br><span class="line">        ),</span><br><span class="line">    }</span><br><span class="line">    | prompt</span><br><span class="line">    | llm_with_tools</span><br><span class="line">    | OpenAIToolsAgentOutputParser()</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>

<h4 id="Agents-API"><a href="#Agents-API" class="headerlink" title="Agents API"></a>Agents API</h4><ul>
<li><code>AgentExecutor</code> 重复调用Agents并执行工具<ul>
<li>封装了各种错误处理、日志等</li>
</ul>
</li>
</ul>
<h3 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h3><p>工具是代理可以调用​​的功能。 <code>Tool</code> 抽象由两个组件组成：</p>
<p>工具 API 的目标是比使用通用文本完成或聊天 API 更可靠地返回有效且有用的工具调用。</p>
<ul>
<li>schema</li>
<li>function</li>
</ul>
<p>设计Agents的关键：</p>
<ul>
<li>让Agents正确的使用tools</li>
<li>以对代理最有帮助的方式描述工具</li>
</ul>
<h2 id="Agent-Type"><a href="#Agent-Type" class="headerlink" title="Agent Type"></a>Agent Type</h2><p>介绍几个常用的Agent Type</p>
<p>ReAct：LLM 可以循环进行 Reasoning 和 Action 步骤的过程。它启用了一个多步骤的过程来识别答案。</p>
<h1 id="Prompt"><a href="#Prompt" class="headerlink" title="Prompt"></a>Prompt</h1><p>提示词工程和模型微调的区别：</p>
<ul>
<li><p>微调</p>
<ul>
<li>定义：针对预先训练的语言模型，在特定任务的少量数据集上对其进行进一步训练</li>
<li>适用场景：当任务或域定义明确，并且有足够的标记数据可供训练时，通常使用微调过程</li>
</ul>
</li>
<li><p>提示词工程</p>
<ul>
<li>涉及设计自然语言提示或指令，可以指导语言模型执行特定任务</li>
<li>最适合需要高精度和明确输出的任务。提示工程可用于制作引发所需输出的查询</li>
</ul>
</li>
</ul>
<h1 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h1><p><img src="/../images/memory_diagram-0627c68230aa438f9b5419064d63cbbc_eZ.png"></p>
<p>四种主要储存模块：</p>
<ul>
<li><code>ConversationBufferMemory</code>对话缓存</li>
<li><code>ConversationTokenBufferMemory</code>按窗口缓存</li>
<li><code>ConversationTokenBufferMemory</code>按令牌缓存</li>
<li><code>ConversationSummaryBufferMemory</code>按摘要缓存</li>
</ul>
<p>最常见的内存类型之一涉及返回聊天消息列表。这些可以作为单个字符串返回，全部连接在一起（当它们被传递到 LLMs 时有用）或 ChatMessages 列表（当传递到 ChatModels 时有用）。</p>
<p>默认情况下，它们作为单个字符串返回。为了作为消息列表返回，您可以设置 <code>return_messages=True</code></p>
<p><img src="/../images/image_96cXegtOz-.png"></p>
<h1 id="Chains"><a href="#Chains" class="headerlink" title="Chains"></a>Chains</h1><p>链是指调用序列 - 即 LLM、Tools还是数据预处理步骤的先后顺序。主要支持的方法是使用 LCEL。</p>
<h2 id="LCEL-Chains"><a href="#LCEL-Chains" class="headerlink" title="LCEL Chains"></a>LCEL Chains</h2><p>LangChain Expression Language（LCEL）可以轻松地从基本组件构建复杂的链，并支持开箱即用的功能，例如流式传输、并行性和日志记录，最基本和常见的用例是将Prompt和LLM链接在一起。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">chain = prompt | model | output_parser</span><br></pre></td></tr></tbody></table></figure>

<p><a href="https://python.langchain.com/v0.1/docs/expression_language/get_started/" title="https://python.langchain.com/v0.1/docs/expression_language/get_started/">https://python.langchain.com/v0.1/docs/expression_language/get_started/</a></p>
<p>意义：组合大模型调用中不相关的部分，让开发者省去胶水代码</p>
<p>下面举一些简单的栗子：</p>
<p>模型调用：</p>
<p><img src="/../images/image_tamQ_03vHR.png"></p>
<p>Stream流：</p>
<p><img src="/../images/image_UPmDNoWd_p.png"></p>
<p>Batch批处理：</p>
<p><img src="/../images/image_JliK3KA3oM.png"></p>
<p>异步调用：</p>
<p><img src="/../images/image_Gf01np9mh3.png"></p>
<h1 id="RAG"><a href="#RAG" class="headerlink" title="RAG"></a>RAG</h1><p>全称Retrieval Augmented Generation (RAG)</p>
<p><img src="/../images/data_connection-95ff2033a8faa5f3ba41376c0f6dd32a_P.jpg"></p>
<p>核心组件：</p>
<ul>
<li><strong>Document loaders</strong>文档加载器</li>
<li>Text Splitting文本分割器，将大文档分割（或分块）为更小的块。</li>
<li>Text Embedding models嵌入模型，用于将文档嵌入到Vector stores中，主要有两种常用方式：<ul>
<li>text2vector</li>
<li>llm</li>
</ul>
</li>
<li>Retrievers检索器，用于在数据源中检索相关信息</li>
<li>Indexing数据库索引，用于检索</li>
</ul>
<h2 id="Retrievers检索"><a href="#Retrievers检索" class="headerlink" title="Retrievers检索"></a>Retrievers检索</h2><p>相关算法：</p>
<ul>
<li><p>基本语义相似度（Basicsemanticsimilarity)</p>
</li>
<li><p>最大边际相关性（Maximummarginalrelevance，MMR)</p>
</li>
<li><p>过滤元数据</p>
</li>
<li><p>LLM辅助检索 SelfQueryRetriever</p>
</li>
<li><p>压缩 ContextualCompressionRetriever</p>
<ul>
<li>工作原理：先使用标准向量检索获得候选文档，然后基于查询语句的语义，使用语言模型压缩这些文档,只保留与问题相关的部分<br><img src="/../images/image_cehTwhXkXE.png"></li>
</ul>
</li>
</ul>
<p>其他类型的检索：</p>
<p>vetordb 并不是唯一一种检索文档的工具。 LangChain 还提供了其他检索文档的方式，例如： TF-IDF 或 SVM 。</p>
<h2 id="对话检索链"><a href="#对话检索链" class="headerlink" title="对话检索链"></a>对话检索链</h2><h3 id="检索链类型"><a href="#检索链类型" class="headerlink" title="检索链类型"></a>检索链类型</h3><p>通过LangChain创建一个检索问答链，对检索到的文档进行问题回答。检索问答链的输入包含以下</p>
<ul>
<li>llm大语言模型</li>
<li><code>chain_type</code>指定传入链（用于将文档传递到 LLM 的上下文窗口中）类型<ul>
<li><strong>Stuff</strong>：只需将所有文档“塞”到一个提示中即可，这是最简单的方法<ul>
<li>API：create_stuff_documents_chain</li>
</ul>
</li>
<li><strong>Map-reduce</strong>：将所有块与问题一起传递给语言模型，获取回复，使用另一个语言模型调用将所有单独的回复总结成最终答案，它可以在任意数量的文档上运行。可以并行处理单个问题，同时也需要更多的调用。它将所有文档视为独立的<ul>
<li>MapReduceDocumentsChain</li>
</ul>
</li>
<li><strong>Refine</strong><ul>
<li>循环许多文档，实际上是迭代的，建立在先前文档的答案之上，非常适合前后因果信息并随时间逐步构建答案，依赖于先前调用的结果。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/../images/summarization_use_case_2-f2a4d5d60980a79140085fb7f.png" alt="Stuff和MapReduce区别" title="Stuff和MapReduce区别"></p>
<p><img src="/../images/image_kuqREZwJrr.png"></p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.chains.combine_documents.stuff <span class="keyword">import</span> StuffDocumentsChain</span><br><span class="line"><span class="keyword">from</span> langchain.chains.llm <span class="keyword">import</span> LLMChain</span><br><span class="line"><span class="keyword">from</span> langchain_core.prompts <span class="keyword">import</span> PromptTemplate</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define prompt</span></span><br><span class="line">prompt_template = <span class="string">"""Write a concise summary of the following:</span></span><br><span class="line"><span class="string">"{text}"</span></span><br><span class="line"><span class="string">CONCISE SUMMARY:"""</span></span><br><span class="line">prompt = PromptTemplate.from_template(prompt_template)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define LLM chain</span></span><br><span class="line">llm = ChatOpenAI(temperature=<span class="number">0</span>, model_name=<span class="string">"gpt-3.5-turbo-16k"</span>)</span><br><span class="line">llm_chain = LLMChain(llm=llm, prompt=prompt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define StuffDocumentsChain</span></span><br><span class="line">stuff_chain = StuffDocumentsChain(llm_chain=llm_chain, document_variable_name=<span class="string">"text"</span>)</span><br><span class="line"></span><br><span class="line">docs = loader.load()</span><br><span class="line"><span class="built_in">print</span>(stuff_chain.run(docs))</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>LLM</category>
      </categories>
      <tags>
        <tag>langchain</tag>
      </tags>
  </entry>
  <entry>
    <title>Spingboot3.0 升级记录</title>
    <url>/2024/06/21/Spingboot3.0%20%E5%8D%87%E7%BA%A7%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<blockquote>
<p><strong>背景</strong>：在原来一个基于 Spring Boot 2.6.11 的项目中，引入了一个第三方库后，发现无法正常加载其自动装配的 Bean。经过排查，发现第三方库基于 Spring Boot 3.2.4 版本开发，存在依赖注入方式上的差异。为了兼容性，决定将原项目升级至 Spring Boot 3.2.4。鉴于 Spring Boot 3.0 的重大变化，本文详细记录了迁移过程中遇到的关键改动及解决方案。</p>
</blockquote>
<h2 id="Spring-Boot-3-0-主要改动"><a href="#Spring-Boot-3-0-主要改动" class="headerlink" title="Spring Boot 3.0 主要改动"></a>Spring Boot 3.0 主要改动</h2><p>以下是 Spring Boot 3.0 中最重要的变动：</p>
<ul>
<li><strong>最低 Java 版本要求</strong>：升级至 Java 17。</li>
<li><strong>移除内置配置</strong>：例如，MySQL 驱动等配置被移除，官方提供迁移工具协助升级：</li>
</ul>
<span id="more"></span>

<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-properties-migrator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>Jakarta EE 替代 Java EE</strong>：所有 <code>javax</code> 包被替换为 <code>jakarta</code> 包：</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">javax.persistence.*   -&gt; jakarta.persistence.*</span><br><span class="line">javax.validation.*    -&gt; jakarta.validation.*</span><br><span class="line">javax.servlet.*       -&gt; jakarta.servlet.*</span><br><span class="line">javax.annotation.*    -&gt; jakarta.annotation.*</span><br><span class="line">javax.transaction.*   -&gt; jakarta.transaction.*</span><br></pre></td></tr></tbody></table></figure>

<p>更多改动详情，参考官方文档：<a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Release-Notes">Spring Boot 3.0 发布说明</a></p>
<h2 id="项目迁移中发现的问题"><a href="#项目迁移中发现的问题" class="headerlink" title="项目迁移中发现的问题"></a>项目迁移中发现的问题</h2><h3 id="自定义-Starter-不兼容"><a href="#自定义-Starter-不兼容" class="headerlink" title="自定义 Starter 不兼容"></a>自定义 Starter 不兼容</h3><p>原版本中自定义 Starter 的方式为：在扫描类上使用 <code>@Configuration</code> 注解，并在 <code>META-INF/spring.factories</code> 文件中声明该扫描类：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">{{启动类路径}}</span><br></pre></td></tr></tbody></table></figure>

<p>新版中，自定义 Starter 应采用 <code>@AutoConfiguration</code> 注解，并在 <code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code> 文件中声明扫描类：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">{{启动类路径}}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Mybatis-兼容性问题"><a href="#Mybatis-兼容性问题" class="headerlink" title="Mybatis 兼容性问题"></a>Mybatis 兼容性问题</h3><p><img src="/../images/Secure2%20Image.png" alt="Secure2 Image"></p>
<p><strong>原因</strong>：Mybatis 旧版本与 Spring Boot 3.0 不兼容，需升级至 Mybatis 3.x 版本或更高。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>🐛 LangChain4j-Spring Bug修复记录</title>
    <url>/2024/08/20/LangChain4j-Spring%20Bug/</url>
    <content><![CDATA[<p>起因：在使用langchain4j的过程中发现，项目默认只会扫描启动类下的带有<code>@AiService</code>的接口， 并且扫描的方式是通过<code>Reflections</code>扫描启动类所在的classPath而不是通过Spring自带的方法</p>
<p>如果使用<code>@ComponentScan</code>扫描特定的文件路径，那么特定路径下的<code>@AiService</code>接口将不会被扫描并被代理到，最后就导致了Bean无法注入的Bug _(:з」∠)_</p>
<h2 id="相关issue"><a href="#相关issue" class="headerlink" title="相关issue"></a>相关issue</h2><ul>
<li><a href="https://github.com/langchain4j/langchain4j/issues/1606">https://github.com/langchain4j/langchain4j/issues/1606</a></li>
<li><a href="https://github.com/langchain4j/langchain4j-spring/pull/35">https://github.com/langchain4j/langchain4j-spring/pull/35</a></li>
</ul>
<blockquote>
<p><em>Tips</em>：这也是我第一次参加开源，虽然只是做了一个微不足道的贡献，但是还是感觉收获很多吧…一直在担心自己的水平不够所以反复理解反复查资料，但是作者很热心帮我修改了代码并且很快就被处理接受了😃</p>
</blockquote>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>在Springboot中使用<code>context/beanFactory</code>获取带有<code>@AiService</code>的Bean，发现Springboot会自动忽略接口，原因在于<strong>Spring是不会扫描接口的，因为接口没有办法实例化</strong>，因此作者的做法为：</p>
<ol>
<li><code>Reflections</code>扫描当前启动类所在的classPath获取带有<code>@AiService</code>的接口</li>
<li>在<code>BeanFactoryPostProcessor</code>阶段（Bean加载完但还未创建任何Bean实例前），使用<code>AiServiceFactory</code>替换接口的BeanDefinition完成代理替换</li>
</ol>
<p>关键代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Set&lt;Class&lt;?&gt;&gt; findAiServices(ConfigurableListableBeanFactory beanFactory) {</span><br><span class="line">    String[] applicationBean = beanFactory.getBeanNamesForAnnotation(SpringBootApplication.class);</span><br><span class="line">    <span class="type">BeanDefinition</span> <span class="variable">applicationBeanDefinition</span> <span class="operator">=</span> beanFactory.getBeanDefinition(applicationBean[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">String</span> <span class="variable">basePackage</span> <span class="operator">=</span> applicationBeanDefinition.getResolvableType().resolve().getPackage().getName();</span><br><span class="line">    <span class="type">Reflections</span> <span class="variable">reflections</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reflections</span>((<span class="keyword">new</span> <span class="title class_">ConfigurationBuilder</span>()).forPackage(basePackage));</span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; classes = reflections.getTypesAnnotatedWith(AiService.class);</span><br><span class="line">    classes.removeIf(clazz -&gt; !clazz.getName().startsWith(basePackage));</span><br><span class="line">    <span class="keyword">return</span> classes;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>针对以上问题，我在PR中做的主要改动如下：</p>
<h2 id="改动1：获取所有的ComponentScan的basePackage并扫描"><a href="#改动1：获取所有的ComponentScan的basePackage并扫描" class="headerlink" title="改动1：获取所有的ComponentScan的basePackage并扫描"></a>改动1：获取所有的ComponentScan的basePackage并扫描</h2><p>既然需要扫描多个模块，扫描的方式也是通过<code>@ComponentScan</code>指定的，那么就获取所有的<code>@ComponentScan</code>指定的扫描路径进行扫描吧：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Set&lt;String&gt; <span class="title function_">getBasePackages</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> {</span><br><span class="line">  Set&lt;String&gt; basePackages = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  List&lt;String&gt; autoConfigPackages = AutoConfigurationPackages.get(beanFactory);</span><br><span class="line">  basePackages.addAll(autoConfigPackages);</span><br><span class="line">  </span><br><span class="line">  String[] beanNames = beanFactory.getBeanNamesForAnnotation(ComponentScan.class);</span><br><span class="line">  <span class="keyword">for</span> (String beanName : beanNames) {</span><br><span class="line">      Class&lt;?&gt; beanClass = beanFactory.getType(beanName);</span><br><span class="line">      <span class="keyword">if</span> (beanClass != <span class="literal">null</span>) {</span><br><span class="line">          <span class="type">ComponentScan</span> <span class="variable">componentScan</span> <span class="operator">=</span> beanClass.getAnnotation(ComponentScan.class);</span><br><span class="line">          <span class="keyword">if</span> (componentScan != <span class="literal">null</span>) {</span><br><span class="line">              Collections.addAll(basePackages, componentScan.value());</span><br><span class="line">              Collections.addAll(basePackages, componentScan.basePackages());</span><br><span class="line">              <span class="keyword">for</span> (Class&lt;?&gt; basePackageClass : componentScan.basePackageClasses()) {</span><br><span class="line">                  basePackages.add(ClassUtils.getPackageName(basePackageClass));</span><br><span class="line">              }</span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="改动2：自定义ClassPathBeanDefinitionScanner扫描接口"><a href="#改动2：自定义ClassPathBeanDefinitionScanner扫描接口" class="headerlink" title="改动2：自定义ClassPathBeanDefinitionScanner扫描接口"></a>改动2：自定义ClassPathBeanDefinitionScanner扫描接口</h2><p>如果是要与Spring集成的话肯定是使用Spring的方法更好，但是Spring自带的类扫描器会直接过滤接口，因此在这里自定义了一个专用于扫描接口的类扫描器</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassPathAiServiceScanner</span> <span class="keyword">extends</span> <span class="title class_">ClassPathBeanDefinitionScanner</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClassPathAiServiceScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="type">boolean</span> useDefaultFilters)</span> {</span><br><span class="line">        <span class="built_in">super</span>(registry, useDefaultFilters);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isCandidateComponent</span><span class="params">(AnnotatedBeanDefinition beanDefinition)</span> {</span><br><span class="line">        <span class="keyword">return</span> beanDefinition.getMetadata().isInterface() &amp;&amp; beanDefinition.getMetadata().isIndependent();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>那么问题来了，如何让Spring使用我们自定义的类扫描器呢？Spring自带的扫描器都是在<code>@ComponentScan</code>解析流程中创建出来的，我们又不能更改这个流程</p>
<p>但是我们可以在Spring的扫描流程结束后，再扫描一遍不就好了吗？于是这里在<code>postProcessBeanDefinitionRegistry</code>阶段重新进行了一次扫描：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AiServiceScannerProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException {</span><br><span class="line">        <span class="type">ClassPathAiServiceScanner</span> <span class="variable">classPathAiServiceScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathAiServiceScanner</span>(registry, <span class="literal">false</span>);</span><br><span class="line">        classPathAiServiceScanner.addIncludeFilter(<span class="keyword">new</span> <span class="title class_">AnnotationTypeFilter</span>(AiService.class));</span><br><span class="line">        Set&lt;String&gt; basePackages = getBasePackages((ConfigurableListableBeanFactory) registry);</span><br><span class="line">        classPathAiServiceScanner.scan(StringUtils.toStringArray(basePackages));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里的解决方案其实也参考了MyBatis的实现：MyBatis通过<code>@Mapper</code>即可将类注入到Spring中，原理正是在于使用了自定义类扫描器<code>ClassPathMapperScanner</code>扫描所有带有<code>@Mapper</code>和<code>@MapperScan</code>指定的路径，详细过程可以参考 <a href="./Mybatis%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8Cbean%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F.md">Mybatis实现动态注册bean的两种方式</a></p>
<hr>
<p>参考：</p>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1962431">https://cloud.tencent.com/developer/article/1962431</a></li>
<li><a href="https://blog.csdn.net/qq_31086797/article/details/124488829">https://blog.csdn.net/qq_31086797/article/details/124488829</a></li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>langchain4j</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis实现动态注册bean的两种方式</title>
    <url>/2024/03/26/Mybatis%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8Cbean%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>我们都知道MyBatis可以通过<code>@MapperScanner</code>和<code>@Mapper</code>两种方法将Mapper注入到Spring容器中，本文介绍MyBatis如何实现动态注册Bean的两种方式的实现原理，以便在其他类似的场景作为参考。</p>
<h2 id="MyBatis代理DAO接口类过程"><a href="#MyBatis代理DAO接口类过程" class="headerlink" title="MyBatis代理DAO接口类过程"></a>MyBatis代理DAO接口类过程</h2><p>先看一下MyBatis代理Bean的过程：</p>
<ul>
<li><code>MapperScannerConfigurer</code>核心配置类<ul>
<li><code>MapperScannerConfigurer#postProcessBeanDefinitionRegistry</code>负责在Bean注册后扫描调用<code>ClassPathMapperScanner</code>全部的Mapper</li>
</ul>
</li>
<li><code>ClassPathMapperScanner</code>类扫描器，继承自<code>ClassPathBeanDefinitionScanner</code>，负责在classPath中扫描所有的继承了Mapper的DAO接口，对扫描到的Mapper接口进行封装<ul>
<li>封装方式：使用<code>MapperFactoryBean</code>替换接口的<code>BeanDefinition</code>，会把<code>sqlSessionFactory</code>，<code>sqlSessionTemplate</code>等参数传递给<code>MapperFactoryBean</code>，从而创建<code>SqlSession</code>(<code>SqlSessionTemplate</code>)，通过<code>getObject()</code>返回代理类</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="动态注册Bean"><a href="#动态注册Bean" class="headerlink" title="动态注册Bean"></a>动态注册Bean</h2><p>那么<code>MapperScannerConfigurer</code>扫描的路径、参数、是否懒加载等配置是在什么时候注入的呢？不同的MyBatis使用姿势实现的方式不同：</p>
<ul>
<li><code>@MapperScan</code><ul>
<li>通过<code>ImportBeanDefinitionRegistrar</code>注入<code>MapperScannerRegistrar</code>，其中<code>ImportBeanDefinitionRegistrar</code>也是Spring官方动态注册bean的常用套路</li>
<li><code>MapperScannerRegistrar</code>中构造了<code>MapperScannerConfigurer</code>，配置了<code>MapperScannerConfigurer</code>的基本属性，如basePackage、annotationClass等等</li>
</ul>
</li>
<li><code>@Mapper</code><ul>
<li><code>@Mapper</code>的扫描逻辑在<code>AutoConfiguredMapperScannerRegistrar</code>（通过自动装配注入），在不使用<code>@MapperScanner</code>指定扫描路径的情况下只会扫描启动类所在的classPath</li>
<li>同上，<code>AutoConfiguredMapperScannerRegistrar</code>中构造了<code>MapperScannerConfigurer</code>并进行属性注入</li>
</ul>
</li>
</ul>
<hr>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/qq_31086797/article/details/124488829">https://blog.csdn.net/qq_31086797/article/details/124488829</a></li>
<li><a href="https://cofcool.github.io/tech/2018/06/20/mybatis-sourcecode-1#11-mapper%E6%89%AB%E6%8F%8F">https://cofcool.github.io/tech/2018/06/20/mybatis-sourcecode-1</a></li>
</ul>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
  </entry>
  <entry>
    <title>Spring中几个关键的后置处理器以及执行顺序</title>
    <url>/2024/05/26/Spring%E4%B8%AD%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E7%9A%84%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BB%A5%E5%8F%8A%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="BeanDefinitionRegistryPostProcessor"><a href="#BeanDefinitionRegistryPostProcessor" class="headerlink" title="BeanDefinitionRegistryPostProcessor"></a>BeanDefinitionRegistryPostProcessor</h2><p>作用时机：<strong>在所有 BeanDefinition被加载后执行，但在<code>BeanFactoryPostProcessor</code>之前</strong>。 </p>
<p>常见应用: 动态注册新的 bean 定义、修改或移除已有的 BeanDefinition。</p>
<h2 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h2><p>BeanFactory标准初始化之后，所有的BeanDefinition已经被加载，但标准Bean的实例还没被创建（不包括<code>BeanFactoryPostProcessor</code>类型）。该方法通常用于修改BeanDefinition，Bean的属性值等，甚至可以在此快速初始化Bean。</p>
<h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h2><p>作用时机：Bean初始化前后</p>
<p><code>BeanPostProcessors#ProcessBeforeInitialization()</code>在Bean初始化前调用</p>
<p><code>BeanPostProcessors#ProcessaAfterInitialization()</code>在Bean初始化后调用</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>📌 Spring实现自定义配置注入&amp;动态更新</title>
    <url>/2024/07/31/Spring%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>最近又在我的论坛项目中造轮子，场景是由于一些业务原因，比如接入了ChatGPT，openai_key可能会频繁的更新，或者添加新的敏感词等等都会造成项目中配置的变化，每次变动都需要修改配置文件并重新部署应用，这样是非常不方便的，动态的更新这些内存中的配置是需要解决的问题。</p>
<p>常见的做法是接入一个配置中心，如Apollo、ZK等等，但是目前项目中是没有用到这些中间件的，接入这些配置中心可能会给项目带来一些风险，况且我这是个单体项目，用这些复杂的配置中心有点大材小用了，再说直接拿来就用没什么意思</p>
<p>鉴于此，我参考了网上和Apollo配置中心的一些技术方案，实现了一个非常实用的配置拓展，支持从自定义数据源中获取配置，并注入到Environment中，且优先级最高，同时也支持配置的动态刷新</p>
<span id="more"></span>

<blockquote>
<p>为了更好的理解本文的逻辑，你可能需要以下前置知识点：<a href="/2024/06/21/Spring%20Environment%E4%BD%93%E7%B3%BB/">Spring Environment体系</a></p>
</blockquote>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><strong>直接说思路</strong>：<u>借助Mysql，维护一个配置表<code>global_config</code>，原因是方便构造自定义数据源和持久化用户配置，在Spring启动时读取数据库中的数据构造为我们自定义的属性源，并设置为首要，再利用<code>Binder</code>更新内存中的<code>ConfigurationProperties</code>对象和 <code>@Value</code>标记的字段，这样就可以实现覆盖<code>properties</code>文件中的配置</u></p>
<blockquote>
<p>其实这里存在一个问题，就是如果能在<code>PropertySourcesPropertyResolver</code>的配置解析阶段就将自定义的属性源注入，那么初始化后的<code>ConfigurationProperties</code>对象和 <code>@Value</code>标记的字段本身就是我们自定义数据源中的配置，但我尝试后发现无论如何都无法在解析前将自定义数据源注入到Environment中，于是只能在项目完全启动后刷新所有配置<br><img src="/../images/image_Secure2_Image.png"></p>
</blockquote>
<h2 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h2><p>我的项目中配置的使用姿势主要分两种：</p>
<ol>
<li>通过<code>@ConfigurationProperties</code>注入的<code>Property</code>对象</li>
<li>通过<code>@Value</code>注入的配置字段</li>
</ol>
<p>两个部分需要不同的更新方式，因此配置的更新方式分为两部分：</p>
<h3 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a><code>@ConfigurationProperties</code></h3><ul>
<li>在初始化阶段：读取数据库中的配置表 → 生成自定义<code>MapPropertySource</code> →** 将自定义****<code>MapPropertySource</code>**<strong>添加到Environment中并设置为最高优先级</strong></li>
<li>监听到配置变更：检查DB中的数据库与当前缓存中的<code>MapPropertySource</code>是否一致 ，如果不一致就调用refresh方法刷新Environment中的<code>MapPropertySource</code>。refresh方法的逻辑其实就是<strong>重新使用Binder绑定内存中的<code>ConfigurationProperties</code></strong></li>
</ul>
<h3 id="Value"><a href="#Value" class="headerlink" title="@Value"></a><code>@Value</code></h3><p>这部分的配置更新参考了<strong>Apollo</strong>的实现：利用一个<strong>括号匹配</strong>算法，在<code>BeanPostProcessor</code>阶段扫描所有带<code>@Value</code>占位符的Bean，包括表达式、占位符等等，连带对应的Bean引用全部存起来</p>
<p>当有相关的key变化时，通过Bean的引用反射更新对应的Bean字段，你也可以使用观察者模式监听对应的key的变化，就可以做到当配置变化后自动触发对应Bean字段的更新</p>
<blockquote>
<p><a href="https://github.com/apolloconfig/apollo/pull/972">https://github.com/apolloconfig/apollo/pull/972</a></p>
</blockquote>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>这部分的代码具体实现其实也参考了<code>ConfigurationProperties</code>的注入原理——<code>ConfigurationPropertiesBindingPostProcessor</code>的实现。为了缩减篇幅删除了一些非核心逻辑：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义的动态配置工厂类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> qing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024/8/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicConfigContainer</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span>, InitializingBean, EnvironmentAware, CommandLineRunner {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConfigurableEnvironment environment;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储db中的全局配置，优先级最高</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DynamicConfigBinder binder;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        cache = Maps.newHashMap();</span><br><span class="line">        <span class="built_in">this</span>.binder = <span class="keyword">new</span> <span class="title class_">DynamicConfigBinder</span>(<span class="built_in">this</span>.applicationContext, environment.getPropertySources());</span><br><span class="line">        bindBeansFromLocalCache(<span class="string">"dbConfig"</span>, cache);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从db中获取全量的配置信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 表示有信息变更; false 表示无信息变更</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">loadAllConfigFromDb</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">"select `key`, `value` from global_conf where deleted = 0"</span>;</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; list = applicationContext.getBean(JdbcTemplate.class).queryForList(sql);</span><br><span class="line">        Map&lt;String, Object&gt; val = Maps.newHashMapWithExpectedSize(list.size());</span><br><span class="line">        <span class="keyword">for</span> (Map&lt;String, Object&gt; conf : list) {</span><br><span class="line">            val.put(conf.get(<span class="string">"key"</span>).toString(), conf.get(<span class="string">"value"</span>).toString());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (val.equals(cache)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        cache.clear();</span><br><span class="line">        cache.putAll(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bindBeansFromLocalCache</span><span class="params">(String namespace, Map&lt;String, Object&gt; cache)</span> {</span><br><span class="line">        <span class="comment">// 将内存的配置信息设置为最高优先级</span></span><br><span class="line">        <span class="type">MapPropertySource</span> <span class="variable">propertySource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapPropertySource</span>(namespace, cache);</span><br><span class="line">        environment.getPropertySources().addFirst(propertySource);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Bindable bindable)</span> {</span><br><span class="line">        binder.bind(bindable);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听配置的变更</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reloadConfig</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">before</span> <span class="operator">=</span> JsonUtil.toStr(cache);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">toRefresh</span> <span class="operator">=</span> loadAllConfigFromDb();</span><br><span class="line">        <span class="keyword">if</span> (toRefresh) {</span><br><span class="line">            refreshConfig();</span><br><span class="line">            log.info(<span class="string">"config update! Old:{}, New:{}"</span>, before, JsonUtil.toStr(cache));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持配置的动态刷新</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">refreshConfig</span><span class="params">()</span> {</span><br><span class="line">        applicationContext.getBeansWithAnnotation(ConfigurationProperties.class).values().forEach(bean -&gt; {</span><br><span class="line">            Bindable&lt;?&gt; target = Bindable.ofInstance(bean).withAnnotations(AnnotationUtils.findAnnotation(bean.getClass(), ConfigurationProperties.class));</span><br><span class="line">            bind(target);</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 应用启动之后，执行的动态配置初始化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        reloadConfig();</span><br><span class="line">        <span class="comment">// SpringValueRegistry.updateAll();</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicConfigBinder</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PropertySources propertySources;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Binder binder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicConfigBinder</span><span class="params">(ApplicationContext applicationContext, PropertySources propertySources)</span> {</span><br><span class="line">        <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">        <span class="built_in">this</span>.propertySources = propertySources;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Bindable&lt;T&gt; bindable)</span> {</span><br><span class="line">        <span class="type">ConfigurationProperties</span> <span class="variable">propertiesAno</span> <span class="operator">=</span> bindable.getAnnotation(ConfigurationProperties.class);</span><br><span class="line">        <span class="keyword">if</span> (propertiesAno != <span class="literal">null</span>) {</span><br><span class="line">            <span class="type">BindHandler</span> <span class="variable">bindHandler</span> <span class="operator">=</span> getBindHandler(propertiesAno);</span><br><span class="line">            getBinder().bind(propertiesAno.prefix(), bindable, bindHandler);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(String prefix, Bindable&lt;T&gt; bindable, BindHandler bindHandler)</span> {</span><br><span class="line">        getBinder().bind(prefix, bindable, bindHandler);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BindHandler <span class="title function_">getBindHandler</span><span class="params">(ConfigurationProperties annotation)</span> {</span><br><span class="line">        <span class="type">BindHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IgnoreTopLevelConverterNotFoundBindHandler</span>();</span><br><span class="line">        <span class="keyword">if</span> (annotation.ignoreInvalidFields()) {</span><br><span class="line">            handler = <span class="keyword">new</span> <span class="title class_">IgnoreErrorsBindHandler</span>(handler);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!annotation.ignoreUnknownFields()) {</span><br><span class="line">            <span class="type">UnboundElementsSourceFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnboundElementsSourceFilter</span>();</span><br><span class="line">            handler = <span class="keyword">new</span> <span class="title class_">NoUnboundElementsBindHandler</span>(handler, filter);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参考ConfigurationPropertiesBindingPostProcessor</span></span><br><span class="line">    <span class="keyword">private</span> Binder <span class="title function_">getBinder</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.binder == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) {</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.binder == <span class="literal">null</span>) {</span><br><span class="line">                    <span class="built_in">this</span>.binder = <span class="keyword">new</span> <span class="title class_">Binder</span>(getConfigurationPropertySources(),</span><br><span class="line">                            getPropertySourcesPlaceholdersResolver(), getConversionService(),</span><br><span class="line">                            getPropertyEditorInitializer());</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.binder;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><img src="/../images/image_Spring%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E9%85%8D%E7%BD%AE.png"></p>
<p>这里就可以看到我们自定义的属性源<code>dbConfig</code>已经被注入成功啦😃</p>
<p>除此之外，当监听到对应的配置更新时，除了更新数据库，还需要推送对应的消息，在这里由于我项目中使用的是Spring Event实现的消息机制，因此监听者的操作如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ConfigRefreshEvent event)</span> {</span><br><span class="line">    dynamicConfigContainer.reloadConfig();</span><br><span class="line">    <span class="comment">// SpringValueRegistry.updateValue(event.getKey());</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>至于<code>@Value</code>的部分，代码比较多就不贴了，具体可以参考在<a href="https://github.com/qing-wq/SAI-Forum-backend/tree/rabbitmq/sai-core/src/main/java/ink/whi/core/autoconf/apollo">https://github.com/qing-wq/SAI-Forum-backend/tree/rabbitmq/sai-core/src/main/java/ink/whi/core/autoconf/apollo</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring Environment</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Lazy-init 踩坑记录</title>
    <url>/2023/11/01/Spring%20Lazy-init%20%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<blockquote>
<p>起因：在写一个Springboot项目时，队友将项目加载方式改为<code>lazy-init</code>，理由是能加快重启的速度，但是导致了Bug</p>
</blockquote>
<span id="more"></span>

<p><img src="/../images/289b54f1b37819da340708c7cfb9e261_rfYNVwE36_.png"></p>
<p><img src="/../images/1551908c7fb3dddbbc2d3b1e90a48cf1_gLwVbcWEG6.png"></p>
<p>Spring在Bean初始化阶段会对所有继承了<code>ApplicationContextAware</code>接口的类注入<code>ApplicationContext</code></p>
<p>但是如果设置了<code>lazy-init</code>，bean加载顺序变了，<code>setApplicationContext</code>就不执行了</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Environment体系</title>
    <url>/2024/06/21/Spring%20Environment%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><ul>
<li><code>PropertySource</code>：管理各种配置源的抽象类，即属性源</li>
<li><code>PropertySources</code>：用于统一管理和访问多个 PropertySource 实例</li>
<li><code>PropertyResolver</code>：通用属性解析<ul>
<li><code>Environment</code>：应用环境表示，提供属性访问，支持profile。</li>
<li><code>ConfigurablePropertyResolver</code>：属性解析配置，支持占位符解析。</li>
</ul>
</li>
<li><code>Binder</code>：配置绑定工具</li>
</ul>
<p>大致关系图：</p>
<p><img src="/../images/image_98WWM6BQwA.png"></p>
<span id="more"></span>

<blockquote>
<p>图片来自<a href="https://www.apolloconfig.com/#/zh/design/apollo-design?id=_31-%E5%92%8Cspring%E9%9B%86%E6%88%90%E7%9A%84%E5%8E%9F%E7%90%86" title="https://www.apolloconfig.com/#/zh/design/apollo-design?id=_31-和spring集成的原理">https://www.apolloconfig.com/#/zh/design/apollo-design?id=_31-和spring集成的原理</a></p>
</blockquote>
<h2 id="PropertySource"><a href="#PropertySource" class="headerlink" title="PropertySource"></a>PropertySource</h2><p><img src="/../images/image_eZgD5dC_Ym.png"></p>
<p>PropertySource是 Spring 框架中的一个关键抽象类，封装了一个属性源，属性源可以是一个<code>Map</code>、<code>Resource</code>对象、系统变量等等</p>
<h2 id="PropertySources"><a href="#PropertySources" class="headerlink" title="PropertySources"></a>PropertySources</h2><p><code>PropertySources</code> 是一个Spring框架中的接口，用于表示和管理一组属性源（<code>PropertySource</code>），这些属性源包含了应用程序环境中的配置数据。该接口提供了一系列方法来检索、添加、替换和删除这些属性源，允许开发者以统一的方式访问不同来源的配置信息，如环境变量、系统属性、配置文件等。</p>
<h2 id="PropertyResolver"><a href="#PropertyResolver" class="headerlink" title="PropertyResolver"></a>PropertyResolver</h2><p><code>PropertyResolver</code>是一个顶层接口，提供了一套灵活且强大的机制来处理应用程序配置属性。它定义了一些获取属性值，以及解析占位符的方法，用于访问和操纵来自各种源的属性值。</p>
<p><img src="/../images/image_TL0vgbMjbo.png"></p>
<h3 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h3><p><code>Environment</code> 接口是 Spring 框架中的一个核心部分，它提供了一个统一的方式来访问各种外部化的配置数据（继承自<code>PropertyResolver</code>）；支持配置文件（Profiles）的概念，可以在不同环境下进行条件性的配置，管理多个属性源。</p>
<p>可以看到<code>Environment</code>是继承了<code>PropertyResolver</code>接口的，<strong>只是增加了一些环境信息方法(profile)</strong></p>
<p>其中<code>Environment</code>实例关于<code>PropertyResolver</code>接口的方法是通过组合模式实现的，内部持有一个<code>PropertySourcesPropertyResolver</code>实例。</p>
<h3 id="ConfigurablePropertyResolver"><a href="#ConfigurablePropertyResolver" class="headerlink" title="ConfigurablePropertyResolver"></a>ConfigurablePropertyResolver</h3><p><code>ConfigurablePropertyResolver</code> 接口则增加了一些配置方法，在Spring中关键作用是提供灵活的配置属性解析。它支持<strong>占位符解析</strong>，并解析这些占位符为实际的配置值，提升配置的动态性和灵活性。</p>
<h3 id="其他实现"><a href="#其他实现" class="headerlink" title="其他实现"></a>其他实现</h3><ul>
<li><code>ConfigurableEnvironment</code>，增加了一些配置的方法，以及可以获取到内部的<code>PropertySource</code>列表。</li>
<li><code>StandardEnvironment</code>，非web上下文使用的环境实例。</li>
<li><code>StandardServletEnvironment</code>，web上下文使用的环境实例。</li>
</ul>
<h2 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h2><p>Spring提供了一个很强大的工具类<code>Binder</code>，可以将<code>Environment</code>或者<code>ConfigurationPropertySource</code>中的属性绑定到一个Java对象中，且支持占位符，类型转换，宽松绑定。Binder的使用可以参考</p>
<h3 id="ConfigurationProperties实现原理"><a href="#ConfigurationProperties实现原理" class="headerlink" title="@ConfigurationProperties实现原理"></a>@ConfigurationProperties实现原理</h3><p><code>@ConfigurationProperties</code>注解在Spring Boot中常用来绑定属性到Java Bean中，不难猜出内部原理便是使用上面所介绍的<code>Binder</code>类来实现的。</p>
<p>使用该注解时常常搭配<code>@EnableConfigurationProperties</code>注解一起使用，<code>@EnableConfigurationProperties</code>的主要作用就是注册了一个<code>ConfigurationPropertiesBindingPostProcessor</code></p>
<p>绑定的核心逻辑在<code>ConfigurationPropertiesBindingPostProcessor</code>中</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException {</span><br><span class="line">  <span class="keyword">if</span> (!hasBoundValueObject(beanName)) {</span><br><span class="line">    bind(ConfigurationPropertiesBean.get(<span class="built_in">this</span>.applicationContext, bean, beanName));</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> bean;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(ConfigurationPropertiesBean bean)</span> {</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    <span class="built_in">this</span>.binder.bind(bean);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConfigurationPropertiesBindException</span>(bean, ex);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">BindResult&lt;?&gt; bind(ConfigurationPropertiesBean propertiesBean) {</span><br><span class="line">    Bindable&lt;?&gt; target = propertiesBean.asBindTarget();</span><br><span class="line">    <span class="type">ConfigurationProperties</span> <span class="variable">annotation</span> <span class="operator">=</span> propertiesBean.getAnnotation();</span><br><span class="line">    <span class="type">BindHandler</span> <span class="variable">bindHandler</span> <span class="operator">=</span> getBindHandler(target, annotation);</span><br><span class="line">     <span class="keyword">return</span> getBinder().bind(annotation.prefix(), target, bindHandler); </span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<p>关键点在于Binder将<code>ConfigurationProperties</code>的前缀和实际的Bean对象绑定在了一起，实现配置的注入</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="https://www.cnblogs.com/wt20/p/17588895.html" title="https://www.cnblogs.com/wt20/p/17588895.html">https://www.cnblogs.com/wt20/p/17588895.html</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2023/06/18/230618-SpringBoot%E4%B9%8B%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%B1%9E%E6%80%A7%E7%BB%91%E5%AE%9ABinder/" title="https://spring.hhui.top/spring-blog/2023/06/18/230618-SpringBoot之编程式属性绑定Binder/">https://spring.hhui.top/spring-blog/2023/06/18/230618-SpringBoot之编程式属性绑定Binder/</a></li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring Environment</tag>
      </tags>
  </entry>
</search>
