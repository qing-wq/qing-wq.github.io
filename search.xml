<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Bean的生命周期</title>
    <url>/2024/03/31/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p><img src="/../images/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/bean.svg"></p>
<p><em><strong><u>大致过程：实例化→属性注入→初始化→销毁</u></strong></em></p>
<h1 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h1><ol>
<li>Spring扫描所有的Bean（通过xml配置文件或者注解）得到BeanDefinition</li>
<li>根据得到的BeanDefinition去生成bean<ol>
<li>首先根据class推断构造方法</li>
<li>根据推断出来的构造方法，反射，得到一个对象（暂时叫做<strong>原始对象</strong>）</li>
</ol>
</li>
</ol>
<blockquote>
<p>总结：扫描Bean，获取构造方法并生成原始对象，分配内存空间</p>
</blockquote>
<h1 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h1><p>填充原始对象中的属性（即依赖注入）</p>
<span id="more"></span>

<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><ol>
<li><p><strong>实现了<code>ApplicationContextAware</code>接口</strong>  </p>
<p> 使用ApplicationContext来生成并管理Bean的话，才有此步；否则，没有。  </p>
<p> 如果这个Bean已经实现了ApplicationContextAware接口，会调用<code>setApplicationContext()</code>方法，传入Spring上下文（同样这个方式也可以实现上一步的内容，但比上一步更好，因为ApplicationContext是BeanFactory的子接口，有更多的实现方法）；</p>
</li>
<li><p><strong><code>BeanPostProcessors</code>的<code>ProcessBeforeInitialization()</code></strong></p>
<p> 如果有BeanPostProcessors和Bean关联，那么其<code>postProcessBeforeInitialization()</code>方法将被将被调用。</p>
</li>
<li><p><strong><code>@PostConstruct</code></strong></p>
<p> 这里插入一个不属于Spring的生命周期，但是实际项目中会经常用到的方法。它在执行依赖项注入后被执行，即<strong>构造函数之后，<code>init()</code>方法之前执行</strong></p>
</li>
<li><p><strong><code>initializingBean</code>的<code>afterPropertiesSet()</code></strong></p>
<p> 如果Bean类已实现InitializingBean接口，则执行他的<code>afterProPertiesSet()</code>方法。</p>
</li>
<li><p>Bean的<code>init-method</code>  </p>
</li>
<li><p><strong><code>BeanPostProcessors</code>的<code>ProcessaAfterInitialization()</code></strong></p>
<p> 容器中如果有实现BeanPostProcessors接口的实例，则Bean在初始化之前都会执行这个实例的<code>processAfterInitialization()</code>方法。</p>
</li>
<li><p>如果原始对象中的某个方法被AOP了，那么则需要根据原始对象生成一个代理对象</p>
</li>
<li><p>把最终生成的代理对象放入单例池（源码中叫做<code>singletonObjects</code>）中，下次getBean时就直接从单例池拿即可</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring源码系列</category>
      </categories>
  </entry>
  <entry>
    <title>🤨 Go generic VS Java generic</title>
    <url>/2023/11/14/Go%20generic%20VS%20Java%20generic/</url>
    <content><![CDATA[<p><em>本文暂未完成</em></p>
<p>随着Go 1.18版本的发布，Go语言正式引入了泛型这一重要特性。本文将对Go泛型与Java泛型进行对比分析，探讨它们之间的异同。</p>
<blockquote>
<p>Go 1.18版本引入了泛型特性，主要包括以下几个方面：  </p>
</blockquote>
<p>  类型参数：类型参数是泛型函数或类型的一个占位符，表示一个未知的类型。类型参数用方括号[]括起来，放在函数名或类型名之后。例如，<code>func MyFunc[T any](a T) {}</code>中的T就是一个类型参数。  </p>
<p>  约束：约束是一种限制类型参数的方式，用于指定类型参数必须满足的条件。约束可以是接口类型或其他具有类型参数的类型。例如，<code>func MyFunc[T io.Reader](a T) {}</code>中的io.Reader就是一个约束，表示类型参数T必须实现io.Reader接口。  </p>
<p>  预定义约束：Go 1.18提供了一些预定义的约束，用于表示常见的类型集合。例如，any约束表示任何类型，comparable约束表示可比较的类型（支持<code>==</code>和<code>!=</code>操作符）。  </p>
<p>  泛型函数：泛型函数是一种使用类型参数的函数，可以处理不同类型的参数。泛型函数的定义和普通函数类似，只是在函数名后面添加了类型参数列表。例如，<code>func MyFunc[T any](a, b T) T {}</code>。  </p>
<p>  泛型类型：泛型类型是一种使用类型参数的类型，可以表示不同类型的数据结构。泛型类型的定义和普通类型类似，只是在类型名后面添加了类型参数列表。例如，<code>type MySlice[T any] []T</code>。</p>
<ul>
<li>匿名函数不支持泛型，但是匿名函数可以使用别处定义好的类型实参</li>
<li>不支持泛型方法</li>
</ul>
<p>对比方面：</p>
<ul>
<li>泛型定义</li>
<li>泛型擦除</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="https://www.kunkkawu.com/archives/shen-ru-li-jie-golang-de-fan-xing">https://www.kunkkawu.com/archives/shen-ru-li-jie-golang-de-fan-xing</a></li>
<li><a href="https://tonybai.com/2022/03/25/intro-generics/">https://tonybai.com/2022/03/25/intro-generics/</a></li>
</ul>
]]></content>
      <categories>
        <category>Java VS Go</category>
      </categories>
  </entry>
  <entry>
    <title>Go GC VS Java GC</title>
    <url>/2023/11/03/Go-GC-Vs-Java-GC/</url>
    <content><![CDATA[<p>之前面试的时候被面试官问到过这个问题，但是当时对Go的GC一点也不了解。于是后来整理了一下，发现Go的GC算法真有意思。本文对比了Java和Go在GC算法上的的区别：</p>
<h1 id="Java-GC"><a href="#Java-GC" class="headerlink" title="Java GC"></a>Java GC</h1><p>Java的GC使用<strong>分代回收算法</strong>，将堆内存划分为新生代和老年代，一般情况下在<strong>新生代使用标记-复制算法，老年代使用标记-清除或标记-整理算法</strong></p>
<p>分代GC依赖分代假设，即GC将主要的回收目标放在新创建的对象上（存活时间短，更倾向于被回收），而非频繁检查所有对象。</p>
<p>在Java中，不同的垃圾回收器使用的垃圾回收算法不同：</p>
<ul>
<li>JDK 8：Parallel Scavenge</li>
<li>JDK 9 ~ JDK20: G1</li>
</ul>
<span id="more"></span>

<p><strong>特点：</strong></p>
<ul>
<li>都会造成STW，这是影响性能最主要的因素</li>
<li>部分算法还会产生大量空间碎片</li>
</ul>
<p>介绍一下Java中比较经典的垃圾回收器：</p>
<h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p><strong>以获取最短回收停顿时间为目标</strong>，使用了<strong>标记-清除</strong> 算法，<strong>第一次实现了让垃圾收集线程与用户线程（基本上）同时工作</strong></p>
<ul>
<li>主要优点：<strong>并发收集、低停顿</strong></li>
<li>缺点：<strong>对 CPU 资源敏感</strong>，<strong>会产生大量空间碎片</strong></li>
</ul>
<h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p>G1 收集器在后台维护了一个<strong>优先列表</strong>，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 <strong>Garbage-First</strong> 的由来) 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率）。</p>
<p>G1使用<strong>标记-整理</strong>算法</p>
<h1 id="Go-GC"><a href="#Go-GC" class="headerlink" title="Go GC"></a>Go GC</h1><p>Golang的垃圾回收算法使用的是<em><strong>无分代、不整理、并发</strong>的</em><em>三色标记清扫算法</em>**。原因在于：</p>
<ul>
<li>Go 运行时的分配算法基于<code>tcmalloc</code>，<strong>基本上没有碎片问题</strong>，对对象进行整理不会带来实质性的性能提升。</li>
<li>Go 的编译器会通过<strong>逃逸分析</strong>将大部分新生对象存储在栈上，只有那些需要长期存在的对象才会被分配到需要进行垃圾回收的堆中。也就是说，分代<code>GC</code>回收的那些存活时间短的对象在 Go 中是直接被分配到栈上，当<code>goroutine</code>死亡后栈也会被直接回收，不需要<code>GC</code>的参与，进而分代假设并没有带来直接优势。</li>
<li>引入了<strong>混合屏障机制</strong>，能够让Go 的垃圾回收器部分阶段与用户代码并发执行，大大缩短了STW的时间</li>
</ul>
]]></content>
      <categories>
        <category>Java VS Go</category>
      </categories>
  </entry>
  <entry>
    <title>Go语言基础</title>
    <url>/2023/09/01/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li><strong>GOPATH</strong>：代表 Go 语言项目的工作目录，在 Go Module 模式之前非常重要，现在基本上用来存放使用 go get 命令获取的项目。</li>
<li><strong>GOBIN</strong>：代表 Go 编译生成的程序的安装目录，比如通过 go install 命令，会把生成的 Go 程序安装到 GOBIN 目录下，以供你在终端使用。</li>
<li>Go代理：<code>GOPROXY=https://goproxy.cn</code></li>
</ul>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> GOROOT=/usr/local/go </span><br><span class="line"><span class="built_in">export</span> GOPATH=<span class="variable">$HOME</span>/MyDoucument/code/goProject</span><br><span class="line"><span class="built_in">export</span> GOBIN=<span class="variable">$GOPATH</span>/bin</span><br><span class="line"><span class="built_in">export</span> GO111MODULE=on</span><br></pre></td></tr></tbody></table></figure>

<h3 id="编译发布"><a href="#编译发布" class="headerlink" title="编译发布"></a>编译发布</h3><p><code>go build</code>编译生成可执行文件</p>
<p><code>go install</code>把它安装到 <code>$GOBIN</code> 目录或者任意位置</p>
<h3 id="跨平台编译"><a href="#跨平台编译" class="headerlink" title="跨平台编译"></a>跨平台编译</h3><p>Go 语言通过两个环境变量来控制跨平台编译，它们分别是 <code>GOOS</code> 和 <code>GOARCH</code> 。</p>
<ul>
<li><strong>GOOS</strong>：代表要编译的目标操作系统，常见的有 Linux、Windows、Darwin 等。</li>
<li><strong>GOARCH</strong>：代表要编译的目标处理器架构，常见的有 386、AMD64、ARM64 等。</li>
</ul>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">GOOS=linux GOARCH=amd64 go build ./ch01/main.go</span><br></pre></td></tr></tbody></table></figure>

<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><ul>
<li><strong>有符号整型</strong>：如 <code>int</code>、<code>int8</code>、<code>int16</code>、<code>int32</code> 和 <code>int64</code>。</li>
<li><strong>无符号整型</strong>：如 <code>uint</code>、<code>uint8</code>、<code>uint16</code>、<code>uint32</code> 和 <code>uint64</code>。</li>
</ul>
<p>除了有用“位”（bit）大小表示的整型外，还有 int 和 uint 这两个没有具体 bit 大小的整型，它们的大小可能是 32bit，也可能是 64bit，和硬件设备 CPU 有关。</p>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><ul>
<li><code>float32</code> </li>
<li><code>float64</code></li>
</ul>
<h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><ul>
<li><code>complex64</code></li>
<li><code>complex128</code></li>
</ul>
<p>复数有实部和虚部，<code>complex64</code>的实部和虚部为32位，<code>complex128</code>的实部和虚部为64位</p>
<h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p><code>bool</code></p>
<ul>
<li>布尔类型变量的默认值为false。</li>
<li>Go 语言中不允许将整型强制转换为布尔型.</li>
<li>布尔型无法参与数值运算，也无法与其他类型进行转换</li>
</ul>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>*** Go 语言里的字符串的内部实现使用UTF-8编码，每个字符串的底层都是byte数组***</p>
<ul>
<li><em><strong>byte：相当于uint8</strong></em></li>
<li><em><strong>rune：相当于int32</strong></em><ul>
<li>Go 使用了特殊 <code>rune</code> 类型来处理 <code>Unicode</code>（复合字符，包括中文、日文等用多字节表示字符）</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//utf-8遍历</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str); i++ {</span><br><span class="line">    ch := str[i]</span><br><span class="line">    fmt.Printf(<span class="string">"%c \n"</span>, ch)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//Unicode遍历</span></span><br><span class="line"><span class="keyword">for</span> _, ch1 := <span class="keyword">range</span> str {</span><br><span class="line">    fmt.Printf(<span class="string">"%c \n"</span>, ch1)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="Array、Slice、Map"><a href="#Array、Slice、Map" class="headerlink" title="Array、Slice、Map"></a>Array、Slice、Map</h2><p><img src="/../images/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/image_MkJ3W3cuce.png"></p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">array1:=[<span class="number">5</span>]<span class="type">string</span>{<span class="number">1</span>:<span class="string">"b"</span>,<span class="number">3</span>:<span class="string">"d"</span>}</span><br><span class="line"></span><br><span class="line">slice:=array[start:end]</span><br><span class="line"></span><br><span class="line">slice1:=<span class="built_in">make</span>([]<span class="type">string</span>,<span class="number">4</span>,<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">slice2:=<span class="built_in">append</span>(slice1,<span class="string">"f"</span>)</span><br><span class="line"></span><br><span class="line">nameAgeMap:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">nameAgeMap:=<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>{<span class="string">"飞雪无情"</span>:<span class="number">20</span>}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>📌提示</p>
<p>在创建新切片的时候，最好要让新切片的长度和容量一样，这样在追加操作的时候就会生成新的底层数组，从而和原有数组分离，就不会因为共用底层数组导致修改内容的时候影响多个切片。</p>
</blockquote>
<h2 id="函数和方法"><a href="#函数和方法" class="headerlink" title="函数和方法"></a>函数和方法</h2><p>在 Go 语言中，方法和函数是两个概念，但又非常相似，不同点在于方法必须要有一个接收者，这个接收者是一个类型，这样方法就和这个类型绑定在一起，称为这个类型的方法。</p>
<ul>
<li>函数：正常的代码逻辑</li>
<li>方法：特定类型才有，相当于对象的方法</li>
</ul>
<h3 id="值类型接收者和指针类型接收者"><a href="#值类型接收者和指针类型接收者" class="headerlink" title="值类型接收者和指针类型接收者"></a>值类型接收者和指针类型接收者</h3><ul>
<li>值类型接收者：不会改变原来的对象，相当于操作对象的拷贝</li>
<li>指针类型接收者：通过指针可以获取对象地址，可以直接改变原来的对象</li>
</ul>
<blockquote>
<p>提示：在调用方法的时候，传递的接收者本质上都是副本，只不过一个是这个值的副本，一是指向这个值指针的副本。指针具有指向原有值的特性，所以修改了指针指向的值，也就修改了原有的值。<em><strong>我们可以简单地理解为值接收者使用的是值的副本来调用方法，而指针接收者使用实际的值来调用方法。</strong></em></p>
</blockquote>
<blockquote>
<p>📌值接受者方法不会改变原始结构体实例</p>
</blockquote>
<ul>
<li>如果使用一个值类型变量调用指针类型接收者的方法，Go 语言编译器会自动帮我们取指针调用，以满足指针接收者的要求。</li>
<li>同样的原理，如果使用一个指针类型变量调用值类型接收者的方法，Go 语言编译器会自动帮我们解引用调用，以满足值类型接收者的要求。</li>
</ul>
<h3 id="值类型调用者和指针类型调用者"><a href="#值类型调用者和指针类型调用者" class="headerlink" title="值类型调用者和指针类型调用者"></a>值类型调用者和指针类型调用者</h3><p>在官方effective go文档中，对两者区别描述如下：</p>
<ul>
<li><em><strong>值方法（value methods）可以通过指针和值调用，但是指针方法（pointer methods）只能通过指针来调用</strong></em><em><strong>。</strong></em></li>
<li>但有一个例外，如果某个值是可寻址的（addressable，或者说<em>左值</em>），那么编译器会在值调用指针方法时自动插入取地址符，使得在此情形下看起来像指针方法也可以通过值来调用。</li>
</ul>
<hr>
<p>总结：</p>
<ul>
<li>不管是普通对象还是指针，都可以调用他们的值方法和指针方法，因为编译器会自行处理（语法糖</li>
<li><strong>遇事不决请用pointer method！！！</strong></li>
</ul>
<h3 id="通过变量调用方法"><a href="#通过变量调用方法" class="headerlink" title="通过变量调用方法"></a>通过变量调用方法</h3><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">student := Student(<span class="string">"my name is xiaoming, I am "</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法赋值给变量</span></span><br><span class="line">sm := Student.stu</span><br><span class="line">sm2 := (*Student).stu2</span><br><span class="line">sm(student, <span class="number">2</span>)</span><br><span class="line">sm2(&amp;student)</span><br><span class="line">student.stu(<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="结构体和接口"><a href="#结构体和接口" class="headerlink" title="结构体和接口"></a>结构体和接口</h2><p>结构体定义：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">type Stu <span class="class"><span class="keyword">struct</span>{</span></span><br><span class="line">  name <span class="built_in">string</span></span><br><span class="line">  age <span class="type">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名结构体 变量 </span></span><br><span class="line">var stu <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">  name <span class="built_in">string</span></span><br><span class="line">  age <span class="type">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名结构体变量另一种写法</span></span><br><span class="line">newCar := <span class="keyword">struct</span> {</span><br><span class="line">  Make    <span class="built_in">string</span> `json:<span class="string">"make"</span>`</span><br><span class="line">  Model   <span class="built_in">string</span> `json:<span class="string">"model"</span>`</span><br><span class="line">  Mileage <span class="type">int</span>    `json:<span class="string">"mileage"</span>`</span><br><span class="line">}{}</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyStringer interface</span></span><br><span class="line">type MyStringer interface{</span><br><span class="line">  myString() <span class="built_in">string</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><em><strong>以指针类型接收者实现接口的时候，只有对应的指针类型实例才被认为实现了该接口。</strong></em></p>
<p><img src="/../images/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/Ciqc1F-yPMSAZ4k7AABU_GW4VxE080_qJvRefMHb8.png"></p>
<h3 id="工厂函数（构造函数）"><a href="#工厂函数（构造函数）" class="headerlink" title="工厂函数（构造函数）"></a>工厂函数（构造函数）</h3><p>工厂函数一般用于创建自定义的结构体，便于使用者调用</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="type">string</span>)</span></span> *person {</span><br><span class="line">    <span class="keyword">return</span> &amp;person{name:name}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="继承和组合"><a href="#继承和组合" class="headerlink" title="继承和组合"></a>继承和组合</h3><p>在 Go 语言中没有继承的概念，所以结构、接口之间也没有父子关系，Go 语言提倡的是组合，利用组合达到代码复用的目的，这也更灵活。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 组合</span></span><br><span class="line">p:=person{</span><br><span class="line">    age:<span class="number">30</span>,</span><br><span class="line">    name:<span class="string">"飞雪无情"</span>,</span><br><span class="line">    address:address{</span><br><span class="line">        province: <span class="string">"北京"</span>,</span><br><span class="line">        city:     <span class="string">"北京"</span>,</span><br><span class="line">    },</span><br><span class="line">}</span><br><span class="line"><span class="comment">//像使用自己的字段一样，直接使用</span></span><br><span class="line">fmt.Println(p.province)</span><br></pre></td></tr></tbody></table></figure>

<p>类型组合后，外部类型不仅可以使用内部类型的字段，也可以使用内部类型的方法，就像使用自己的方法一样。<br><strong>方法覆写</strong>：如果外部类型定义了和内部类型同样的方法，那么外部类型的会覆盖内部类型，这就是。</p>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>类型断言用来判断一个接口的值是否是实现该接口的某个具体类型。</p>
<p>接口引用拥有断言能力，用于判断当前引用是否属于某个对象的实例</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 接口引用指向子类实例</span></span><br><span class="line"><span class="keyword">var</span> myInterface MyInterface = NewTest(<span class="string">"test"</span>, <span class="number">18</span>, <span class="string">"test"</span>)</span><br><span class="line"><span class="comment">// 判断myInterface是否是Test类型</span></span><br><span class="line"><span class="keyword">if</span> _, ok := myInterface.(*Test);!ok {</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">"myInterface 不是 Test实例"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>在类型断言的时候，同时完成了类型转换</strong></p>
<h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><p>在 Go 语言中，错误是通过内置的 error 接口表示的：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// error 定义</span></span><br><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> {</span><br><span class="line">   Error() <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂函数</span></span><br><span class="line">errors.New(<span class="string">"error"</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong>自定义异常</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> commonError <span class="keyword">struct</span> {</span><br><span class="line">  errorCode <span class="type">int</span>    <span class="comment">//错误码</span></span><br><span class="line">  errorMsg  <span class="type">string</span> <span class="comment">//错误信息</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 实现了Error()就是自定义异常 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ce *commonError)</span></span> Error() <span class="type">string</span> {</span><br><span class="line">  <span class="keyword">return</span> ce.errorMsg</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Error-Wrapping"><a href="#Error-Wrapping" class="headerlink" title="Error Wrapping"></a>Error Wrapping</h3><p>上述自定义异常可以满足我们的需求，但是非常烦琐，因为既要定义新的类型还要实现 error 接口。</p>
<p> Go 语言 1.13 版本开始，Go 标准库新增了 Error Wrapping 功能，让我们可以基于一个存在的 error 生成新的 error，并且可以保留原 error 信息。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// wrap</span></span><br><span class="line">e := errors.New(<span class="string">"原始错误e"</span>)</span><br><span class="line">w := fmt.Errorf(<span class="string">"Wrap了一个错误:%w"</span>, e)</span><br><span class="line">fmt.Println(w)   <span class="comment">// wrap了一个错误:原始错误e</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Unwrap</span></span><br><span class="line">fmt.Println(errors.Unwrap(w))   <span class="comment">// 原始错误e</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="errors-Is"><a href="#errors-Is" class="headerlink" title="errors.Is"></a>errors.Is</h3><p>有了 Error Wrapping 后，你会发现原来用的判断两个 error 是不是同一个 error 的方法失效了，比如 Go 语言标准库经常用到的如下代码中的方式：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">fmt.Println(errors.Is(w, e))  <span class="comment">// true</span></span><br><span class="line">fmt.Println(e == os.ErrExist) <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>errors.ls</code></p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Is</span><span class="params">(err, target <span class="type">error</span>)</span></span> <span class="type">bool</span></span><br></pre></td></tr></tbody></table></figure>

<p>以上就是errors.Is 函数的定义，可以解释为：</p>
<ul>
<li>如果 err 和 target 是同一个，那么返回 true。</li>
<li>如果 err 是一个 wrapping error，target 也包含在这个嵌套 error 链中的话，也返回 true。</li>
</ul>
<blockquote>
<p>📌可以简单地概括为，两个 error 相等或 err 包含 target 的情况下返回 true，其余返回 false。</p>
</blockquote>
<h3 id="errors-As"><a href="#errors-As" class="headerlink" title="errors.As"></a>errors.As</h3><p>同样的原因，有了 error 嵌套后，error 断言也不能用了，因为你不知道一个 error 是否被嵌套，又嵌套了几层。所以 Go 语言为解决这个问题提供了 errors.As 函数，比如前面 error 断言的例子，可以使用  errors.As 函数重写，效果是一样的，如下面的代码所示：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cm *commonError</span><br><span class="line"><span class="keyword">if</span> errors.As(err,&amp;cm){</span><br><span class="line">   fmt.Println(<span class="string">"错误代码为:"</span>,cm.errorCode,<span class="string">"，错误信息为："</span>,cm.errorMsg)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">   fmt.Println(sum)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Deferred"><a href="#Deferred" class="headerlink" title="Deferred"></a>Deferred</h3><p>defer 语句常被用于成对的操作，如文件的打开和关闭，加锁和释放锁，连接的建立和断开等。不管多么复杂的操作，都可以保证资源被正确地释放。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(filename <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) {</span><br><span class="line">   f, err := os.Open(filename)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">defer</span> f.Close()</span><br><span class="line">   <span class="comment">//省略无关代码</span></span><br><span class="line">   <span class="keyword">return</span> readAll(f, n)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>在一个方法或者函数中，可以有多个 defer 语句；</li>
<li>defer 有一个调用栈，多个 defer 语句的执行顺序依照<strong>后进先出</strong>的原则。</li>
</ol>
<h3 id="Panic"><a href="#Panic" class="headerlink" title="Panic"></a>Panic</h3><p>Go 语言是一门静态的强类型语言，很多问题都尽可能地在编译时捕获，但是有一些只能在运行时检查，比如数组越界访问、不相同的类型强制转换等，这类运行时的问题会引起 panic 异常。除了运行时可以产生 panic 外，我们自己也可以抛出 panic 异常。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panic</span><span class="params">(v <span class="keyword">interface</span>{})</span></span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p><code>interface{}</code> 是空接口的意思，在 Go 语言中代表任意类型。</p>
</blockquote>
<p>panic 异常是一种非常严重的情况，会让程序中断运行，使程序崩溃，所以<strong>如果是不影响程序运行的错误，不要使用 panic，使用普通错误 error 即可。</strong></p>
<h4 id="Recover-捕获-Panic-异常"><a href="#Recover-捕获-Panic-异常" class="headerlink" title="Recover 捕获 Panic 异常"></a>Recover 捕获 Panic 异常</h4><p>通常情况下，我们不对 panic 异常做任何处理，因为既然它是影响程序运行的异常，就让它直接崩溃即可。但是也的确有一些特例，比如<strong>在****程序崩溃前做一些资源释放的处理</strong>，这时候就需要从 panic 异常中恢复，才能完成处理。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connectMySQL</span><span class="params">(ip, username, password <span class="type">string</span>)</span></span> {</span><br><span class="line">  <span class="keyword">if</span> ip == <span class="string">""</span> {</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"ip不能为空"</span>)</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//省略其他代码</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> {</span><br><span class="line">      fmt.Println(p)</span><br><span class="line">    }</span><br><span class="line">  }()</span><br><span class="line">  connectMySQL(<span class="string">""</span>, <span class="string">"root"</span>, <span class="string">"123456"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="并发基础"><a href="#并发基础" class="headerlink" title="并发基础"></a>并发基础</h1><h2 id="协程（Goroutine）"><a href="#协程（Goroutine）" class="headerlink" title="协程（Goroutine）"></a>协程（Goroutine）</h2><p>Go 语言中没有线程的概念，只有协程，也称为 goroutine。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> function()</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">ch:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>接收：获取 chan 中的值，操作符为<code> &lt;- chan</code>。</li>
<li>发送：向 chan 发送值，把值放在 chan 中，操作符为 <code>chan &lt;-</code>。</li>
</ol>
<h3 id="无缓冲-channel"><a href="#无缓冲-channel" class="headerlink" title="无缓冲 channel"></a><strong>无缓冲 channel</strong></h3><p>无缓冲 channel，它的容量是 0，不能存储任何数据。所以无缓冲 channel 只起到传输数据的作用，数据并不会在 channel 中做任何停留。这也意味着，无缓冲 channel 的发送和接收操作是同时进行的，它也可以称为同步 channel。</p>
<h3 id="有缓冲-channel"><a href="#有缓冲-channel" class="headerlink" title="有缓冲 channel"></a>有缓冲 channel</h3><p>有缓冲 channel 类似一个可阻塞的队列，内部的元素<em><strong>先进先出</strong></em>。通过 make 函数的第二个参数可以指定 channel 容量的大小，进而创建一个有缓冲 channel。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">cacheCh:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">5</span>)</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/../images/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/CgqCHl-7fzmAVLu0AACSjW-neAE188_bGrO7t8IpW.png"></p>
<p>一个有缓冲 channel 具备以下特点：</p>
<ol>
<li>有缓冲 channel 的内部有一个缓冲队列；</li>
<li>发送操作是向队列的尾部插入元素，如果队列已满，则阻塞等待，直到另一个 goroutine 执行，接收操作释放队列的空间；</li>
<li>接收操作是从队列的头部获取元素并把它从队列中删除，如果队列为空，则阻塞等待，直到另一个 goroutine 执行，发送操作插入新的元素。</li>
</ol>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 获取队列容量和元素个数：</span></span><br><span class="line">fmt.Println(<span class="string">"cacheCh容量为:"</span>,<span class="built_in">cap</span>(cacheCh),<span class="string">",元素个数为："</span>,<span class="built_in">len</span>(cacheCh))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭 channel</span></span><br><span class="line"><span class="built_in">close</span>(cacheCh)</span><br></pre></td></tr></tbody></table></figure>

<p>如果一个 channel 被关闭了，就不能向里面发送数据了，如果发送的话，会引起 painc 异常。但是还可以接收 channel 里的数据，如果 channel 里没有数据的话，接收的数据是元素类型的零值。</p>
<h3 id="单向-channel"><a href="#单向-channel" class="headerlink" title="单向 channel"></a>单向 channel</h3><p>有时候，我们有一些特殊的业务需求，比如限制一个 channel 只可以接收但是不能发送，或者限制一个 channel 只能发送但不能接收，这种 channel 称为单向 channel。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">onlySend := <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span><br><span class="line">onlyReceive:=<span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="select-多路复用"><a href="#select-多路复用" class="headerlink" title="select 多路复用"></a>select 多路复用</h3><blockquote>
<p>小提示：多路复用可以简单地理解为，N 个 channel 中，任意一个 channel 有数据产生，select 都可以监听到，然后执行相应的分支，接收数据并处理。</p>
</blockquote>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> {</span><br><span class="line">   <span class="keyword">case</span> i1 = &lt;-c1:</span><br><span class="line">     <span class="comment">//todo</span></span><br><span class="line">   <span class="keyword">case</span> c2 &lt;- i2:</span><br><span class="line">     <span class="comment">//todo</span></span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">     <span class="comment">// default todo</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="sync-包"><a href="#sync-包" class="headerlink" title="sync 包"></a>sync 包</h2><blockquote>
<p>小技巧：使用 go build、go run、go test 这些 Go 语言工具链提供的命令时，添加 <code>-race</code> 标识可以帮你检查 Go 语言代码是否存在资源竞争。</p>
</blockquote>
<h3 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a><strong>sync.Mutex</strong></h3><p>互斥锁，顾名思义，指的是在同一时刻只有一个协程执行某段代码，其他协程都要等待该协程执行完毕后才能继续执行。</p>
<p>Mutex 的 <code>Lock</code> 和 <code>Unlock</code> 方法总是成对出现，而且要确保 Lock 获得锁后，一定执行 UnLock 释放锁</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>(</span><br><span class="line">   sum <span class="type">int</span></span><br><span class="line">   mutex sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(i <span class="type">int</span>)</span></span> {</span><br><span class="line">   mutex.Lock()</span><br><span class="line">   sum += i</span><br><span class="line">   mutex.Unlock()</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>小提示：以上被加锁保护的 sum+=i 代码片段又称为<strong>临界区</strong>。在同步的程序设计中，临界区段指的是一个访问共享资源的程序片段，而这些共享资源又有无法同时被多个协程访问的特性。</p>
</blockquote>
<h3 id="sync-RWMutex"><a href="#sync-RWMutex" class="headerlink" title="sync.RWMutex"></a>sync.RWMutex</h3><p>go中的读写锁。使用：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mutex sync.RWMutex</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readSum</span><span class="params">()</span></span> <span class="type">int</span> {</span><br><span class="line"></span><br><span class="line">   <span class="comment">//只获取读锁</span></span><br><span class="line">   mutex.RLock()</span><br><span class="line">   <span class="keyword">defer</span> mutex.RUnlock()</span><br><span class="line">   b:=sum</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h3><p>相当于Java中的***<code>CountDownLatch</code>***，用于最终完成的场景，关键点在于一定要等待所有协程都执行完毕。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">   <span class="comment">//因为要监控110个协程，所以设置计数器为110</span></span><br><span class="line">   wg.Add(<span class="number">110</span>)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ {</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">         <span class="comment">//计数器值减1</span></span><br><span class="line">         <span class="keyword">defer</span> wg.Done()</span><br><span class="line">         add(<span class="number">10</span>)</span><br><span class="line">      }()</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>;i++ {</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">         <span class="comment">//计数器值减1</span></span><br><span class="line">         <span class="keyword">defer</span> wg.Done()</span><br><span class="line">         fmt.Println(<span class="string">"和为:"</span>,readSum())</span><br><span class="line">      }()</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">//一直等待，直到计数器值为0</span></span><br><span class="line">   wg.Wait()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h3><p>让代码只执行一次，哪怕是在高并发的情况下，比如创建一个单例。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">   doOnce()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doOnce</span><span class="params">()</span></span> {</span><br><span class="line">   <span class="keyword">var</span> once sync.Once</span><br><span class="line">   onceBody := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">      fmt.Println(<span class="string">"Only once"</span>)</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">//用于等待协程执行完毕</span></span><br><span class="line">   done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//启动10个协程执行once.Do(onceBody)</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">         <span class="comment">//把要执行的函数(方法)作为参数传给once.Do方法即可</span></span><br><span class="line">         once.Do(onceBody)</span><br><span class="line">         done &lt;- <span class="literal">true</span></span><br><span class="line">      }()</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">      &lt;-done</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="sync-Cond"><a href="#sync-Cond" class="headerlink" title="sync.Cond"></a>sync.Cond</h3><p>sync.Cond 可以用于发号施令，一声令下所有协程都可以开始执行，关键点在于协程开始的时候是等待的，要等待 sync.Cond 唤醒才能执行。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//10个人赛跑，1个裁判发号施令</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">race</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">   cond :=sync.NewCond(&amp;sync.Mutex{})</span><br><span class="line">   <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">   wg.Add(<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>; i++ {</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(num <span class="type">int</span>)</span></span> {</span><br><span class="line">         <span class="keyword">defer</span>  wg.Done()</span><br><span class="line">         fmt.Println(num,<span class="string">"号已经就位"</span>)</span><br><span class="line">         cond.L.Lock()</span><br><span class="line">         cond.Wait()<span class="comment">//等待发令枪响</span></span><br><span class="line">         fmt.Println(num,<span class="string">"号开始跑……"</span>)</span><br><span class="line">         cond.L.Unlock()</span><br><span class="line">      }(i)</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">//等待所有goroutine都进入wait状态</span></span><br><span class="line">   time.Sleep(<span class="number">2</span>*time.Second)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">      <span class="keyword">defer</span>  wg.Done()</span><br><span class="line">      fmt.Println(<span class="string">"裁判已经就位，准备发令枪"</span>)</span><br><span class="line">      fmt.Println(<span class="string">"比赛开始，大家准备跑"</span>)</span><br><span class="line">      cond.Broadcast()<span class="comment">//发令枪响</span></span><br><span class="line">   }()</span><br><span class="line">   <span class="comment">//防止函数提前返回退出</span></span><br><span class="line">   wg.Wait()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><strong>Wait</strong>，阻塞当前协程，直到被其他协程调用 Broadcast 或者 Signal 方法唤醒，使用的时候需要加锁，使用 sync.Cond 中的锁即可，也就是 L 字段。</li>
<li><strong>Signal</strong>，唤醒一个等待时间最长的协程。</li>
<li><strong>Broadcast</strong>，唤醒所有等待的协程。</li>
</ol>
<blockquote>
<p>注意：在调用 Signal 或者 Broadcast 之前，要确保目标协程处于 Wait 阻塞状态，不然会出现死锁问题。</p>
</blockquote>
<p>如果你以前学过 Java，会发现 sync.Cond 和 Java 的等待唤醒机制很像，它的三个方法 Wait、Signal、Broadcast 就分别对应 Java 中的 wait、notify、notifyAll。</p>
<h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><blockquote>
<p>一个任务会有很多个协程协作完成，一次 HTTP 请求也会触发很多个协程的启动，而这些协程有可能会启动更多的子协程，并且无法预知有多少层协程、每一层有多少个协程。</p>
<p>如果因为某些原因导致任务终止了，HTTP 请求取消了，那么它们启动的协程怎么办？该如何取消呢？因为取消这些协程可以节约内存，提升性能，同时避免不可预料的 Bug。</p>
<p>Context 就是用来简化解决这些问题的，并且是并发安全的。Context 是一个接口，它具备手动、定时、超时发出取消信号、传值等功能，主要用于控制多个协程之间的协作，尤其是取消操作。一旦取消指令下达，那么被 Context 跟踪的这些协程都会收到取消信号，就可以做清理和退出操作。</p>
</blockquote>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> {</span><br><span class="line"></span><br><span class="line">   Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">   Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{}</span><br><span class="line">   Err() <span class="type">error</span></span><br><span class="line">   Value(key <span class="keyword">interface</span>{}) <span class="keyword">interface</span>{}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Context-树"><a href="#Context-树" class="headerlink" title="Context 树"></a>Context 树</h3><p>Go 语言提供了函数可以帮助我们生成不同的 Context，通过这些函数可以生成一颗 Context 树，这样 Context 才可以关联起来，父 Context 发出取消信号的时候，子 Context 也会发出，这样就可以控制不同层级的协程退出。</p>
<p>从使用功能上分，有四种实现好的 Context。</p>
<ol>
<li><strong>空 Context</strong>：不可取消，没有截止时间，主要用于 Context 树的根节点。</li>
<li><strong>可取消的 Context</strong>：用于发出取消信号，当取消的时候，它的子 Context 也会取消。</li>
<li><strong>可定时取消的 Context</strong>：多了一个定时的功能。</li>
<li><strong>值 Context</strong>：用于存储一个 key-value 键值对。</li>
</ol>
<p><img src="/../images/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/CgqCHl_EyHOARbBqAAKzKmhclWo807_j9j7DgBnzy.png"></p>
<p><code> context.Background()</code>获取一个根节点 Context。</p>
<hr>
<p> Context 树要怎么生成呢？</p>
<ol>
<li>**<code>WithCancel(parent Context)</code>**：生成一个可取消的 Context。<ol>
<li>**<code>WithDeadline(parent Context, d time.Time)</code>**：生成一个可定时取消的 Context，参数 d 为定时取消的具体时间。<ol>
<li>**<code>WithTimeout(parent Context, timeout time.Duration)</code>**：生成一个可超时取消的 Context，参数 timeout 用于设置多久后取消</li>
</ol>
</li>
</ol>
</li>
<li>**<code>WithValue(parent Context, key, val interface{})</code>**：生成一个可携带 key-value 键值对的 Context。</li>
</ol>
<p>以上四个生成 Context 的函数中，前三个都属于可取消的 Context，它们是一类函数，最后一个是值 Context，用于存储一个 key-value 键值对。</p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    name:=<span class="string">"xiaoming"</span></span><br><span class="line">    <span class="keyword">var</span> nameP *<span class="type">string</span> = &amp;name</span><br><span class="line">    fmt.Println(*nameP)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>获取一个变量的指针非常容易，使用取地址符 &amp; 就可以</p>
</li>
<li><p>指针类型就是在对应的类型前加 * 号</p>
</li>
<li><p>指针类型非常廉价，只占用 4 个或者 8 个字节的内存大小。</p>
</li>
<li><p><em><strong>通过 var 声明的指针变量还没有分配内存</strong></em>，因为这时候它仅仅是个变量，是不能直接赋值和取值的，它的值是 nil </p>
<p><img src="/../images/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/image_xouftL6NE6.png" alt="直接赋值和取值" title="直接赋值和取值"></p>
<p>解决方法：将一块内存地址<code>&amp;m</code>赋值给指针变量<code>*p</code></p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> m <span class="type">int</span></span><br><span class="line">p = &amp;m</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>通过new创建的指针是存在内存地址的，可以直接赋值</p>
<ul>
<li><code>var intP *int = new(int)</code></li>
</ul>
</li>
</ul>
<h1 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h1><p><strong>严格来说，Go 语言没有引用类型</strong>，但是我们可以把 map、chan 称为引用类型，这样便于理解。除了 map、chan 之外，Go 语言中的函数、接口、slice 切片、指针都可以称为引用类型。</p>
<p><img src="/../images/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/image_B8036E8m0p.png"></p>
<p>总结：</p>
<p>在 Go 语言中，<strong>函数的参数传递只有值传递</strong>，而且传递的实参都是原始数据的一份拷贝。</p>
<p>如果拷贝的内容是值类型的，那么在函数中就无法修改原始数据；</p>
<p>如果拷贝的内容是指针（或者可以理解为引用类型 map、chan 等），那么就可以在函数中修改原始数据。</p>
<h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1><ul>
<li>指针类型的变量如果没有分配内存，就默认是零值 nil，它没有指向的内存，所以无法使用，强行使用就会得到以上 nil 指针错误</li>
<li>对于值类型来说，即使只声明一个变量，没有对其初始化，该变量也会有分配好的内存。</li>
<li>两个关键函数：new和make</li>
</ul>
<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>new 函数只用于分配内存，并且把内存清零，也就是返回一个指向对应类型零值的指针。new 函数一般用于需要显式地返回指针的情况，不是太常用。</p>
<h2 id="make"><a href="#make" class="headerlink" title="make"></a>make</h2><p>make 函数只用于 slice、chan 和 map 这三种内置类型的创建和初始化，因为这三种类型的结构比较复杂，比如 slice 要提前初始化好内部元素的类型，slice 的长度和容量等，这样才可以更好地使用它们。</p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><ul>
<li><p><strong><code>reflect.Value</code></strong> 和**<code>reflect.Type</code>**</p>
<p>在 Go 语言的反射定义中，任何接口都由两部分组成：接口的具体类型，以及具体类型对应的值。比如 var i int = 3，因为 <code>interface{}</code> 可以表示任何类型，所以变量 i 可以转为 interface{}。其中 Value 为变量的值，即 3，而 Type 为变量的类型，即 int。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">i:=<span class="number">3</span></span><br><span class="line">iv:=reflect.ValueOf(i)</span><br><span class="line">it:=reflect.TypeOf(i)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>修改变量</p>
<p>要修改一个变量的值，有几个关键点：传递指针（可寻址），通过 Elem 方法获取指向的值，才可以保证值可以被修改，reflect.Value 为我们提供了 CanSet 方法判断是否可以修改该变量。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">ipv := reflect.ValueOf(&amp;i)</span><br><span class="line">ipv.Elem().SetInt(<span class="number">4</span>)</span><br><span class="line">fmt.Println(i)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>反射的三大定律</p>
<ol>
<li>任何接口值 <code>interface{}</code> 都可以反射出反射对象，也就是 reflect.Value 和 reflect.Type，通过函数 reflect.ValueOf 和 reflect.TypeOf 获得。</li>
<li>反射对象也可以还原为 interface{} 变量，也就是第 1 条定律的可逆性，通过 reflect.Value 结构体的 Interface 方法获得。</li>
<li>要修改反射的对象，该值必须可设置，也就是可寻址，参考上节课修改变量的值那一节的内容理解。</li>
</ol>
</li>
</ul>
<h1 id="SliceHeader"><a href="#SliceHeader" class="headerlink" title="SliceHeader"></a>SliceHeader</h1><ul>
<li><p>在 Go 语言中，切片其实是一个结构体，定义如下：</p>
<p><img src="/../images/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/image_GCPR--tEED.png"></p>
<p>SliceHeader 是切片在运行时的表现形式，它有三个字段 Data、Len 和 Cap。</p>
<ol>
<li>Data 用来指向存储切片元素的数组。</li>
<li>Len 代表切片的长度。</li>
<li>Cap 代表切片的容量。</li>
</ol>
</li>
<li><p>优点</p>
<ol>
<li>支持动态扩容</li>
<li>切片的本质是 SliceHeader，又因为函数的参数是值传递，所以传递的是 SliceHeader 的副本，而不是底层数组的副本。这时候切片的优势就体现出来了，因为 SliceHeader 的副本内存占用非常少，即使是一个非常大的切片，也顶多占用 24 个字节的内存，这就解决了大数组在传参时内存浪费的问题。</li>
</ol>
</li>
</ul>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ul>
<li>测试文件以_test.go结尾</li>
<li>测试函数以Testxxx（xxx为测试函数名）开头</li>
</ul>
<p>假设编写的函数在<em>ch18/main.go</em>中：<code>go test -v ./ch18</code></p>
<hr>
<ul>
<li>go test -v –coverprofile=ch18.cover ./ch18：得到一个单元测试覆盖率文件</li>
</ul>
<h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h2><p>衡量代码的性能</p>
<ul>
<li><p>函数必须以 Benchmark 开头</p>
</li>
<li><p>函数的签名必须接收一个指向 testing.B 类型的指针，并且不能返回任何值；</p>
</li>
<li><p>最后的 for 循环很重要，被测试的代码要放到循环里；</p>
</li>
<li><p>b.N 是基准测试框架提供的，表示循环的次数，因为需要反复调用测试的代码，才可以评估性能。</p>
</li>
<li><p>运行：<code>go test -bench=. ./ch18</code></p>
<p><img src="/../images/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/image_TRt00J58vX.png"></p>
</li>
<li><p>计时方法</p>
<p><img src="/../images/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/image_3wVKmmQ8bg.png"></p>
</li>
<li><p>内存统计</p>
<p><img src="/../images/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/image_MfFsm1QCxq.png"></p>
</li>
<li><p>并发基准测试</p>
<p><img src="/../images/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/image_MgQUA96T3S.png"></p>
</li>
</ul>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>Go的泛型使用<code>interface</code>实现</p>
<ul>
<li>an approximation element <code>~T</code> restricts to all types whose underlying type is T: 代表底层类型是<code>T</code></li>
<li>a union element <code>T1 | T2 | ...</code> restricts to any of the listed elements: 代表<code>或</code>,类型列表之一。</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 任意类型 any</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span>[<span class="title">T1</span>, <span class="title">T2</span> <span class="title">any</span>]<span class="params">(x <span class="type">int</span>, y T1)</span></span> T2 {</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Integer <span class="keyword">interface</span> {</span><br><span class="line">  Signed | Unsigned</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Signed <span class="keyword">interface</span> {</span><br><span class="line">  ~<span class="type">int</span> | ~<span class="type">int8</span> | ~<span class="type">int16</span> | ~<span class="type">int32</span> | ~<span class="type">int64</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Unsigned <span class="keyword">interface</span> {</span><br><span class="line">  ~<span class="type">uint</span> | ~<span class="type">uint8</span> | ~<span class="type">uint16</span> | ~<span class="type">uint32</span> | ~<span class="type">uint64</span> | ~<span class="type">uintptr</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型抽象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span>[<span class="title">T</span> <span class="title">Integer</span>]<span class="params">(input T)</span></span> T {</span><br><span class="line">  <span class="keyword">if</span> input &lt; <span class="number">0</span> {</span><br><span class="line">    <span class="keyword">return</span> -input</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> input</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>GraphQL入门</title>
    <url>/2024/04/13/GraphQL%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<blockquote>
<p>最近工作中用到了这个技术「GraphQL」，本文记录一下入门学习过程</p>
</blockquote>
<h2 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1 基础概念"></a>1 基础概念</h2><h3 id="1-1-操作类型-Operation-Type"><a href="#1-1-操作类型-Operation-Type" class="headerlink" title="1.1 操作类型 Operation Type"></a>1.1 操作类型 Operation Type</h3><ol>
<li><code>query</code>：查询数据，相当于CRUD 中的 R</li>
<li><code>mutation</code>：变更，对数据进行变更，比如增加、删除、修改，CRUD 中的 CUD</li>
<li><code>substription</code>：订阅，当数据发生更改，进行消息推送</li>
</ol>
<h3 id="1-2-对象类型和标量类型-Object-Type-Scalar-Type"><a href="#1-2-对象类型和标量类型-Object-Type-Scalar-Type" class="headerlink" title="1.2 对象类型和标量类型 Object Type &amp; Scalar Type"></a>1.2 对象类型和标量类型 Object Type &amp; Scalar Type</h3><ol>
<li><strong>对象类型</strong>：用户在 schema 中定义的 <code>type</code></li>
<li><strong>标量类型</strong>：GraphQL 中内置有一些标量类型 <code>String</code>、<code>Int</code>、<code>Float</code>、<code>Boolean</code>、<code>ID</code>，用户也可以定义自己的标量类型</li>
</ol>
<p>例如：</p>
<figure class="highlight graphql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MetaData <span class="punctuation">{</span></span><br><span class="line">    <span class="symbol">fileName</span><span class="punctuation">:</span> String<span class="punctuation">!</span></span><br><span class="line">    <span class="symbol">fileId</span><span class="punctuation">:</span> ID</span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>其中<code>MetaData</code>是对象类型，<code>String</code>、<code>ID</code>等则是标量类型，<code>!</code>表示非空标量</p>
<p>如果一个 GraphQL 服务接受到了一个 <code>query</code>，那么这个 <code>query</code> 将从 <code>Root Query</code> 开始查找，找到对象类型时则使用它的解析函数 Resolver 来获取内容，如果返回的是对象类型则继续使用解析函数获取内容，如果返回的是标量类型则结束获取，直到找到最后一个标量类型。</p>
<h3 id="1-3-模式-Schema"><a href="#1-3-模式-Schema" class="headerlink" title="1.3 模式 Schema"></a>1.3 模式 Schema</h3><p>Schema定义了字段的类型、数据的结构，描述了接口数据请求的规则，Schema 使用一个简单的强类型模式语法，称为模式描述语言（Schema Definition Language, <em><strong>SDL</strong></em>）</p>
<p>如下是一个Schema的demo：</p>
<figure class="highlight graphql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">Query</span> <span class="punctuation">{</span></span><br><span class="line">    metaData<span class="punctuation">(</span><span class="symbol">fileId</span><span class="punctuation">:</span> ID<span class="punctuation">)</span><span class="punctuation">:</span> MetaData</span><br><span class="line"><span class="punctuation">}</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">Mutation</span> <span class="punctuation">{</span></span><br><span class="line">    createMetaData<span class="punctuation">(</span><span class="symbol">fileId</span><span class="punctuation">:</span> ID, <span class="symbol">fileName</span><span class="punctuation">:</span> String, <span class="symbol">fileType</span><span class="punctuation">:</span> String<span class="punctuation">)</span><span class="punctuation">:</span> MetaData</span><br><span class="line"><span class="punctuation">}</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MetaData <span class="punctuation">{</span></span><br><span class="line">    <span class="symbol">fileName</span><span class="punctuation">:</span> String<span class="punctuation">!</span></span><br><span class="line">    <span class="symbol">fileType</span><span class="punctuation">:</span> String</span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>Schema 文件从 Query、Mutation、Subscription 入口开始定义了各个对象类型或标量类型，这些字段的类型也可能是其他的对象类型或标量类型，组成一个<strong>树形结构</strong>，而用户在向服务端发送请求的时候，沿着这个树选择一个或多个分支就可以获取多组信息。</p>
<p>注意：在 Query 查询字段时，是并行执行的，而在 Mutation 变更的时候，是线性执行，一个接着一个，防止同时变更带来的竞态问题，比如说我们在一个请求中发送了两个 Mutation，那么前一个将始终在后一个之前执行。</p>
<h3 id="1-4-解析函数-Resolver"><a href="#1-4-解析函数-Resolver" class="headerlink" title="1.4 解析函数 Resolver"></a>1.4 解析函数 Resolver</h3><p>前端请求信息到达后端之后，需要由解析函数 Resolver 来提供数据：</p>
<figure class="highlight graphql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">query</span> <span class="punctuation">{</span></span><br><span class="line">  hello</span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>对应的同名的解析函数应该是这样的：</p>
<figure class="highlight graphql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="symbol">Query</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">  hello <span class="punctuation">(</span>parent, args, context, info<span class="punctuation">)</span> <span class="punctuation">{</span></span><br><span class="line">    return <span class="punctuation">...</span></span><br><span class="line">  <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>解析函数接受四个参数，分别为</p>
<ol>
<li><code>parent</code>：当前上一个解析函数的返回值</li>
<li><code>args</code>：查询中传入的参数</li>
<li><code>context</code>：提供给所有解析器的上下文信息</li>
<li><code>info</code>：一个保存与当前查询相关的字段特定信息以及 schema 详细信息的值</li>
</ol>
<p>解析函数的返回值可以是一个具体的值，也可以是 Promise 或 Promise 数组。</p>
<h3 id="1-5-请求格式"><a href="#1-5-请求格式" class="headerlink" title="1.5 请求格式"></a>1.5 请求格式</h3><p>下面演示如何通过 Get/Post 方式来执行下面的 GraphQL 查询：</p>
<p><strong>查询文档</strong></p>
<figure class="highlight graphql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">query</span> <span class="punctuation">{</span></span><br><span class="line">  me <span class="punctuation">{</span></span><br><span class="line">    name</span><br><span class="line">  <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>Get/Post请求方式：</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Get 方式</span></span><br><span class="line">http<span class="punctuation">:</span><span class="comment">//localhost:8080/graphql?query={me{name}}</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Post 方式的请求体</span></span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"query"</span><span class="punctuation">:</span> <span class="string">"{me{name}}"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"operationName"</span><span class="punctuation">:</span> <span class="string">""</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"variables"</span><span class="punctuation">:</span> <span class="punctuation">{</span> <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"value"</span><span class="punctuation">,</span> ... <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>标准的 GraphQL POST 请求应当在 HTTP header 中声明 <code>Content-Type: application/json</code>，并且使用 JSON 格式的内容。</p>
<p><strong>返回的格式</strong></p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 正确返回</span></span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"data"</span><span class="punctuation">:</span> <span class="punctuation">{</span> ... <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行时发生错误</span></span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"errors"</span><span class="punctuation">:</span> <span class="punctuation">[</span> ... <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>GraphQL也提供了方便的图形化界面帮助构建GraphQL请求：</p>
<blockquote>
<p>左边是请求信息栏，左下是请求参数栏和请求头设置栏，右边是返回参数栏</p>
</blockquote>
<p><img src="/../images/GraphQL%E5%85%A5%E9%97%A8/image_B7PpTjmpqj.png"></p>
<h2 id="2-GraphQL-Java"><a href="#2-GraphQL-Java" class="headerlink" title="2 GraphQL-Java"></a>2 GraphQL-Java</h2><p>先看一下官网Demo：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> {</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">      <span class="comment">//schema定义，包含一个hello的查询方法</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">schema</span> <span class="operator">=</span> <span class="string">"type Query{hello: String} schema{query: Query}"</span>;</span><br><span class="line">      <span class="type">SchemaParser</span> <span class="variable">schemaParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SchemaParser</span>();</span><br><span class="line">      <span class="comment">// 加载schema并解析为TypeDefinitionRegistry</span></span><br><span class="line">      <span class="type">TypeDefinitionRegistry</span> <span class="variable">typeDefinitionRegistry</span> <span class="operator">=</span> schemaParser.parse(schema);</span><br><span class="line">      <span class="comment">// 定义hello方法触发的操作</span></span><br><span class="line">      <span class="type">RuntimeWiring</span> <span class="variable">runtimeWiring</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeWiring</span>()</span><br><span class="line">              .type(<span class="string">"Query"</span>, builder -&gt; builder.dataFetcher(<span class="string">"hello"</span>, <span class="keyword">new</span> <span class="title class_">StaticDataFetcher</span>(<span class="string">"world"</span>)))</span><br><span class="line">              .build();</span><br><span class="line"></span><br><span class="line">      <span class="type">SchemaGenerator</span> <span class="variable">schemaGenerator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SchemaGenerator</span>();</span><br><span class="line">      <span class="type">GraphQLSchema</span> <span class="variable">graphQLSchema</span> <span class="operator">=</span> schemaGenerator.makeExecutableSchema(typeDefinitionRegistry, runtimeWiring);</span><br><span class="line">      <span class="comment">// 构建GraphQL实例</span></span><br><span class="line">      <span class="type">GraphQL</span> <span class="variable">build</span> <span class="operator">=</span> GraphQL.newGraphQL(graphQLSchema).build();</span><br><span class="line">      <span class="type">ExecutionResult</span> <span class="variable">executionResult</span> <span class="operator">=</span> build.execute(<span class="string">"{hello}"</span>);</span><br><span class="line"></span><br><span class="line">      System.out.println(executionResult.getData().toString());  <span class="comment">// result: {hello=world}</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过这个Demo，我们来看一下GraphQL的实现需要哪些关键组件：</p>
<h3 id="2-1-TypeDefinitionRegistry"><a href="#2-1-TypeDefinitionRegistry" class="headerlink" title="2.1 TypeDefinitionRegistry"></a>2.1 TypeDefinitionRegistry</h3><p><strong>类型定义</strong>。在Java代码中，通过加载Schema文件或描述，将其解析为<code>TypeDefinitionRegistry</code>。</p>
<h3 id="2-2-RuntimeWiring"><a href="#2-2-RuntimeWiring" class="headerlink" title="2.2 RuntimeWiring"></a>2.2 RuntimeWiring</h3><p><strong>运行时织入</strong>。仅有Schema及其类型定义还不够，在Java中要实际运行GraphQL，还需要显式指定定义中的每个操作，该触发什么样的行为，<em>相当于Resolver函数</em></p>
<p>例如，在本例中，<code>builder -&gt; builder.dataFetcher("hello", new StaticDataFetcher("world")</code>表示当查询Query类型下的hello字段时，返回值为”world”。</p>
<h3 id="2-3-GraphQL"><a href="#2-3-GraphQL" class="headerlink" title="2.3 GraphQL"></a>2.3 GraphQL</h3><p><strong>核心组件</strong>。GraphQL实例是我们使用GraphQL最关键的组件，负责对GraphQL请求进行响应</p>
<p>在结合前面<code>TypeDefinitionRegistry</code>和<code>RuntimeWiring</code>的基础上，生成的可运行的GraphQL实例</p>
<h3 id="2-4-ExecutionResult"><a href="#2-4-ExecutionResult" class="headerlink" title="2.4 ExecutionResult"></a>2.4 ExecutionResult</h3><p>每次执行GraphQL操作时，返回的<strong>结果对象</strong>。</p>
<p>其中包含error字段，用于保存执行过程中的报错信息；data字段，用于获取执行结果返回值。</p>
<h3 id="2-5-DataFetchers"><a href="#2-5-DataFetchers" class="headerlink" title="2.5 DataFetchers"></a>2.5 DataFetchers</h3><p><em><strong>Schema中的每个字段都有一个<code>DataFethcer</code>与之关联，</strong></em>在查询执行的时候，它会为查询语句中的每个字段调用合适的<code>DataFetcher</code></p>
<p><code>DataFetcher</code>是一个接口，核心方法是<code>get()</code>，只有一个<code>DataFetcherEnvironment</code>参数：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DataFetcher</span>&lt;T&gt; {</span><br><span class="line"></span><br><span class="line">    T <span class="title function_">get</span><span class="params">(DataFetchingEnvironment environment)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>DataFetchingEnvironment</code>中包含前端传递的字段参数，<code>DataFetchers</code>复杂根据这些参数查找到对应的数据</p>
<p>下面这张图非常形象画的（虽然不是我画的😆）</p>
<p><img src="/../images/GraphQL%E5%85%A5%E9%97%A8/image_hy8ZUSywws.png"></p>
<h2 id="3-实践"><a href="#3-实践" class="headerlink" title="3 实践"></a>3 实践</h2><blockquote>
<p>“Talk is cheap. Show me the code.”</p>
</blockquote>
<p>场景：创建一个文件服务器，能够上传和下载文件，并可以保存和查询文件的元数据</p>
<p>先定义一个Scheme文件<code>schema.graphqls</code>：</p>
<figure class="highlight graphql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">Query</span> <span class="punctuation">{</span></span><br><span class="line">    metaData<span class="punctuation">(</span><span class="symbol">fileId</span><span class="punctuation">:</span> ID<span class="punctuation">)</span><span class="punctuation">:</span> MetaData</span><br><span class="line"><span class="punctuation">}</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">Mutation</span> <span class="punctuation">{</span></span><br><span class="line">    createMetaData<span class="punctuation">(</span><span class="symbol">fileId</span><span class="punctuation">:</span> ID, <span class="symbol">fileName</span><span class="punctuation">:</span> String, <span class="symbol">fileType</span><span class="punctuation">:</span> String<span class="punctuation">)</span><span class="punctuation">:</span> MetaData</span><br><span class="line"><span class="punctuation">}</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MetaData <span class="punctuation">{</span></span><br><span class="line">    <span class="symbol">fileName</span><span class="punctuation">:</span> String</span><br><span class="line">    <span class="symbol">fileType</span><span class="punctuation">:</span> String</span><br><span class="line"><span class="punctuation">}</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mutation</span> createMetaData <span class="punctuation">{</span></span><br><span class="line">    createMetaData<span class="punctuation">(</span><span class="symbol">fileId</span><span class="punctuation">:</span> <span class="string">"%s"</span>, <span class="symbol">fileName</span><span class="punctuation">:</span> <span class="string">"%s"</span>, <span class="symbol">fileType</span><span class="punctuation">:</span> <span class="string">"%s"</span><span class="punctuation">)</span> <span class="punctuation">{</span></span><br><span class="line">        fileName,</span><br><span class="line">        fileType</span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">query</span> <span class="punctuation">{</span></span><br><span class="line">    metaData<span class="punctuation">(</span><span class="symbol">fileId</span><span class="punctuation">:</span> <span class="string">"%s"</span><span class="punctuation">)</span> <span class="punctuation">{</span></span><br><span class="line">        fileName,</span><br><span class="line">        fileType</span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>我们定义一个类<code>GraphQLFactory</code>，用于构建GraphQL实例：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GraphQLFactory</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> GraphQL graphQL;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowire</span></span><br><span class="line">    <span class="keyword">private</span> SpringSQLQueryDataFetcher queryDataFetcher;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowire</span></span><br><span class="line">    <span class="keyword">private</span> SpringSQLMutationDataFetcher mutationDataFetcher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">schemaString</span> <span class="operator">=</span> getGraphQLSchemaResourceAsString(<span class="string">"schema.graphqls"</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">GraphQLSchema</span> <span class="variable">graphQLSchema</span> <span class="operator">=</span> buildSchema(schemaString, queryDataFetcher, mutationDataFetcher);</span><br><span class="line">        <span class="keyword">return</span> GraphQL.newGraphQL(graphQLSchema).build();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> GraphQLSchema <span class="title function_">buildSchema</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> <span class="meta">@NotNull</span> String schemaString,</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> <span class="meta">@NotNull</span> DataFetcher&lt;MetaData&gt; queryDataFetcher,</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> <span class="meta">@NotNull</span> DataFetcher&lt;MetaData&gt; mutationDataFetcher</span></span><br><span class="line"><span class="params">    )</span> {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">TypeDefinitionRegistry</span> <span class="variable">typeDefinitionRegistry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SchemaParser</span>().parse(schemaString);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">RuntimeWiring</span> <span class="variable">runtimeWiring</span> <span class="operator">=</span> buildWiring(queryDataFetcher, mutationDataFetcher);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">SchemaGenerator</span> <span class="variable">schemaGenerator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SchemaGenerator</span>();</span><br><span class="line">        <span class="keyword">return</span> schemaGenerator.makeExecutableSchema(typeDefinitionRegistry, runtimeWiring);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RuntimeWiring <span class="title function_">buildWiring</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> RuntimeWiring.newRuntimeWiring()</span><br><span class="line">                .type(newTypeWiring(<span class="string">"Query"</span>).dataFetcher(<span class="string">"metaData"</span>, queryDataFetcher))</span><br><span class="line">                .type(newTypeWiring(<span class="string">"Mutation"</span>).dataFetcher(<span class="string">"createMetaData"</span>, mutationDataFetcher))</span><br><span class="line">                .build();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接下来我们创建对应的<code>DataFetchers</code>，分别对Schema中定义的<code>createMetaData</code>和<code>metaData</code>方法进行实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringSQLQueryDataFetcher</span> <span class="keyword">implements</span> <span class="title class_">DataFetcher</span>&lt;MetaData&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MetaData <span class="title function_">get</span><span class="params">(<span class="keyword">final</span> DataFetchingEnvironment dataFetchingEnvironment)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">fileId</span> <span class="operator">=</span> dataFetchingEnvironment.getArgument(FILE_ID);</span><br><span class="line">        <span class="comment">// select from db</span></span><br><span class="line">        <span class="type">MetaData</span> <span class="variable">metaData</span> <span class="operator">=</span> getMetaDataByFileId(fileId);</span><br><span class="line">        <span class="keyword">return</span> metaData;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringSQLMutationDataFetcher</span> <span class="keyword">implements</span> <span class="title class_">DataFetcher</span>&lt;MetaData&gt; {</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FILE_ID</span> <span class="operator">=</span> <span class="string">"fileId"</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FILE_NAME</span> <span class="operator">=</span> <span class="string">"fileName"</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FILE_TYPE</span> <span class="operator">=</span> <span class="string">"fileType"</span>;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> MetaData <span class="title function_">get</span><span class="params">(<span class="keyword">final</span> DataFetchingEnvironment dataFetchingEnvironment)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">      <span class="keyword">final</span> <span class="type">String</span> <span class="variable">fileId</span> <span class="operator">=</span> dataFetchingEnvironment.getArgument(FILE_ID);</span><br><span class="line">      <span class="keyword">final</span> <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> dataFetchingEnvironment.getArgument(FILE_NAME);</span><br><span class="line">      <span class="keyword">final</span> <span class="type">String</span> <span class="variable">fileType</span> <span class="operator">=</span> dataFetchingEnvironment.getArgument(FILE_TYPE);</span><br><span class="line"></span><br><span class="line">      updateMetaData(fileId, fileName, fileType);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> MetaData.of(</span><br><span class="line">              Stream.of(</span><br><span class="line">                      <span class="keyword">new</span> <span class="title class_">AbstractMap</span>.SimpleImmutableEntry&lt;&gt;(FILE_NAME, fileName),</span><br><span class="line">                      <span class="keyword">new</span> <span class="title class_">AbstractMap</span>.SimpleImmutableEntry&lt;&gt;(FILE_TYPE, fileType)</span><br><span class="line">              ).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))</span><br><span class="line">      );</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<p>参考：</p>
<ul>
<li><a href="https://juejin.cn/post/7066694688090095652" title="Graphql+SpringBoot看这一篇就够了">Graphql+SpringBoot看这一篇就够了</a></li>
<li><a href="https://www.cnblogs.com/pku-liuqiang/p/11496914.html" title="GraphQL Java-入门指南">GraphQL Java-入门指南</a></li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>GraphQL</tag>
      </tags>
  </entry>
  <entry>
    <title>JMM</title>
    <url>/2023/06/03/JMM/</url>
    <content><![CDATA[<p>JMM 实际上是 Java 定义的并发编程相关的一组规范</p>
<h3 id="JMM-是如何抽象线程和主内存之间的关系？"><a href="#JMM-是如何抽象线程和主内存之间的关系？" class="headerlink" title="JMM 是如何抽象线程和主内存之间的关系？"></a>JMM 是如何抽象线程和主内存之间的关系？</h3><p><img src="/../images/JMM/image.png" alt="img"></p>
<p><strong>什么是主内存？什么是本地内存？</strong></p>
<ul>
<li><strong>主内存</strong>：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量，还是局部变量，类信息、常量、静态变量都是放在主内存中。为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中。</li>
<li><strong>本地内存</strong>：每个线程都有一个私有的本地内存，本地内存存储了该线程以读 / 写共享变量的副本。每个线程只能操作自己本地内存中的变量，无法直接访问其他线程的本地内存。如果线程间需要通信，必须通过主内存来进行。本地内存是 JMM 抽象出来的一个概念，并不真实存在，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</li>
</ul>
<p><strong>关于JMM的一些同步的约定：</strong></p>
<p>1、线程解锁前，必须把共享变量<strong>立刻</strong>刷回主存；</p>
<p>2、线程加锁前，必须<strong>读取主存</strong>中的最新值到工作内存中；</p>
<span id="more"></span>

<h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>内存交互操作有8种，虚拟机实现必须保证每一个操作都是<strong>原子的</strong>，不可在分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许例外）</p>
<ul>
<li><strong>Read（读取）</strong>：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用；</li>
<li><strong>load（载入）</strong>：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中；</li>
<li><strong>Use（使用）</strong>：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令；</li>
<li><strong>assign（赋值）</strong>：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中；</li>
<li><strong>store（存储）</strong>：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用；</li>
<li><strong>write（写入）</strong>：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中；</li>
<li><strong>lock（锁定）</strong>：作用于主内存的变量，把一个变量标识为线程独占状态；</li>
<li><strong>unlock（解锁）</strong>：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定；</li>
</ul>
<p>即**<code>读-&gt;加载-&gt;使用-&gt;赋值（assign）-&gt;写-&gt;存储</code>**</p>
<p><strong>JMM对这八种指令的使用，制定了如下规则：</strong></p>
<ul>
<li><p>不允许read和load、store和write操作之一单独出现，必须成对使用。即使用了read必须load，使用了store必须write</p>
</li>
<li><p>不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存</p>
</li>
<li><p>不允许一个线程将没有assign的数据从工作内存同步回主内存  </p>
</li>
<li><p>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作</p>
</li>
<li><p>一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁</p>
</li>
<li><p>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值</p>
</li>
<li><p>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量对一个变量进行unlock操作之前，必须把此变量同步回主内存</p>
</li>
</ul>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC基础</title>
    <url>/2023/09/03/JUC%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>线程的生命周期分为五种状态：</p>
<ul>
<li>新生 <code>NEW</code></li>
<li>运行 <code>RUNNABLE</code></li>
<li>阻塞 <code>BLOCKED</code></li>
<li>等待 <code>WAITING</code></li>
<li>超时等待<code>TIME_WAITING</code></li>
<li>终止 <code>TERMINATED</code></li>
</ul>
<p>在操作系统层面，线程有 READY 和 RUNNING 状态；而在 JVM 层面，只能看到 RUNNABLE 状态</p>
<span id="more"></span>

<p><strong>为什么 JVM 没有区分这两种状态呢？</strong> </p>
<p> 现在的时分多任务操作系统架构通常都是用所谓的“时间分片”方式进行抢占式轮转调度。这个时间分片通常是很小的，一个线程一次最多只能在 CPU 上运行比如 10-20ms 的时间（此时处于 running 状态），也即大概只有 0.01 秒这一量级，时间片用后就要被切换下来放入调度队列的末尾等待再次调度。（也即回到 ready 状态）。<em>线程切换的如此之快，区分这两种状态就没什么意义了。</em></p>
<h2 id="wait-sleep"><a href="#wait-sleep" class="headerlink" title="wait/sleep"></a>wait/sleep</h2><p><strong>区别</strong>：</p>
<ul>
<li><p><strong><code>sleep()</code></strong>** 方法没有释放锁，而 <strong><strong><code>wait()</code></strong></strong> 方法释放了锁** 。这是因为<code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，不会操作对象锁，而<code>wait()</code> 则是 <code>Object</code> 类的本地方法，让获得对象锁的线程实现等待</p>
</li>
<li><p><code>wait()</code> 方法被调用后，<em>线程不会自动苏醒</em>，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</p>
</li>
</ul>
<p>因此，<code>wait()</code> 通常被用于线程间交互/通信，<code>sleep()</code>通常被用于暂停当前线程的执行。</p>
<p><strong>为什么 wait() 方法不定义在 Thread 中？</strong></p>
<p><code>wait()</code> 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入等待状态，自然是要操作对应的对象而非当前的线程。</p>
<h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><p><strong>公平锁：</strong> 十分公平，必须先来后到；</p>
<p><strong>非公平锁：</strong> 十分不公平，可以插队；**(默认)**</p>
<h2 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h2><p>lock三部曲</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1.</span> Lock lock=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> lock.lock() 加锁</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> <span class="keyword">finally</span>=&gt; 解锁：lock.unlock();</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Synchronized锁-与Lock锁-的区别"><a href="#Synchronized锁-与Lock锁-的区别" class="headerlink" title="Synchronized锁 与Lock锁 的区别"></a>Synchronized锁 与Lock锁 的区别</h2><ul>
<li>Synchronized 无法判断获取<strong>锁的状态</strong>，Lock可以判断</li>
<li>Synchronized 会<strong>自动释放锁</strong>，lock必须要手动加锁和手动释放锁！可能会遇到死锁</li>
<li>Synchronized 线程1(获得锁-&gt;阻塞)、线程2(等待)；lock就不一定会一直等待下去，lock会有一个<strong>trylock</strong>去尝试获取锁，不会造成长久的等待。</li>
<li>Synchronized <strong>是可重入锁</strong>，不可以中断的，<strong>非公平的</strong>；Lock是可重入的，可以判断锁，可以自己设置公平锁和非公平锁；</li>
<li>Synchronized 适合锁少量的代码同步问题，Lock适合锁大量的同步代码；</li>
</ul>
<h2 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h2><p>实现类：<code>FutureTask</code>，可以获取到线程执行完毕的结果</p>
<p><code>Callable</code>与<code>Runable</code>的区别：</p>
<ul>
<li><code>Callable</code>可以有返回值</li>
<li><code>Callable</code>可以抛出异常，而<code>Runnable</code>不能抛出被检查的异常</li>
<li>启动方法不同</li>
</ul>
<h2 id="线程安全类集合"><a href="#线程安全类集合" class="headerlink" title="线程安全类集合"></a>线程安全类集合</h2><h3 id="List类"><a href="#List类" class="headerlink" title="List类"></a>List类</h3><ul>
<li><p><code>Vector</code></p>
</li>
<li><p><code>Collections.synchronizedList()</code></p>
</li>
<li><p><code>CopyOnWriteArrayList</code></p>
<p>  适用于读多写少的场景</p>
<p>  核心思想是：如果有多个调用者同时要求相同的资源，他们会共同获取相同的指针指向相同的资源，直到某个调用者视图修改资源内容时，系统才会真正复制一份专用副本给该调用者，而其他调用者所见到的最初的资源仍然保持不变。</p>
<p>  读的时候不需要加锁，如果读的时候有多个线程正在向CopyOnWriteArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的CopyOnWriteArrayList。</p>
</li>
</ul>
<p>**<code>CopyOnWriteArrayList</code><strong>比</strong><code>Vector</code>**区别？</p>
<ul>
<li>**<code>Vector</code><strong>底层是使用</strong><code>synchronized</code>**关键字来实现的，效率低下</li>
<li>**<code>CopyOnWriteArrayList</code>**使用的是Lock锁，更加高效</li>
</ul>
<h3 id="Set类"><a href="#Set类" class="headerlink" title="Set类"></a>Set类</h3><ul>
<li><code>Collections.synchronizedSet()</code></li>
<li><code>CopyOnWriteArraySet</code></li>
</ul>
<h3 id="Map类"><a href="#Map类" class="headerlink" title="Map类"></a>Map类</h3><ul>
<li><code>Collections.synchronizedMap()</code></li>
<li><code>ConcurrentHashMap</code></li>
<li><code>HashTable</code></li>
</ul>
<h1 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h1><h2 id="生产者和消费者问题"><a href="#生产者和消费者问题" class="headerlink" title="生产者和消费者问题"></a>生产者和消费者问题</h2><p>这是一个经典的线程通信问题。两组线程共享一个缓冲区。生产者将数据放入缓冲区，消费者将数据从缓冲区取出</p>
<p>demo如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProviderConsumer</span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span>  <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断等待、业务、通知</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        }</span><br><span class="line">        num++;</span><br><span class="line">       System.out.println(Thread.currentThread().getName() + <span class="string">" increment num "</span> + num);</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        }</span><br><span class="line">        num--;</span><br><span class="line">       System.out.println(Thread.currentThread().getName() + <span class="string">" decrement num "</span> + num);</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ProviderConsumer</span> <span class="variable">providerConsumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProviderConsumer</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    providerConsumer.increment();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    providerConsumer.decrement();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"B"</span>).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong>虚假唤醒问题</strong></p>
<blockquote>
<p>当一定的条件触发时会唤醒很多在阻塞态的线程，但只有部分的线程唤醒是有用的，其余线程的唤醒是多余的。  </p>
</blockquote>
<p>  <a href="https://blog.csdn.net/weixin_45668482/article/details/117373700?ydreferer=aHR0cHM6Ly9jbi5iaW5nLmNvbS8=">https://blog.csdn.net/weixin_45668482/article/details/117373700?ydreferer=aHR0cHM6Ly9jbi5iaW5nLmNvbS8%3D</a></p>
<p>解决虚假唤醒问题：应该将唤醒放在循环中，不满足条件需要继续等待</p>
<p>换句话说：将if替换成while。当使用<code>notifyAll()</code>时，所有的线程都将被唤醒，如果使用的是if，不会再次进行条件判断，因此被唤醒的可能是消费者，也可能是生产者。而使用while的时候，会再次进行等待判断，从而避免虚假唤醒问题。</p>
<h3 id="Lock-Condition实现"><a href="#Lock-Condition实现" class="headerlink" title="Lock + Condition实现"></a>Lock + Condition实现</h3><p>Lock锁的Condition可以精准通知唤醒的线程，从而<strong>控制多个线程的执行顺序</strong></p>
<p>demo：多个线程轮流输出A B C</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestCondition</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition3</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 1A 2B 3C</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printA</span><span class="params">()</span> {</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 业务代码 判断 -&gt; 执行 -&gt; 通知</span></span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">1</span>) {</span><br><span class="line">                condition1.await();</span><br><span class="line">            }</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"==&gt; AAAA"</span> );</span><br><span class="line">            num = <span class="number">2</span>;</span><br><span class="line">            condition2.signal();</span><br><span class="line">        }<span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printB</span><span class="params">()</span> {</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">2</span>) {</span><br><span class="line">                condition2.await();</span><br><span class="line">            }</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"==&gt; BBBB"</span> );</span><br><span class="line">            num = <span class="number">3</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        }<span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printC</span><span class="params">()</span> {</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">3</span>) {</span><br><span class="line">                condition3.await();</span><br><span class="line">            }</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"==&gt; CCCC"</span> );</span><br><span class="line">            num = <span class="number">1</span>;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        }<span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h3 id="BlockingQueue实现生产者消费者问题"><a href="#BlockingQueue实现生产者消费者问题" class="headerlink" title="BlockingQueue实现生产者消费者问题"></a>BlockingQueue实现生产者消费者问题</h3><p>BlockingQueue是Java自带的阻塞队列，内部的原理也是使用了ReentrantLock + Condition实现</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    BlockingQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">producer</span> <span class="operator">=</span> () -&gt; {</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                queue.put(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(producer).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(producer).start();</span><br><span class="line">    </span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">consumer</span> <span class="operator">=</span> () -&gt; {</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                queue.take();</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(consumer).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(consumer).start();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="Java中的线程协作"><a href="#Java中的线程协作" class="headerlink" title="Java中的线程协作"></a>Java中的线程协作</h1><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>倒计数锁存器，可以用作一个<strong>简单的开/关锁存器，或者门</strong>：所有线程调用<code>await()</code>在门口等待，直到被调用<code>countDown()</code>的线程打开。</p>
<p>CountDownLatch一个有用的属性是，它不要求调用countDown线程等待计数到达零之前相互等待，它只是阻止任何线程通过await，直到所有线程可以通过。</p>
<p>常用方法：</p>
<ul>
<li>**<code>countDown()</code>**减一操作；</li>
<li><strong><code>await()</code></strong> 等待计数器归零</li>
</ul>
<h3 id="CyclickBarrier"><a href="#CyclickBarrier" class="headerlink" title="CyclickBarrier"></a>CyclickBarrier</h3><p>循环屏障，它允许一组线程全部等待彼此达到共同屏障点的同步辅助。循环阻塞在涉及固定大小的线程方的程序中很有用，这些线程必须偶尔等待彼此。屏障被称为循环，因为它可以在等待的线程被释放之后重新使用。</p>
<p>常用方法包括：</p>
<ul>
<li><strong><code>await()</code></strong>: 调用该方法的线程到达屏障点，并等待其他线程到达。如果是最后一个到达的线程，将执行可选的任务。</li>
<li><code>await(long timeout, TimeUnit unit)</code>: 调用该方法的线程到达屏障点，并等待其他线程到达，但最多等待指定的时间。</li>
<li><code>getParties()</code>: 返回需要到达屏障点的总线程数。</li>
<li><code>isBroken()</code>: 检查屏障是否被破坏（是否有线程等待超时）。</li>
</ul>
<p>**<code>CyclicBarrier </code>****与 ****<code>CountDownLatch </code>**<strong>区别</strong></p>
<ul>
<li><code>CountDownLatch</code>是一次性的，<code>CyclicBarrier</code> 是可以重用的</li>
<li><code>CountDownLatch</code>中有两个关键，一个是<code>countDown()</code>，一个是<code>awit()</code>，调用<code>awit()</code>的线程需要等待，调用<code>countDown()</code>的线程会将倒计时-1，不同的线程职责可能是不同的，被管理的是调用了<code>awit()</code>的线程，计数器可以是单独的逻辑。</li>
</ul>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>信号量，用于控制同时访问某个资源的线程数量。它可以用来限制并发访问的线程数，或者用于线程间的信号通知。</p>
<p><code>Semaphore</code> 维护了一组许可（permits），线程在访问资源之前必须先获得许可，如果许可数不足，则线程必须等待，直到有可用的许可为止。每个 <code>Semaphore</code> 对象都有一个初始许可数，表示可同时访问该资源的线程数。</p>
<p>假设信号量初始数量为sem：</p>
<p>  P 操作：申请一个许可，将 sem 减 1，相减后，如果 <code>sem &lt; 0</code>，则进程/线程进入阻塞等待，否则继续，表明 P 操作可能会阻塞；</p>
<p>  V 操作：释放一个许可，将 sem 加 1，相加后，如果<code> sem &lt;= 0</code>，唤醒一个等待中的进程/线程，表明 V 操作不会阻塞；</p>
<p>常用方法：</p>
<ul>
<li><strong><code>acquire()</code></strong>: 获取一个许可，如果没有可用许可，则线程会被阻塞，直到有可用许可。</li>
<li><strong><code>release()</code></strong>: 释放一个许可，将其返回给 <code>Semaphore</code>。</li>
<li><code>tryAcquire()</code>: 尝试获取一个许可，如果获取成功则返回 true，否则返回 false。</li>
<li><code>availablePermits()</code>: 返回当前可用的许可数。</li>
</ul>
<h2 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h2><p>读写锁，控制对共享资源访问的同步机制。它允许多个线程同时读取资源，但只允许一个线程独占写入资源。</p>
<p>ReadWriteLock的目的是在资源被读取的频率高于写入的情况下优化性能。通过允许并发读取，多个线程可以同时访问资源，这可以提高吞吐量并减少线程之间的竞争。然而，当一个线程希望修改资源时，它需要独占访问以确保一致性。</p>
<h2 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork/Join"></a>Fork/Join</h2><p>核心思想：<strong>分而治之</strong></p>
<p>Fork-Join模型的核心思想是关键概念是”fork”（分叉）和”join”（合并），即将一个大任务划分为若干个小任务，然后并行地执行这些小任务，最后将它们的结果组合起来得到最终的结果。这个过程可以递归地进行，即每个小任务也可以再次划分成更小的子任务，直到任务的规模足够小以至于可以被直接执行。</p>
<p>两个实现类：</p>
<ul>
<li><code>RecursiveTask</code>有返回值</li>
<li><code>RecursiveAction</code>没有返回值</li>
</ul>
<p>Fork/Join框架的优势在于它能够自动地将任务划分成合适的大小，并利用多核处理器上的并行性提高程序的性能。它也提供了一些优化技术，如<em><strong>工作窃取（work stealing）</strong></em>，可以确保各个线程在执行任务时能够充分利用系统资源。</p>
<h3 id="工作窃取原理"><a href="#工作窃取原理" class="headerlink" title="工作窃取原理"></a>工作窃取原理</h3><ol>
<li>每个工作线程都有一个本地的工作队列（<em>双端队列</em>），用于存储待执行的任务。使用双端队列作为本地工作队列的好处在于，工作线程可以高效地从队列的头部或尾部执行插入和删除操作。当工作线程执行任务时，它会从队列的头部获取任务并执行；而当工作线程尝试窃取任务时，它会从队列的尾部插入窃取到的任务。</li>
<li>当一个工作线程的本地工作队列为空时，它会尝试从其他工作线程的工作队列中窃取任务。这个窃取的目标通常是选择一个相对较繁忙的工作线程，即其工作队列中有更多任务等待执行。</li>
<li>工作线程可以从目标工作线程的工作队列的顶部（头部）或者底部（尾部）窃取任务。选择窃取的位置可以根据具体的实现策略来确定，不同的实现方式可能有所不同。</li>
<li>窃取任务的过程通常是通过线程间的原子操作来实现的，以确保并发的正确性。例如，可以使用CAS（Compare and Swap）操作来保证任务的窃取是原子的。</li>
<li>当一个工作线程成功地窃取到任务后，它会将任务添加到自己的本地工作队列中，并继续执行窃取到的任务。</li>
</ol>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java NIO</title>
    <url>/2024/01/10/Java%20NIO/</url>
    <content><![CDATA[<p>NIO的主要组成部分：</p>
<ul>
<li><p><code>Buffer</code>，高效的数据容器，除了布尔类型，所有原始数据类型都有相应的Buffer实现。</p>
</li>
<li><p><code>Channel</code>，类似在Linux之类操作系统上看到的文件描述符，是NIO中被用来支持批量式IO操作的一种抽象。</p>
<p>File或者Socket，通常被认为是比较高层次的抽象，而Channel则是更加操作系统底层的一种抽象，这也使得NIO得以充分利用现代操作系统底层机制，获得特定场景的性能优化，例如，DMA（Direct Memory Access）等。不同层次的抽象是相互关联的，我们可以通过Socket获取Channel，反之亦然。</p>
</li>
<li><p>Selector，是NIO实现多路复用的基础，它提供了一种高效的机制，可以检测到注册在Selector上的多个Channel中，是否有Channel处于就绪状态，进而实现了单线程对多Channel的高效管理。Selector同样是基于底层操作系统机制，不同模式、不同版本都存在区别，例如，在最新的代码库里，相关实现如下：Linux上实现依赖于<a href="http://hg.openjdk.java.net/jdk/jdk/file/d8327f838b88/src/java.base/linux/classes/sun/nio/ch/EPollSelectorImpl.java" title="epoll">epoll</a>，Windows上NIO2（AIO）模式则是依赖于<a href="http://hg.openjdk.java.net/jdk/jdk/file/d8327f838b88/src/java.base/windows/classes/sun/nio/ch/Iocp.java" title="iocp">iocp</a>。</p>
</li>
<li><p>Charset，提供Unicode字符串定义，NIO也提供了相应的编解码器等，例如，通过下面的方式进行字符串到ByteBuffer的转换：</p>
<p><code>Charset.defaultCharset().encode(“Hello world!”));</code></p>
</li>
</ul>
<p><img src="/../images/Java-NIO/image_VP_FzfL6fn.png"></p>
<span id="more"></span>

<h2 id="NIO-Buffer"><a href="#NIO-Buffer" class="headerlink" title="NIO Buffer"></a>NIO Buffer</h2><p>Buffer是NIO操作数据的基本工具，<strong>Buffer存放在堆外内存中</strong>，Java为每种原始数据类型都提供了相应的Buffer实现（布尔除外）</p>
<p><img src="/../images/Java-NIO/image_gSn93Owl5h.png"></p>
<p>Buffer有几个基本属性：</p>
<ul>
<li>capacity，它反映这个Buffer到底有多大，也就是数组的长度。</li>
<li>position，要操作的数据起始位置。</li>
<li>limit，相当于操作的限额。在读取或者写入时，limit的意义很明显是不一样的。比如，读取操作时，很可能将limit设置到所容纳数据的上限；而在写入时，则会设置容量或容量以下的可写限度。</li>
<li>mark，记录上一次postion的位置，默认是0，算是一个便利性的考虑，往往不是必须的。</li>
</ul>
<h3 id="Direct-Buffer和垃圾收集"><a href="#Direct-Buffer和垃圾收集" class="headerlink" title="Direct Buffer和垃圾收集"></a>Direct Buffer和垃圾收集</h3><ul>
<li>Direct Buffer：如果我们看Buffer的方法定义，你会发现它定义了<code>isDirect()</code>方法，返回当前Buffer是否是Direct类型。这是因为Java提供了堆内和堆外（Direct）Buffer，我们可以以它的allocate或者allocateDirect方法直接创建。</li>
<li>MappedByteBuffer：它将文件按照指定大小直接映射为内存区域，当程序访问这个内存区域时将直接操作这块儿文件数据，省去了将数据从内核空间向用户空间传输的损耗。我们可以使用<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/channels/FileChannel.html#map-java.nio.channels.FileChannel.MapMode-long-long-" title="FileChannel.map">FileChannel.map</a>创建MappedByteBuffer，它本质上也是种Direct Buffer。</li>
</ul>
<p>在实际使用中，<strong>Java会尽量对Direct Buffer仅做本地IO操作，对于很多大数据量的IO密集操作</strong>，可能会带来非常大的性能优势，因为：</p>
<ul>
<li>Direct Buffer生命周期内内存地址都不会再发生更改，进而内核可以安全地对其进行访问，很多IO操作会很高效。</li>
<li>减少了堆内对象存储的可能额外维护工作，所以访问效率可能有所提高。</li>
</ul>
<p>Direct Buffer创建和销毁过程中，都会比一般的堆内Buffer增加部分开销，所以通常都建议用于长期使用、数据较大的场景。</p>
<p>另外，大多数垃圾收集过程中，都不会主动收集Direct Buffer，它的垃圾收集过程，就是基于JVM的Cleaner和幻象引用机制，其本身不是public类型，内部实现了一个Deallocator负责销毁的逻辑。对它的销毁往往要拖到full GC的时候，所以使用不当很容易导致OutOfMemoryError。</p>
<h2 id="Java-NIO文件拷贝"><a href="#Java-NIO文件拷贝" class="headerlink" title="Java NIO文件拷贝"></a>Java NIO文件拷贝</h2><p>Java有多种比较典型的文件拷贝实现方式，比如：</p>
<ol>
<li>利用java.io类库，直接为源文件构建一个FileInputStream读取，然后再为目标文件构建一个FileOutputStream，完成写入工作。</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFileByStream</span><span class="params">(File source, File dest)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(source);</span><br><span class="line">         <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dest);){</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line">        <span class="keyword">while</span> ((length = is.read(buffer)) &gt; <span class="number">0</span>) {</span><br><span class="line">            os.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"> }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>利用java.nio类库提供的<code>transferTo()</code>或<code>transferFrom()</code>方法实现。</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFileByChannel</span><span class="params">(File source, File dest)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileChannel</span> <span class="variable">sourceChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(source).getChannel();</span><br><span class="line">         <span class="type">FileChannel</span> <span class="variable">targetChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dest).getChannel();){</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> sourceChannel.size() ;count&gt;<span class="number">0</span> ;) {</span><br><span class="line">            <span class="type">long</span> <span class="variable">transferred</span> <span class="operator">=</span> sourceChannel.transferTo(</span><br><span class="line">                    sourceChannel.position(), count, targetChannel);            sourceChannel.position(sourceChannel.position() + transferred);</span><br><span class="line">            count -= transferred;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="传统的文件拷贝"><a href="#传统的文件拷贝" class="headerlink" title="传统的文件拷贝"></a>传统的文件拷贝</h2><p>当我们使用输入输出流进行读写时，实际上是进行了多次上下文切换，比如应用读取数据时，先在内核态将数据从磁盘读取到内核缓存，再切换到用户态将数据从内核缓存读取到用户缓存。</p>
<p><img src="/../images/Java-NIO/image_chCCeAayev.png"></p>
<h2 id="transferTo"><a href="#transferTo" class="headerlink" title="transferTo"></a>transferTo</h2><p>而基于NIO transferTo的实现方式，在Linux和Unix上，则会使用到<em><strong>零拷贝技术</strong></em>，数据传输并不需要用户态参与，省去了上下文切换的开销和不必要的内存拷贝，进而可能提高应用拷贝性能。</p>
<p>注意，transferTo不仅仅是可以用在文件拷贝中，与其类似的，例如读取磁盘文件，然后进行Socket发送，网络I/O中，同样可以享受这种机制带来的性能和扩展性提高。</p>
<p>transferTo的传输过程：</p>
<p><img src="/../images/Java-NIO/image_FK8ghShkIG.png"></p>
]]></content>
      <categories>
        <category>日常小记</category>
      </categories>
      <tags>
        <tag>Java I/O</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的四大函数式接口</title>
    <url>/2023/04/27/Java%E4%B8%AD%E7%9A%84%E5%9B%9B%E5%A4%A7%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="Function"><a href="#Function" class="headerlink" title="Function<T, R>"></a>Function&lt;T, R&gt;</h2><p>函数式接口 <code>Function&lt;T, R&gt;</code> 的泛型参数解释如下：</p>
<ul>
<li><code>T</code>：表示函数的<em><strong>输入类型</strong></em>，即参数类型。</li>
<li><code>R</code>：表示函数的<em><strong>输出类型</strong></em>，即返回值类型。</li>
</ul>
<span id="more"></span>

<h2 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h2><p>断定型接口，有一个输入参数，返回值为布尔值</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPredicate</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Predicate&lt;String&gt; predicate = String::isEmpty;</span><br><span class="line">        System.out.println(predicate.test(<span class="string">"str"</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Suppier"><a href="#Suppier" class="headerlink" title="Suppier"></a>Suppier</h2><p>供给型接口，没有参数，只有返回值</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSupplier</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Supplier&lt;String&gt; supplier = () -&gt; {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"ok"</span>;</span><br><span class="line">        };</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="Consummer"><a href="#Consummer" class="headerlink" title="Consummer"></a>Consummer</h2><p>消费型接口，只有输入，没有输出</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestConsumer</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Consumer&lt;Integer&gt; consumer = (s) -&gt; {</span><br><span class="line">            System.out.println(s.toString());</span><br><span class="line">        };</span><br><span class="line">        consumer.accept(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>日常小记</category>
      </categories>
  </entry>
  <entry>
    <title>Java中的线程池</title>
    <url>/2023/02/03/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h2 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h2><p>使用<code>Executors</code>创建线程池：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newSingleThreadExecutor(); <span class="comment">//单个线程</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool2</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>); <span class="comment">//创建一个固定的线程池的大小</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool3</span> <span class="operator">=</span> Executors.newCachedThreadPool(); <span class="comment">//可伸缩的线程池</span></span><br></pre></td></tr></tbody></table></figure>

<p>但是不建议使用<code>Executors</code>创建线程池，在阿里巴巴技术规范中写有：</p>
<p><img src="/../images/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20240903160832255.png" alt="image-20240903160832255"></p>
<span id="more"></span>

<blockquote>
<p>使用<code>Executors</code>创建线程池的本质实际上也是调用了<code>ThreadPoolExecutor</code>创建线程池，但是创建的线程池默认配置不太合理？</p>
</blockquote>
<h2 id="TreadPoolExector"><a href="#TreadPoolExector" class="headerlink" title="TreadPoolExector"></a>TreadPoolExector</h2><p><code>ThreadPoolExecutor</code>的构造方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, </span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize, </span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime, </span></span><br><span class="line"><span class="params">                          TimeUnit unit, </span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue, </span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory, </span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>ThreadPoolExecutor</code>的构造函数具有以下七个参数，它们分别是：</p>
<ol>
<li><p><code>corePoolSize</code>（核心线程数）：</p>
<p> 它指定了线程池中保持活动状态的核心线程数量。核心线程是一直存活的线程，即使它们处于空闲状态也不会被回收。当有新任务提交时，核心线程会立即执行任务。如果使用的是无界队列，线程池中的线程数永远不会超过核心线程数。</p>
</li>
<li><p><code>maximumPoolSize</code>（最大线程数）：</p>
<p> 它定义了线程池中允许创建的最大线程数量。当工作队列已满且当前线程数小于最大线程数时，线程池会创建新的线程来执行任务。如果使用的是有界队列，当队列已满且线程数达到最大值时，新的任务会触发拒绝策略。</p>
</li>
<li><p><code>keepAliveTime</code>（线程空闲超时时间）：</p>
<p> 它表示非核心线程空闲的最大时间。当线程池中的线程数超过核心线程数，并且空闲时间超过该值时，多余的线程会被终止并从线程池中移除，以减少资源消耗。新任务到达时，如果线程池中的线程数小于核心线程数，可能会重新创建线程。</p>
</li>
<li><p><code>unit</code>（空闲超时时间的单位）：</p>
<p> 用于指定<code>keepAliveTime</code>参数的单位，可以是<code>TimeUnit.SECONDS</code>、<code>TimeUnit.MILLISECONDS</code>等。</p>
</li>
<li><p><code>workQueue</code>（工作队列）：</p>
<p> 它定义了用于保存待执行任务的阻塞队列。当任务提交到线程池时，如果线程数小于核心线程数，会创建新线程来执行任务。如果线程数达到核心线程数，而工作队列未满，则将任务放入队列中等待执行。工作队列可以是有界队列（如<code>ArrayBlockingQueue</code>）或无界队列（如<code>LinkedBlockingQueue</code>）。</p>
</li>
<li><p><code>threadFactory</code>（线程工厂，可选）：</p>
<p> 线程工厂指定创建线程的方式，用于创建新线程的工厂对象。线程工厂可以根据需要对线程进行自定义配置，例如设置线程名字、设置线程优先级等。如果未指定，将使用默认的<code>DefaultThreadFactory</code></p>
</li>
<li><p><code>handler</code>（拒绝策略，可选）：</p>
<p> 它定义了当线程池无法接受新任务时的处理方式。拒绝策略可以是预定义的几种策略，如抛出异常、丢弃任务、阻塞等。也可以根据需要自定义拒绝策略实现<code>RejectedExecutionHandler</code>接口。</p>
</li>
</ol>
<p>我们可以这样类比：</p>
<p><img src="/../images/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20240903161026674.png" alt="image-20240903161026674"><br><em><strong>注意：核心线程没有空闲时，超量任务首先放入队列中，队列满了才会开普通线程处理！</strong></em></p>
<p>如果<code>corePoolSize</code>为0，则要使用<code>SynchronousQueue</code>避免无限阻塞。因为核心线程为0时，任务会先放入队列中，队列放不下了再使用普通线程，如果队列是无限的就会导致一直阻塞</p>
<h3 id="工作队列-BlockQueue"><a href="#工作队列-BlockQueue" class="headerlink" title="工作队列 BlockQueue"></a>工作队列 BlockQueue</h3><p>使用用<code>ThreadPoolExecutor</code>需要指定一个<code>BlockingQueue</code>任务等待队列。</p>
<p>BlockingQueue（阻塞队列）定义了一组用于插入、获取和检查元素的方法。与普通的队列不同，BlockingQueue在队列为空时，获取元素的操作会被阻塞，直到队列中有可用元素为止。同样地，当队列已满时，插入元素的操作也会被阻塞，直到队列有空闲空间为止。</p>
<p>BlockQueue有四组API：</p>
<p><img src="/../images/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20240903161114544.png" alt="image-20240903161114544"></p>
<p>BlockingQueue提供了多个实现类，其中常用的有以下几种：</p>
<ol>
<li><code>ArrayBlockingQueue</code>：基于数组实现的有界阻塞队列。它在构造时需要指定队列的容量，并且在队列已满时会阻塞插入操作，直到有空闲空间。</li>
<li><code>LinkedBlockingQueue</code>：基于链表实现的可选有界或无界阻塞队列。如果构造时不指定容量，则队列大小默认为无限制。</li>
<li><code>PriorityBlockingQueue</code>：基于优先级堆实现的无界阻塞队列。元素按照优先级进行排序，可以自定义比较器。</li>
<li><code>SynchronousQueue</code>：同步队列。是一个没有容量的阻塞队列，任何一次插入操作的元素都要等待相对的删除/读取操作，否则进行行行插入操作的线程就要一直等待,反之亦然<ol>
<li>进去一个元素，必须等待取出来之后，才能再往里面放入一个元素</li>
<li>使用lock锁保证线程安全的</li>
</ol>
</li>
<li><code>DelayQueue</code>：基于优先级堆实现的延迟阻塞队列。其中的元素必须实现<code>Delayed</code>接口，只有经过一定时间后才能被取出。</li>
</ol>
<p><em><strong>BlockingQueue实现原理：ReentrantLock + Condition</strong></em></p>
<p><code>ArrayBlockingQueue</code>和<code>LinkedBlockingQueue</code>区别：<br>    - <code>ArrayBlockingQueue</code>使用数组作缓冲区，有界，生产者消费者之间使用<strong>独占锁</strong>，即生产者和消费者共用一把缓冲区的锁，出队和入队不能同时进行<br>    - <code>LinkedBlockingQueue</code>使用链表作缓冲区，无界，生产者消费者之间使用<strong>分离锁</strong>，即生产者和消费者分别用一把缓冲区的锁，出队和入队可以同时进行</p>
<h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>  如上面介绍，拒绝策略需要实现<code>RejectedExecutionHandler</code>接口，<code>Executors</code>为我们提供了4种拒绝策略：</p>
<ul>
<li><code>AbortPolicy</code>（默认）：丢弃任务并抛出<code>RejectedExecutionException</code>异常</li>
<li><code>CallerRunsPolicy</code>：直接运行这个任务的run方法，但并非是由线程池处理，而是交由任务的调用线程处理</li>
<li><code>DiscardPolicy</code>：直接丢弃任务，不抛出任何异常</li>
<li><code>DiscardOldestPolicy</code>：将当前处于等待队列列头的等待任务强行取出，然后再试图将当前被拒绝的任务提交</li>
</ul>
<h2 id="常见线程池种类"><a href="#常见线程池种类" class="headerlink" title="常见线程池种类"></a>常见线程池种类</h2><p>四种线程池的特点：</p>
<ul>
<li><code>SingleThreadExecutor</code>单线程线程池<ul>
<li>特点：线程池只有一个线程</li>
<li>使用一个<code>LinkedBlockingQueue</code>作为工作队列，未指定容量（默认值<code>Integer.MAX_VALUE</code>）</li>
</ul>
</li>
<li><code>FixedThreadPool</code>固定线程池<ul>
<li>特点：最大线程数就是核心线程数，<strong>即只有核心线程</strong></li>
<li><code>keepAliveTime=0</code>，但核心线程不会被回收或者销毁</li>
<li>无界队列：使用<code>LinkedBlockingQueue</code>作为工作队列，未指定容量（默认值<code>Integer.MAX_VALUE</code>）</li>
<li>适用于需要有一定持续并发量的场景</li>
</ul>
</li>
<li><code>CachedThreadPool</code>缓存线程池<ul>
<li><strong>没有核心线程，普通线程数量无限</strong></li>
<li><code>keepAliveTime=60</code>，线程闲置60s后回收</li>
<li>使用<code>SynchronousQueue</code>作为工作队列，它不会保存任务，而是直接将任务交给空闲线程执行</li>
<li>处理大量短时间工作任务的线程池，适用于项目中多线程的场景不多或者是需要快速响应的场景，即来即处理，且用完释放，不占用过多资源</li>
</ul>
</li>
<li><code>ScheduledThreadPool</code>定时线程池<ul>
<li><strong>指定核心线程数量，普通线程数量无限</strong></li>
<li>任务队列为延时阻塞队列<code>DelayQueue</code></li>
<li>适用用于执行定时或周期性的任务</li>
</ul>
</li>
</ul>
<h2 id="线程池调优"><a href="#线程池调优" class="headerlink" title="线程池调优"></a>线程池调优</h2><p>在设置线程池大小时，可以考虑任务类型和系统资源的特点，以确定适当的线程池大小。具体而言，对于 CPU 密集型任务和 I/O 密集型任务，可以采取以下建议：</p>
<ul>
<li><strong>CPU 密集型任务</strong><ul>
<li>对于 CPU 密集型任务，线程数应与 CPU 核心数相近或稍多一些，以充分利用 CPU 资源，并避免过多的线程竞争和上下文切换开销。</li>
<li>可以通过 <code>Runtime.getRuntime().availableProcessors()</code> 获取当前系统的 CPU 核心数，作为线程池的核心线程数。</li>
<li>由于 CPU 密集型任务不涉及阻塞等待，可以选择较小的工作队列容量或使用 <code>SynchronousQueue</code>，使得任务提交后立即执行。</li>
</ul>
</li>
<li><strong>I/O 密集型任务</strong><ul>
<li>对于 I/O 密集型任务，一般建议将线程数设置为 CPU 核心数的几倍，例如 2 倍或 4 倍，以充分利用 I/O 操作的等待时间，提高系统的吞吐量。</li>
<li>由于 I/O 操作会涉及到阻塞等待，可以设置较大的工作队列容量，以处理可能的任务积压。</li>
</ul>
</li>
</ul>
<p>实际线程池大小的选择还取决于任务的具体特点和系统资源的限制。在实际应用中，可以通过测试和性能调优来确定最佳的线程池大小，确保任务能够高效执行并充分利用系统资源。</p>
<p><a href="/2024/02/03/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9C%A8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5%E4%BB%A5%E5%8F%8A%E5%AF%B9%E5%BA%94%E5%8F%82%E6%95%B0%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1/">线程池在业务中的实践以及对应参数如何设计</a></p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>🐛 LangChain4j-Spring Bug修复记录</title>
    <url>/2024/08/20/LangChain4j-Spring-Bug/</url>
    <content><![CDATA[<p>起因：在使用langchain4j的过程中发现，项目默认只会扫描启动类下的带有<code>@AiService</code>的接口， 并且扫描的方式是通过<code>Reflections</code>扫描启动类所在的classPath而不是通过Spring自带的方法</p>
<p>如果使用<code>@ComponentScan</code>扫描特定的文件路径，那么特定路径下的<code>@AiService</code>接口将不会被扫描并被代理到，最后就导致了Bean无法注入的Bug _(:з」∠)_</p>
<h2 id="相关issue"><a href="#相关issue" class="headerlink" title="相关issue"></a>相关issue</h2><ul>
<li><a href="https://github.com/langchain4j/langchain4j/issues/1606">https://github.com/langchain4j/langchain4j/issues/1606</a></li>
<li><a href="https://github.com/langchain4j/langchain4j-spring/pull/35">https://github.com/langchain4j/langchain4j-spring/pull/35</a></li>
</ul>
<blockquote>
<p><em>Tips</em>：这也是我第一次参加开源，虽然只是做了一个微不足道的贡献，但是还是感觉收获很多吧…一直在担心自己的水平不够所以反复理解反复查资料，但是作者很热心帮我修改了代码并且很快就被处理接受了😃</p>
</blockquote>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>在Springboot中使用<code>context/beanFactory</code>获取带有<code>@AiService</code>的Bean，发现Springboot会自动忽略接口，原因在于<strong>Spring是不会扫描接口的，因为接口没有办法实例化</strong>，因此作者的做法为：</p>
<ol>
<li><code>Reflections</code>扫描当前启动类所在的classPath获取带有<code>@AiService</code>的接口</li>
<li>在<code>BeanFactoryPostProcessor</code>阶段（Bean加载完但还未创建任何Bean实例前），使用<code>AiServiceFactory</code>替换接口的BeanDefinition完成代理替换</li>
</ol>
<p>关键代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Set&lt;Class&lt;?&gt;&gt; findAiServices(ConfigurableListableBeanFactory beanFactory) {</span><br><span class="line">    String[] applicationBean = beanFactory.getBeanNamesForAnnotation(SpringBootApplication.class);</span><br><span class="line">    <span class="type">BeanDefinition</span> <span class="variable">applicationBeanDefinition</span> <span class="operator">=</span> beanFactory.getBeanDefinition(applicationBean[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">String</span> <span class="variable">basePackage</span> <span class="operator">=</span> applicationBeanDefinition.getResolvableType().resolve().getPackage().getName();</span><br><span class="line">    <span class="type">Reflections</span> <span class="variable">reflections</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reflections</span>((<span class="keyword">new</span> <span class="title class_">ConfigurationBuilder</span>()).forPackage(basePackage));</span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; classes = reflections.getTypesAnnotatedWith(AiService.class);</span><br><span class="line">    classes.removeIf(clazz -&gt; !clazz.getName().startsWith(basePackage));</span><br><span class="line">    <span class="keyword">return</span> classes;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>针对以上问题，我在PR中做的主要改动如下：</p>
<h2 id="改动1：获取所有的ComponentScan的basePackage并扫描"><a href="#改动1：获取所有的ComponentScan的basePackage并扫描" class="headerlink" title="改动1：获取所有的ComponentScan的basePackage并扫描"></a>改动1：获取所有的ComponentScan的basePackage并扫描</h2><p>既然需要扫描多个模块，扫描的方式也是通过<code>@ComponentScan</code>指定的，那么就获取所有的<code>@ComponentScan</code>指定的扫描路径进行扫描吧：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Set&lt;String&gt; <span class="title function_">getBasePackages</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> {</span><br><span class="line">  Set&lt;String&gt; basePackages = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  List&lt;String&gt; autoConfigPackages = AutoConfigurationPackages.get(beanFactory);</span><br><span class="line">  basePackages.addAll(autoConfigPackages);</span><br><span class="line">  </span><br><span class="line">  String[] beanNames = beanFactory.getBeanNamesForAnnotation(ComponentScan.class);</span><br><span class="line">  <span class="keyword">for</span> (String beanName : beanNames) {</span><br><span class="line">      Class&lt;?&gt; beanClass = beanFactory.getType(beanName);</span><br><span class="line">      <span class="keyword">if</span> (beanClass != <span class="literal">null</span>) {</span><br><span class="line">          <span class="type">ComponentScan</span> <span class="variable">componentScan</span> <span class="operator">=</span> beanClass.getAnnotation(ComponentScan.class);</span><br><span class="line">          <span class="keyword">if</span> (componentScan != <span class="literal">null</span>) {</span><br><span class="line">              Collections.addAll(basePackages, componentScan.value());</span><br><span class="line">              Collections.addAll(basePackages, componentScan.basePackages());</span><br><span class="line">              <span class="keyword">for</span> (Class&lt;?&gt; basePackageClass : componentScan.basePackageClasses()) {</span><br><span class="line">                  basePackages.add(ClassUtils.getPackageName(basePackageClass));</span><br><span class="line">              }</span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="改动2：自定义ClassPathBeanDefinitionScanner扫描接口"><a href="#改动2：自定义ClassPathBeanDefinitionScanner扫描接口" class="headerlink" title="改动2：自定义ClassPathBeanDefinitionScanner扫描接口"></a>改动2：自定义ClassPathBeanDefinitionScanner扫描接口</h2><p>如果是要与Spring集成的话肯定是使用Spring的方法更好，但是Spring自带的类扫描器会直接过滤接口，因此在这里自定义了一个专用于扫描接口的类扫描器</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassPathAiServiceScanner</span> <span class="keyword">extends</span> <span class="title class_">ClassPathBeanDefinitionScanner</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClassPathAiServiceScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="type">boolean</span> useDefaultFilters)</span> {</span><br><span class="line">        <span class="built_in">super</span>(registry, useDefaultFilters);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isCandidateComponent</span><span class="params">(AnnotatedBeanDefinition beanDefinition)</span> {</span><br><span class="line">        <span class="keyword">return</span> beanDefinition.getMetadata().isInterface() &amp;&amp; beanDefinition.getMetadata().isIndependent();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>那么问题来了，如何让Spring使用我们自定义的类扫描器呢？Spring自带的扫描器都是在<code>@ComponentScan</code>解析流程中创建出来的，我们又不能更改这个流程</p>
<p>但是我们可以在Spring的扫描流程结束后，再扫描一遍不就好了吗？于是这里在<code>postProcessBeanDefinitionRegistry</code>阶段重新进行了一次扫描：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AiServiceScannerProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException {</span><br><span class="line">        <span class="type">ClassPathAiServiceScanner</span> <span class="variable">classPathAiServiceScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathAiServiceScanner</span>(registry, <span class="literal">false</span>);</span><br><span class="line">        classPathAiServiceScanner.addIncludeFilter(<span class="keyword">new</span> <span class="title class_">AnnotationTypeFilter</span>(AiService.class));</span><br><span class="line">        Set&lt;String&gt; basePackages = getBasePackages((ConfigurableListableBeanFactory) registry);</span><br><span class="line">        classPathAiServiceScanner.scan(StringUtils.toStringArray(basePackages));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里的解决方案其实也参考了MyBatis的实现：MyBatis通过<code>@Mapper</code>即可将类注入到Spring中，原理正是在于使用了自定义类扫描器<code>ClassPathMapperScanner</code>扫描所有带有<code>@Mapper</code>和<code>@MapperScan</code>指定的路径，详细过程可以参考 <a href="./Mybatis%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8Cbean%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F.md">Mybatis实现动态注册bean的两种方式</a></p>
<hr>
<p>参考：</p>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1962431">https://cloud.tencent.com/developer/article/1962431</a></li>
<li><a href="https://blog.csdn.net/qq_31086797/article/details/124488829">https://blog.csdn.net/qq_31086797/article/details/124488829</a></li>
</ul>
]]></content>
      <categories>
        <category>日常小记</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>langchain</tag>
      </tags>
  </entry>
  <entry>
    <title>LangChain入门笔记</title>
    <url>/2024/04/27/LangChain%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>LangChain是一个用于开发由语言模型驱动的应用程序的框架。</p>
<p>主要功能：</p>
<ul>
<li><p>调用语言模型</p>
</li>
<li><p>将不同数据源接入到语言模型的交互中</p>
</li>
<li><p>允许语言模型与运行环境交互</p>
</li>
</ul>
</blockquote>
<p><strong>基本架构</strong></p>
<p><img src="/../images/LangChain%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/langchain_stack_dark_0TT7SLpV72.svg"></p>
<p><strong>LangChain中提供的模块</strong></p>
<ul>
<li><p>Modules：支持的模型类型和集成。</p>
</li>
<li><p>Prompt：提示词管理、优化和序列化。</p>
</li>
<li><p>Memory：内存是指在链/代理调用之间持续存在的状态。</p>
</li>
<li><p>Indexes：当语言模型与特定于应用程序的数据相结合时，会变得更加强大-此模块包含用于加载、查询和更新外部数据的接口和集成。</p>
</li>
<li><p>Chain：链是结构化的调用序列（对LLM或其他实用程序）。</p>
</li>
<li><p>Agents：代理是一个链，其中LLM在给定高级指令和一组工具的情况下，反复决定操作，执行操作并观察结果，直到高级指令完成。</p>
</li>
<li><p>Callbacks：回调允许您记录和流式传输任何链的中间步骤，从而轻松观察、调试和评估应用<br>程序的内部。</p>
</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>文档问答</li>
<li>查询数据表格（CSV、SQL、DataFrame等）</li>
<li>API交互、信息提取、文档总结等</li>
</ul>
<h1 id="Model-I-O"><a href="#Model-I-O" class="headerlink" title="Model I/O"></a>Model I/O</h1><p>四个核心组件：</p>
<ul>
<li>Prompts 提示词</li>
<li>Chat Models 聊天模型<ul>
<li>擅长对话</li>
</ul>
</li>
<li>LLMs 纯文本模型<ul>
<li>擅长理解和合成文本方面，例如总结文档、PDF、概念页面等</li>
</ul>
</li>
<li>Output parsers 输出转换器</li>
</ul>
<blockquote>
<p>📌Chat Models 和 LLMs 的区别：</p>
<p>Chat models和LLMs都是LangChain中的语言模型抽象，但是LLMs是纯语言模型，Chat models是针对对话做了优化的聊天模型</p>
</blockquote>
<h1 id="Agents"><a href="#Agents" class="headerlink" title="Agents"></a>Agents</h1><blockquote>
<p>大型语言模型（LLMs）非常强大，但它们缺乏“最笨”的计算机程序可以轻松处理的特定能力。LLM 对逻辑推理、计算和检索外部信息的能力较弱，这与最简单的计算机程序形成对比。例如，语言模型无法准确回答简单的计算问题，还有当询问最近发生的事件时，其回答也可能过时或错误，因为无法主动获取<br>最新信息。这是由于当前语言模型仅依赖预训练数据，与外界“断开”。要克服这一缺陷， LangChain 框<br>架提出了 “代理”(Agent) 的解决方案。</p>
</blockquote>
<p>Agent作为语言模型的外部模块，可提供计算、逻辑、检索等功能的支持，使语言模型获得异常强大的推理和获取信息的超能力。</p>
<hr>
<p>Agents的核心思想是使用语言模型来选择要采取的一系列Action</p>
<p>在langchain中，一系列Action被硬编码（在代码中）。</p>
<p>在Agents中，语言模型被用作推理引擎来确定要采取哪些操作以及按什么顺序。</p>
<p>不同Agents的区别：不同的推理提示风格、不同的编码输入方式以及不同的解析输出方式。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h3><p>构建代理的核心组件</p>
<ul>
<li><code>AgentAction</code> 即Action，表示代理执行的操作，通常表示调用tools<ul>
<li>我们将想让对Agents的操作封装成Action（tools），再让Agents在被调用时选择应该使用哪些tools</li>
<li>在<code>AgentAction</code>中有两个属性：<code>tool</code>和<code>tool_input</code>，分别代表工具的名字和工具输入</li>
</ul>
</li>
<li><code>AgentFinish</code>  Agents返回的最终结果</li>
<li><code>Intermediate Steps</code> 中间步骤。代表<code>AgentAction</code>以及当前Agents运行的相应输出</li>
</ul>
<h3 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h3><ul>
<li><code>Agent Inputs</code> Agents的输入，键值对类型<ul>
<li>required：<code>intermediate_steps</code></li>
</ul>
</li>
<li><code>Agent Outputs</code> Agents的响应，分为<code>Union[AgentAction, List[AgentAction], AgentFinish]</code><ul>
<li>输出解析器负责获取原始 LLM 输出并将其转换为这三种类型之一</li>
</ul>
</li>
</ul>
<p>demo：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">agent = (</span><br><span class="line">    {</span><br><span class="line">        <span class="string">"input"</span>: <span class="keyword">lambda</span> x: x[<span class="string">"input"</span>],</span><br><span class="line">        <span class="string">"agent_scratchpad"</span>: <span class="keyword">lambda</span> x: format_to_openai_tool_messages(</span><br><span class="line">            x[<span class="string">"intermediate_steps"</span>]</span><br><span class="line">        ),</span><br><span class="line">    }</span><br><span class="line">    | prompt</span><br><span class="line">    | llm_with_tools</span><br><span class="line">    | OpenAIToolsAgentOutputParser()</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>

<h4 id="Agents-API"><a href="#Agents-API" class="headerlink" title="Agents API"></a>Agents API</h4><ul>
<li><code>AgentExecutor</code> 重复调用Agents并执行工具<ul>
<li>封装了各种错误处理、日志等</li>
</ul>
</li>
</ul>
<h3 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h3><p>工具是代理可以调用​​的功能。 <code>Tool</code> 抽象由两个组件组成：</p>
<p>工具 API 的目标是比使用通用文本完成或聊天 API 更可靠地返回有效且有用的工具调用。</p>
<ul>
<li>schema</li>
<li>function</li>
</ul>
<p>设计Agents的关键：</p>
<ul>
<li>让Agents正确的使用tools</li>
<li>以对代理最有帮助的方式描述工具</li>
</ul>
<h2 id="Agent-Type"><a href="#Agent-Type" class="headerlink" title="Agent Type"></a>Agent Type</h2><p>介绍几个常用的Agent Type</p>
<p>ReAct：LLM 可以循环进行 Reasoning 和 Action 步骤的过程。它启用了一个多步骤的过程来识别答案。</p>
<h1 id="Prompt"><a href="#Prompt" class="headerlink" title="Prompt"></a>Prompt</h1><p>提示词工程和模型微调的区别：</p>
<ul>
<li><p>微调</p>
<ul>
<li>定义：针对预先训练的语言模型，在特定任务的少量数据集上对其进行进一步训练</li>
<li>适用场景：当任务或域定义明确，并且有足够的标记数据可供训练时，通常使用微调过程</li>
</ul>
</li>
<li><p>提示词工程</p>
<ul>
<li>涉及设计自然语言提示或指令，可以指导语言模型执行特定任务</li>
<li>最适合需要高精度和明确输出的任务。提示工程可用于制作引发所需输出的查询</li>
</ul>
</li>
</ul>
<h1 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h1><p><img src="/../images/LangChain%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/memory_diagram-0627c68230aa438f9b5419064d63cbbc_TH.png"></p>
<p>四种主要储存模块：</p>
<ul>
<li><code>ConversationBufferMemory</code>对话缓存</li>
<li><code>ConversationTokenBufferMemory</code>按窗口缓存</li>
<li><code>ConversationTokenBufferMemory</code>按令牌缓存</li>
<li><code>ConversationSummaryBufferMemory</code>按摘要缓存</li>
</ul>
<p>最常见的内存类型之一涉及返回聊天消息列表。这些可以作为单个字符串返回，全部连接在一起（当它们被传递到 LLMs 时有用）或 ChatMessages 列表（当传递到 ChatModels 时有用）。</p>
<p>默认情况下，它们作为单个字符串返回。为了作为消息列表返回，您可以设置 <code>return_messages=True</code></p>
<p><img src="/../images/LangChain%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image_6DBZDWLskV.png"></p>
<h1 id="Chains"><a href="#Chains" class="headerlink" title="Chains"></a>Chains</h1><p>链是指调用序列 - 即 LLM、Tools还是数据预处理步骤的先后顺序。主要支持的方法是使用 LCEL。</p>
<h2 id="LCEL-Chains"><a href="#LCEL-Chains" class="headerlink" title="LCEL Chains"></a>LCEL Chains</h2><p>LangChain Expression Language（LCEL）可以轻松地从基本组件构建复杂的链，并支持开箱即用的功能，例如流式传输、并行性和日志记录，最基本和常见的用例是将Prompt和LLM链接在一起。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">chain = prompt | model | output_parser</span><br></pre></td></tr></tbody></table></figure>

<p><a href="https://python.langchain.com/v0.1/docs/expression_language/get_started/" title="https://python.langchain.com/v0.1/docs/expression_language/get_started/">https://python.langchain.com/v0.1/docs/expression_language/get_started/</a></p>
<p>意义：组合大模型调用中不相关的部分，让开发者省去胶水代码</p>
<p>下面举一些简单的栗子：</p>
<p>模型调用：</p>
<p><img src="/../images/LangChain%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image_I16oGnpYi7.png"></p>
<p>Stream流：</p>
<p><img src="/../images/LangChain%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image_8inhVIpa63.png"></p>
<p>Batch批处理：</p>
<p><img src="/../images/LangChain%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image_HKv1CygTUu.png"></p>
<p>异步调用：</p>
<p><img src="/../images/LangChain%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image_wKdMBtlRZQ.png"></p>
<h1 id="RAG"><a href="#RAG" class="headerlink" title="RAG"></a>RAG</h1><p>全称Retrieval Augmented Generation (RAG)</p>
<p><img src="/../images/LangChain%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/data_connection-95ff2033a8faa5f3ba41376c0f6dd32a_6.jpg"></p>
<p>核心组件：</p>
<ul>
<li><strong>Document loaders</strong>文档加载器</li>
<li>Text Splitting文本分割器，将大文档分割（或分块）为更小的块。</li>
<li>Text Embedding models嵌入模型，用于将文档嵌入到Vector stores中，主要有两种常用方式：<ul>
<li>text2vector</li>
<li>llm</li>
</ul>
</li>
<li>Retrievers检索器，用于在数据源中检索相关信息</li>
<li>Indexing数据库索引，用于检索</li>
</ul>
<h2 id="Retrievers检索"><a href="#Retrievers检索" class="headerlink" title="Retrievers检索"></a>Retrievers检索</h2><p>相关算法：</p>
<ul>
<li><p>基本语义相似度（Basicsemanticsimilarity)</p>
</li>
<li><p>最大边际相关性（Maximummarginalrelevance，MMR)</p>
</li>
<li><p>过滤元数据</p>
</li>
<li><p>LLM辅助检索 SelfQueryRetriever</p>
</li>
<li><p>压缩 ContextualCompressionRetriever</p>
<ul>
<li>工作原理：先使用标准向量检索获得候选文档，然后基于查询语句的语义，使用语言模型压缩这些文档,只保留与问题相关的部分<br><img src="/../images/LangChain%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image_vwodDD-H4n.png"></li>
</ul>
</li>
</ul>
<p>其他类型的检索：</p>
<p>vetordb 并不是唯一一种检索文档的工具。 LangChain 还提供了其他检索文档的方式，例如： TF-IDF 或 SVM 。</p>
<h2 id="对话检索链"><a href="#对话检索链" class="headerlink" title="对话检索链"></a>对话检索链</h2><h3 id="检索链类型"><a href="#检索链类型" class="headerlink" title="检索链类型"></a>检索链类型</h3><p>通过LangChain创建一个检索问答链，对检索到的文档进行问题回答。检索问答链的输入包含以下</p>
<ul>
<li>llm大语言模型</li>
<li><code>chain_type</code>指定传入链（用于将文档传递到 LLM 的上下文窗口中）类型<ul>
<li><strong>Stuff</strong>：只需将所有文档“塞”到一个提示中即可，这是最简单的方法<ul>
<li>API：create_stuff_documents_chain</li>
</ul>
</li>
<li><strong>Map-reduce</strong>：将所有块与问题一起传递给语言模型，获取回复，使用另一个语言模型调用将所有单独的回复总结成最终答案，它可以在任意数量的文档上运行。可以并行处理单个问题，同时也需要更多的调用。它将所有文档视为独立的<ul>
<li>MapReduceDocumentsChain</li>
</ul>
</li>
<li><strong>Refine</strong><ul>
<li>循环许多文档，实际上是迭代的，建立在先前文档的答案之上，非常适合前后因果信息并随时间逐步构建答案，依赖于先前调用的结果。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/../images/LangChain%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/summarization_use_case_2-f2a4d5d60980a79140085fb7f.png" alt="Stuff和MapReduce区别" title="Stuff和MapReduce区别"></p>
<p><img src="/../images/LangChain%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/image_5N5XBgZFMJ.png"></p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.chains.combine_documents.stuff <span class="keyword">import</span> StuffDocumentsChain</span><br><span class="line"><span class="keyword">from</span> langchain.chains.llm <span class="keyword">import</span> LLMChain</span><br><span class="line"><span class="keyword">from</span> langchain_core.prompts <span class="keyword">import</span> PromptTemplate</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define prompt</span></span><br><span class="line">prompt_template = <span class="string">"""Write a concise summary of the following:</span></span><br><span class="line"><span class="string">"{text}"</span></span><br><span class="line"><span class="string">CONCISE SUMMARY:"""</span></span><br><span class="line">prompt = PromptTemplate.from_template(prompt_template)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define LLM chain</span></span><br><span class="line">llm = ChatOpenAI(temperature=<span class="number">0</span>, model_name=<span class="string">"gpt-3.5-turbo-16k"</span>)</span><br><span class="line">llm_chain = LLMChain(llm=llm, prompt=prompt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define StuffDocumentsChain</span></span><br><span class="line">stuff_chain = StuffDocumentsChain(llm_chain=llm_chain, document_variable_name=<span class="string">"text"</span>)</span><br><span class="line"></span><br><span class="line">docs = loader.load()</span><br><span class="line"><span class="built_in">print</span>(stuff_chain.run(docs))</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>langchain</tag>
        <tag>LLM</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中的字符串类型</title>
    <url>/2023/09/14/MySQL%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>变量名称</th>
<th>含义</th>
<th>大小</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>固定大小的字符</td>
<td>0-255<strong>个字符</strong></td>
</tr>
<tr>
<td>varchar</td>
<td>可变长度字符串,相当于<code>String</code></td>
<td>0 - 65536<strong>个字符</strong></td>
</tr>
<tr>
<td>Text</td>
<td>文本串,保存大文本</td>
<td>4G</td>
</tr>
<tr>
<td>Blob</td>
<td>二进制大对象，专门用来储存图片，声音，视频等流媒体数据。插入数据的时候，需要使用IO流。</td>
<td>4G</td>
</tr>
</tbody></table>
<span id="more"></span>


<h2 id="CHAR-和-VARCHAR-的定义"><a href="#CHAR-和-VARCHAR-的定义" class="headerlink" title="CHAR 和 VARCHAR 的定义"></a>CHAR 和 VARCHAR 的定义</h2><p><code>CHAR(N)</code> 用来保存固定长度的字符，N 的范围是 0 ~ 255，<strong>请牢记，N 表示的是字符，而不是字节</strong>。<code>VARCHAR(N)</code> 用来保存变长字符，N 的范围为 0 ~ 65536， <strong>N 表示字符</strong>。</p>
<p>在超出 65536 个字符的情况下，可以考虑使用更大的字符类型 TEXT 或 BLOB，两者最大存储长度为 4G，其区别是 BLOB 没有字符集属性，纯属二进制存储。</p>
<p>MySQL 数据库的 VARCHAR 字符类型，最大能够存储 65536 个字符，所以在 MySQL 数据库下，绝大部分场景使用类型 VARCHAR 就足够了。</p>
<p>对于长文本，比如存储博客这样的场景，可以使用<code>Text</code></p>
<p><strong>字符集</strong></p>
<p>在表结构设计中，除了将列定义为 CHAR 和 VARCHAR 用以存储字符以外，还需要额外定义字符对应的字符集，因为每种字符在不同字符集编码下，对应着不同的二进制值。常见的字符集有 GBK、UTF8，通常默认把字符集设置为 UTF8。</p>
<p><strong>推荐把 MySQL 的默认字符集设置为 UTF8MB4</strong>，可以存储emoji 表情</p>
<h2 id="varchar-100-可以存多少中文字符"><a href="#varchar-100-可以存多少中文字符" class="headerlink" title="varchar(100)可以存多少中文字符"></a>varchar(100)可以存多少中文字符</h2><p>不同的字符集，<code>CHAR(N)</code>、<code>VARCHAR(N)</code>对应最长的字节也不相同。</p>
<p>比如 <em><strong>GBK 字符集，1 个字符最大存储 2 个字节，UTF-8字符集支持每个字符最大三3字节，UTF8MB4 字符集 1 个字符最大存储 4 个字节。</strong></em></p>
<blockquote>
<p>注意MySQL中的UTF-8跟平时用的UTF-8有区别，真正的 UTF-8 是每个字符最多四个字节。</p>
</blockquote>
<p>那么在UTF-8字符集的情况下，一个汉字3个字节，<code>varchar(100)</code>可以存放100个中文字符</p>
<h2 id="补充：Unicode-ASCII-UTF-8-GBK-编码的区别"><a href="#补充：Unicode-ASCII-UTF-8-GBK-编码的区别" class="headerlink" title="补充：Unicode ASCII UTF-8 GBK 编码的区别"></a>补充：Unicode ASCII UTF-8 GBK 编码的区别</h2><h3 id="ASCII编码"><a href="#ASCII编码" class="headerlink" title="ASCII编码"></a>ASCII编码</h3><p>ASCII 码使用指定的7 位或8 位二进制数组合来表示128 或256 种可能的字符。</p>
<p><em><strong>长度：1个字节</strong></em></p>
<h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。</p>
<p>Unicode最常用的是用<strong>两个字节表示一个字符</strong>。现代操作系统和大多数编程语言都直接支持Unicode。</p>
<p>新的问题：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p>
<p><em><strong>长度：2个字节</strong></em></p>
<h3 id="UTF8"><a href="#UTF8" class="headerlink" title="UTF8"></a>UTF8</h3><p>所以，本着节约的精神，出现了“可变长编码”的UTF-8编码</p>
<p>UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，<em><strong>常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节</strong></em>。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间。</p>
<p><em><strong>长度：1-6个字节，汉字一般是3个字节</strong></em></p>
<h3 id="GBK-编码"><a href="#GBK-编码" class="headerlink" title="GBK 编码"></a><strong>GBK 编码</strong></h3><p>GBK 编码专门用于表示汉字</p>
<p><em><strong>长度：</strong></em><em><strong>2个字节</strong></em></p>
]]></content>
      <categories>
        <category>日常小记</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis Interceptor</title>
    <url>/2024/01/08/Mybatis-Interceptor/</url>
    <content><![CDATA[<p>我们先来看一下MyBatis的执行过程，这个也是网上的热图了：</p>
<p><img src="/../images/image-20240908231217545.png" alt="image-20240908231217545"></p>
<p>Mybatis的拦截器提供了非常强大的扩展能力。在sql最终执行之前，提供了四个拦截点，支持不同场景的功能扩展：</p>
<ul>
<li><code>Executor</code>：代表执行器，由它调度StatementHandler、ParameterHandler、ResultSetHandler等来执行对应的SQL，其中StatementHandler是最重要的。</li>
<li><code>ParameterHandler</code>：处理SQL参数。</li>
<li><code>ResultSetHandler</code>：进行结果集（ResultSet）的封装返回处理，它非常的复杂，好在不常用。</li>
<li><code>StatementHandler</code>：作用是使用数据库的Statement（PreparedStatement）执行操作，它是四大对象的核心，起到承上启下的作用，许多重要的插件都是通过拦截它来实现的。</li>
</ul>
<span id="more"></span>

<p>每个拦截点提供了多个方法，拦截器是基于方法的</p>
<ul>
<li><code>Executor</code> (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</li>
<li><code>ParameterHandler</code> (getParameterObject, setParameters)</li>
<li><code>ResultSetHandler</code> (handleResultSets, handleOutputParameters)</li>
<li><code>StatementHandler</code> (prepare, parameterize, batch, update, query)</li>
</ul>
<h2 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h2><p>自定义插件实现，重点两步</p>
<ul>
<li>实现接口<code>org.apache.ibatis.plugin.Interceptor</code></li>
<li><code>@Intercepts</code>标志该类是一个拦截器；<code>@Signature</code>定义切点，可以指定多个</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Intercepts({</span></span><br><span class="line"><span class="meta">        @Signature(type = ResultSetHandler.class, method = "handleResultSets", args = {java.sql.Statement.class})</span></span><br><span class="line"><span class="meta">})</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = "sensitive", name = "enabled")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SensitiveInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SensitiveService sensitiveService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable {</span><br><span class="line">        List&lt;Object&gt; results = (List&lt;Object&gt;) invocation.proceed();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (results.isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> results;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ResultSet</span></span><br><span class="line">        <span class="type">ResultSetHandler</span> <span class="variable">resultSetHandler</span> <span class="operator">=</span> (ResultSetHandler) invocation.getTarget();</span><br><span class="line">        <span class="type">MetaObject</span> <span class="variable">metaObject</span> <span class="operator">=</span> SystemMetaObject.forObject(resultSetHandler);</span><br><span class="line">        <span class="type">MappedStatement</span> <span class="variable">mappedStatement</span> <span class="operator">=</span> (MappedStatement) metaObject.getValue(<span class="string">"mappedStatement"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">plugin</span><span class="params">(Object target)</span> {</span><br><span class="line">        <span class="keyword">return</span> Plugin.wrap(target, <span class="built_in">this</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>日常小记</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis学习笔记</title>
    <url>/2022/07/26/Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>MyBatis，原名 iBatis，Java常用ORM矿建，原来是Apache下的一个开源项目，2010 年迁移到 Google code，改名 MyBatis。2013 年迁移到 Github。</p>
<p><strong>官方文档</strong>： <a href="https://mybatis.org/mybatis-3/zh" title="mybatis – MyBatis 3 | Introduction">mybatis – MyBatis 3 | Introduction</a></p>
<h2 id="1-MyBatis使用步骤"><a href="#1-MyBatis使用步骤" class="headerlink" title="1 MyBatis使用步骤"></a>1 MyBatis使用步骤</h2><h3 id="1-1-导入依赖"><a href="#1-1-导入依赖" class="headerlink" title="1.1 导入依赖"></a>1.1 导入依赖</h3><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.26<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<span id="more"></span>

<h3 id="1-2-创建SqlSession"><a href="#1-2-创建SqlSession" class="headerlink" title="1.2 创建SqlSession"></a>1.2 创建SqlSession</h3><p>SqlSession是MyBatis用于执行Sql的关键API</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// MyBatis工具类：用于获取sqlSessionFactory -&gt; sqlSession</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisUtil</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 1.获取sqlSessionFactory对象</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取sqlSession对象</span></span><br><span class="line">    <span class="comment">// sqlSession中完全包含了面向数据库执行sql命令所需的所有方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title function_">getSqlSession</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession(<span class="literal">true</span>);   <span class="comment">// 设置为true表示默认开启事务</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="1-3-XML-配置"><a href="#1-3-XML-配置" class="headerlink" title="1.3 XML 配置"></a>1.3 XML 配置</h3><p><code>mybatis-config.xml</code> 核心配置文件</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">  <span class="string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"${driver}"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"${url}"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"${username}"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"${password}"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"org/mybatis/example/BlogMapper.xml"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>每一个mapper文件都需要在 <code>mybatis-config.xml</code> 中注册</p>
<h3 id="1-4-编写Mapper文件"><a href="#1-4-编写Mapper文件" class="headerlink" title="1.4 编写Mapper文件"></a>1.4 编写Mapper文件</h3><p>定义一个 Mapper 接口，执行数据库的查询操作</p>
<p><code>PersonMapper.xml</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonMapper</span> {</span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">getPersonById</span><span class="params">(Integer personId)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.qing.TestMyBatis.mapper.PersonMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getPersonById"</span> <span class="attr">resultType</span>=<span class="string">"com.qing.TestMyBatis.entity.Person"</span> <span class="attr">parameterType</span>=<span class="string">"Integer"</span>&gt;</span></span><br><span class="line">        select * from person where personId = #{personId}</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>namespace</code> 用于绑定一个 Mapper 接口，<code>id</code> 对应原来方法名</p>
<p><code>resultMap,resultType</code> 返回的结果集，前者返回多个，后者返回单个，值为实体类(集合也是)，注意路径</p>
<p><code>parameterType</code> 输入的参数类型，<code>#{personId}</code> 表示输入的参数，跟方法的参数名对应</p>
<p>原来需要实现 Mapper 接口，现在只需要在 xml 文件中配置即可</p>
<h2 id="2-万能-Map"><a href="#2-万能-Map" class="headerlink" title="2 万能 Map"></a>2 万能 Map</h2><p>给 Dao 传参的时候，如果 <code>parameterType</code> 是一个实体类，就必须要构造完整的对象作为参数，或者写不同的构造方法，Map类型很贴心的解决了这一难题。</p>
<p>简单应用</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addPerson</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtil.getSqlSession();</span><br><span class="line">    <span class="type">PersonMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(PersonMapper.class);</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"id"</span>, <span class="number">6</span>);    <span class="comment">// map中的键可以随意设置名字，可以不需要一一对应</span></span><br><span class="line">    map.put(<span class="string">"hometown"</span>, <span class="string">"shandong"</span>);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> mapper.save(map);</span><br><span class="line">    sqlSession.commit();</span><br><span class="line">    sqlSession.close();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"save"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">    insert bank.person(personId, address) VALUE (#{id},#{hometown})</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>当实体类的属性过多，可以考虑使用 map</p>
<h2 id="3-模糊查询"><a href="#3-模糊查询" class="headerlink" title="3 模糊查询"></a>3 模糊查询</h2><p>方式一：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">"getPersonLike"</span> resultType=<span class="string">"com.qing.TestMyBatis.entity.Person"</span>&gt;</span><br><span class="line">    select * from person where name like <span class="title function_">concat</span><span class="params">(<span class="string">'%'</span>,#{name},<span class="string">'%'</span>)</span></span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>方式二：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">List&lt;Person&gt; list = mapper.getPersonLike(<span class="string">"%q%"</span>);</span><br></pre></td></tr></tbody></table></figure>

<h2 id="4-MyBatis-XML配置文件"><a href="#4-MyBatis-XML配置文件" class="headerlink" title="4 MyBatis XML配置文件"></a>4 MyBatis XML配置文件</h2><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">  <span class="string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"${driver}"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"${url}"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"${username}"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"${password}"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"org/mybatis/example/BlogMapper.xml"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p><code>environment</code> 环境</p>
<p>MyBatis 可以配置成适应多种环境，但每个 SqlSessionFactory 实例只能选择一种环境</p>
</li>
<li><p><code>transactionManager</code> 事务管理器</p>
<p>MyBatis 默认事务管理器是 JDBC</p>
</li>
<li><p><code>dataSource</code> 数据源</p>
<p>使用 properties 属性来实现引用配置文件</p>
</li>
</ul>
<p>在实际开发中，我们一般会将数据库的配置单独房子啊<code>db.properties</code>中，然后引入到<code>mybatis-config.xml</code>中</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">driver=com.mysql.cj.jdbc.Driver</span><br><span class="line">url=jdbc:mysql://localhost:3306/{table_name}?useSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">username=xxxxx</span><br><span class="line">password=xxxxx</span><br></pre></td></tr></tbody></table></figure>

<p>然后在<code>mybatis-config.xml</code>添加：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"db.properties"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="4-2-类型别名"><a href="#4-2-类型别名" class="headerlink" title="4.2 类型别名"></a>4.2 类型别名</h3><p>类型别名是为 Java 类型设置的一个短的名字。它之和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">"com.qing.TestMyBatis.entity.Person"</span> <span class="attr">alias</span>=<span class="string">"Person"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>注意：</p>
<ul>
<li>XML 文件有严格的顺序</li>
<li>别名写在 <code>mybatis-config.xml</code> 中</li>
</ul>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.qing.TestMyBatis.entity"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>使用包名映射，可以扫描到包下的所有实体类，别名默认为类名首字母小写</p>
<h3 id="4-3-映射器"><a href="#4-3-映射器" class="headerlink" title="4.3 映射器"></a>4.3 映射器</h3><p>使用不同映射器进行注入绑定；</p>
<p>第一种：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"com/qing/TestMyBatis/mapper/PerMapper.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>第二种：使用 class 文件绑定注册</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"com.qing.TestMyBatis.mapper.PersonMapper"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>class属性的注意点：</p>
<ul>
<li>接口和他的 Mapper 文件必须同名</li>
<li>接口和他的 Mapper 配置文件必须在同一个包下</li>
</ul>
<p>第三种：使用包扫描进行注册绑定</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.qing.TestMyBatis.mapper.PersonMapper"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>注意点与第二种相同</p>
<h3 id="4-4-ResultMap"><a href="#4-4-ResultMap" class="headerlink" title="4.4 ResultMap"></a>4.4 ResultMap</h3><blockquote>
<p>ResultMap 元素是 MyBatis 中最重要最强大的元素</p>
</blockquote>
<p>当Mapper文件中实体类的属性名和表中的字段名不一致时，就会发生读取错误</p>
<p><strong>因为 MyBatis 是根据字段名去查找对应的<code>getter()</code>和<code>setter()</code>方法，找不到就会返回 null</strong></p>
<p><strong>解决属性名和字段名不一致的问题</strong></p>
<p>解决办法：</p>
<ol>
<li>给字段起别名</li>
<li><code>ResultMap</code></li>
</ol>
<p><code>ResultMap</code>：结果集映射</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"Person"</span> <span class="attr">type</span>=<span class="string">"com.qing.TestMyBatis.entity.Person"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"personId"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"address"</span> <span class="attr">property</span>=<span class="string">"add"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getPersonById"</span> <span class="attr">resultType</span>=<span class="string">"Person"</span> <span class="attr">parameterType</span>=<span class="string">"Integer"</span>&gt;</span></span><br><span class="line">    select * from person where personId = #{id}</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>需要注意，<code>ResultMap</code> 中的 <code>column</code> 和 <code>property</code> 不要用混了！！！**<code>column</code> 代表的是数据库列名，而 <code>property</code> 是实体类的属性名**</p>
<h2 id="7-日志"><a href="#7-日志" class="headerlink" title="7 日志"></a>7 日志</h2><p>如果数据库出现异常，我们需要排错。日志就是最好的助手</p>
<h3 id="7-1-STDOUT-LOGGING"><a href="#7-1-STDOUT-LOGGING" class="headerlink" title="7.1 STDOUT_LOGGING"></a>7.1 STDOUT_LOGGING</h3><p>MyBatis官方自带的日志框架。在核心配置文件中配置该日志：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"STDOUT_LOGGING"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="7-2-Log4j"><a href="#7-2-Log4j" class="headerlink" title="7.2 Log4j"></a>7.2 Log4j</h3><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line">#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码</span><br><span class="line">log4j.rootLogger=DEBUG,console,file</span><br><span class="line"></span><br><span class="line">#控制台输出的相关设置</span><br><span class="line">log4j.appender.console = org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.console.Target = System.out</span><br><span class="line">log4j.appender.console.Threshold=DEBUG</span><br><span class="line">log4j.appender.console.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.console.layout.ConversionPattern=[%c]-%m%n</span><br><span class="line"></span><br><span class="line">#文件输出的相关设置</span><br><span class="line">log4j.appender.file = org.apache.log4j.RollingFileAppender</span><br><span class="line">log4j.appender.file.File=./log/qing.log</span><br><span class="line">log4j.appender.file.MaxFileSize=10mb</span><br><span class="line">log4j.appender.file.Threshold=DEBUG</span><br><span class="line">log4j.appender.file.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n</span><br><span class="line"></span><br><span class="line">#日志输出级别</span><br><span class="line">log4j.logger.org.mybatis=DEBUG</span><br><span class="line">log4j.logger.java.sql=DEBUG</span><br><span class="line">log4j.logger.java.sql.Statement=DEBUG</span><br><span class="line">log4j.logger.java.sql.ResultSet=DEBUG</span><br><span class="line">log4j.logger.java.sql.PreparedStatement=DEBUG</span><br></pre></td></tr></tbody></table></figure>

<p>核心配置文件：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"Log4j"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src="/../images/Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image_MkQjlNyeuN.png"></p>
<h2 id="8-使用注解开发"><a href="#8-使用注解开发" class="headerlink" title="8 使用注解开发"></a>8 使用注解开发</h2><p>注解使用条件：</p>
<ul>
<li>接口与 XML 配置文件必须同名</li>
<li>映射器使用 class</li>
</ul>
<p><code>@Param()</code></p>
<ul>
<li>基本类型前都要加上该注解</li>
<li>引用类型不用加</li>
</ul>
<p><strong>CRUD</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Select("select * from person where name = #{name}")</span></span><br><span class="line">List&lt;Person&gt; <span class="title function_">getPerByName</span><span class="params">(<span class="meta">@Param("name")</span>String name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Delete("delete from person where personId = #{id}")</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">deletePerson</span><span class="params">(<span class="meta">@Param("id")</span> <span class="type">int</span> id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Update("update Person set name = #{name},address = #{add} where personId = #{id}")</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">UpdatePerson</span><span class="params">(Person person)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Insert("insert into person(personId,name,address) value(#{id},#{name},#{add})")</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">addPerson</span><span class="params">(Person person)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>Tips</strong>：<code>#{}</code> 和 <code>${}</code> 的区别</p>
<p><code>#{}</code> 可以防止 sql 注入，能用则用，类似于 <code>PrepareStatement</code></p>
<p><code>${}</code> 不可以防止 sql 注入，早期使用</p>
<h2 id="9-多表查询"><a href="#9-多表查询" class="headerlink" title="9 多表查询"></a>9 多表查询</h2><p><strong>[回顾]MySQL 多表查询</strong></p>
<ul>
<li>子查询</li>
<li>联表查询</li>
</ul>
<p>MyBatis 多表查询</p>
<p><strong>关键字</strong></p>
<ul>
<li><code>column</code> 对应数据库中表的字段</li>
<li><code>property</code> 对应实体类中的属性</li>
<li><code>association</code> 当属性为引用类型时使用，表示对象<ul>
<li><code>javaType</code> 表示属性对应的引用类型</li>
</ul>
</li>
<li><code>collection</code> 当属性为集合时使用，表示集合<ul>
<li><code>ofType</code> 表示集合的泛型信息</li>
</ul>
</li>
</ul>
<p>这里引入两张表：<code>teacher&amp;student</code></p>
<p><img src="/../images/Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image_46ggW4rKS0.png"></p>
<p>其中 <code>student</code> 的 id 与 <code>teacher</code> 的 id 互为外键</p>
<h3 id="9-1-多对一"><a href="#9-1-多对一" class="headerlink" title="9.1 多对一"></a>9.1 多对一</h3><p>实例引入：多个学生对应一个老师</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Teacher teacher;     <span class="comment">// 实体类中含有对象</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>按照查询嵌套处理(类似于子查询)</strong></p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getStudent"</span> <span class="attr">resultMap</span>=<span class="string">"sonSelect"</span>&gt;</span></span><br><span class="line">    select * from student</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"sonSelect"</span> <span class="attr">type</span>=<span class="string">"com.qing.TestMyBatis.entity.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"teacher"</span> <span class="attr">column</span>=<span class="string">"tid"</span> <span class="attr">select</span>=<span class="string">"getTeacher"</span> <span class="attr">javaType</span>=<span class="string">"com.qing.TestMyBatis.entity.Teacher"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getTeacher"</span> <span class="attr">resultType</span>=<span class="string">"com.qing.TestMyBatis.entity.Teacher"</span>&gt;</span></span><br><span class="line">    select * from teacher where id = #{tid}</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>按照结果嵌套处理(类似于联表查询)</strong></p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getStudent"</span> <span class="attr">resultMap</span>=<span class="string">"join"</span>&gt;</span></span><br><span class="line">    select s.id,s.name,s.tid,t.name tname,t.id tid from student s,teacher t where t.id = s.tid</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"join"</span> <span class="attr">type</span>=<span class="string">"com.qing.TestMyBatis.entity.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"teacher"</span> <span class="attr">javaType</span>=<span class="string">"com.qing.TestMyBatis.entity.Teacher"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"tname"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"tid"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>resultMap</code> 用于处理 teacher 属性</p>
<p>查询结果</p>
<p><img src="/../images/Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image_20240905155202694.png"></p>
<p>注意：列起别名一定之后 <code>column="tname"</code> 要用别名，列名冲突也可以使用别名解决</p>
<h3 id="9-2-一对多"><a href="#9-2-一对多" class="headerlink" title="9.2 一对多"></a>9.2 一对多</h3><p>实例引入：一个老师对多个学生</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    List&lt;Student&gt; students;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>按照结果嵌套处理(类似于联表查询)</strong></p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getTeacher"</span> <span class="attr">resultMap</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">    select s.id sid,s.name sname,t.id tid,t.name tname,s.tid stid</span><br><span class="line">    from student s,teacher t</span><br><span class="line">    where s.tid = t.id and  t.id = #{id}</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"map"</span> <span class="attr">type</span>=<span class="string">"Teacher"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"tid"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"tname"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"students"</span> <span class="attr">ofType</span>=<span class="string">"Student"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"sid"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"sname"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"stid"</span> <span class="attr">property</span>=<span class="string">"tid"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>resultMap</code> 用于处理 students 属性</p>
<p><strong>踩坑：column 中写列名或列名的别名，property 中写属性名，二者别搞混了！</strong></p>
<p><strong>按照查询嵌套处理(类似于子查询)</strong></p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getTeacher"</span> <span class="attr">resultMap</span>=<span class="string">"Teach"</span>&gt;</span></span><br><span class="line">    select * from teacher where id = #{id}</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"Teach"</span> <span class="attr">type</span>=<span class="string">"Teacher"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        通过查询到的teacher的id去查student的tid--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"students"</span> <span class="attr">javaType</span>=<span class="string">"ArrayList"</span> <span class="attr">select</span>=<span class="string">"getStudentByTeacherId"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getStudentByTeacherId"</span> <span class="attr">resultType</span>=<span class="string">"Student"</span>&gt;</span></span><br><span class="line">    select * from student where tid = #{tid}</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>注意 <code>collection</code> 中的 <code>javaType</code> 为<strong>ArrayList</strong></p>
<p>查询结果</p>
<p><img src="/../images/Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240905155136614.png"></p>
<p>查询出来的 teacher 的 id 是异常的</p>
<p>总结：</p>
<ul>
<li><code>association</code> 表示一个复杂的联合，用于多对一；</li>
<li><code>collection</code> 表示一个复杂的集合，用于一对多；</li>
</ul>
<h2 id="10-动态-SQL"><a href="#10-动态-SQL" class="headerlink" title="10 动态 SQL"></a>10 动态 SQL</h2><p>什么是动态 SQL？动态 SQL 就是根据不同的条件生成不同的 SQL 语句</p>
<p>可以看一下官方解释：</p>
<blockquote>
<p>动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。</p>
</blockquote>
<p><strong>小技巧</strong>：<strong>UUID</strong></p>
<p>在实际业务中，数据库中表的 ID 并不是按顺序生成的，而是使用 UUID 随机生成的，这样就可以保证唯一性。因为若是按顺序生成，那么删掉一个数之后顺序就打乱了，这是 innodb慢的原因。</p>
<p><strong><code>mapUnderscoreToCamelCase</code></strong></p>
<p>是否开启自动驼峰命名规则映射，即从经典数据库列名到经典 Java 名的类似映射</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"mapUnderscoreToCamelCase"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="10-1-常用标签"><a href="#10-1-常用标签" class="headerlink" title="10.1 常用标签"></a>10.1 常用标签</h3><p>编写实体类</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Blog</span> {</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> views;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="10-2-IF"><a href="#10-2-IF" class="headerlink" title="10.2 IF"></a>10.2 IF</h3><p>需求：查找 Blog，将传入的参数全部用于查找</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryBlogIF"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span> <span class="attr">resultType</span>=<span class="string">"com.qing.TestMyBatis.entity.Blog"</span>&gt;</span></span><br><span class="line">    select * from blog where 1=1</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"title != null"</span>&gt;</span></span><br><span class="line">        and title = #{title}</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"author != null"</span>&gt;</span></span><br><span class="line">        and author = #{author}    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>优化</p>
<p>在上面的 sql 代码中，我们添加了一行 <code>where 1=1</code>，这看起来十分别扭，有没有更好的解决办法？</p>
<h3 id="10-3-where"><a href="#10-3-where" class="headerlink" title="10.3 where"></a>10.3 where</h3><p>MyBatis 提供了一个简单且适合大多数场景的解决办法：where 标签</p>
<blockquote>
<p><em>where</em> 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，<em>where</em> 元素也会将它们去除。</p>
</blockquote>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryBlogIF"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span> <span class="attr">resultType</span>=<span class="string">"com.qing.TestMyBatis.entity.Blog"</span>&gt;</span></span><br><span class="line">    select * from blog</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"title != null"</span>&gt;</span></span><br><span class="line">            and title = #{title}</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"author != null"</span>&gt;</span></span><br><span class="line">            and author = #{author}</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>与 <code>where</code> 作用类似的还有 <code>set</code> 关键字</p>
<h3 id="10-4-set"><a href="#10-4-set" class="headerlink" title="10.4 set"></a>10.4 set</h3><blockquote>
<p><em>set</em> 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）</p>
</blockquote>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateBlog"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">    update Blog</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"title != null"</span>&gt;</span></span><br><span class="line">            title = #{title},</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"author != null"</span>&gt;</span></span><br><span class="line">            author = #{author},</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"views!=null"</span>&gt;</span></span><br><span class="line">            views = #{views},</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where id = #{id}</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="10-5-trim"><a href="#10-5-trim" class="headerlink" title="10.5 trim"></a>10.5 trim</h3><p>trim 元素可以自定义类似于 <em>where</em> 元素功能的标签</p>
<p>和 <em>where</em> 元素等价的自定义 trim 元素为：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"WHERE"</span> <span class="attr">prefixOverrides</span>=<span class="string">"AND |OR "</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><em>prefixOverrides</em> 属性会忽略通过管道符分隔的文本序列（注意此例中的空格是必要的）。上述例子会移除所有 <em>prefixOverrides</em> 属性中指定的内容，并且插入 <em>prefix</em> 属性中指定的内容。</p>
<p>suffixOverrides 表示后缀</p>
<h3 id="10-6-choose，when，otherwise"><a href="#10-6-choose，when，otherwise" class="headerlink" title="10.6 choose，when，otherwise"></a>10.6 choose，when，otherwise</h3><p>类似于 Java 中的 switch</p>
<p>需求：传入了 “title” 就按 “title” 查找，传入了 “author” 就按 “author” 查找</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"testChoose"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span> <span class="attr">resultType</span>=<span class="string">"com.qing.TestMyBatis.entity.Blog"</span>&gt;</span></span><br><span class="line">    select * from blog</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"title != null"</span>&gt;</span></span><br><span class="line">                title like #{title}</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"author!=null"</span>&gt;</span></span><br><span class="line">                author like #{author}</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"views!=null"</span>&gt;</span></span><br><span class="line">                views = #{views}</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">                views &gt; 5000</span><br><span class="line">            <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>所谓的动态 SQL，本质还是 SQL 语句，只是我们可以在 sql 层面去执行一些逻辑代码</strong></p>
<h3 id="10-7-foreach"><a href="#10-7-foreach" class="headerlink" title="10.7 foreach"></a>10.7 foreach</h3><p>动态 SQL 的另一个常用操作需求是对一个集合进行遍历，通常在构建 IN 条件语句的时候</p>
<p>语法：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectPostIn"</span> <span class="attr">resultType</span>=<span class="string">"domain.blog.Post"</span>&gt;</span></span><br><span class="line">  SELECT *</span><br><span class="line">  FROM POST P</span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">collection</span>=<span class="string">"list"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">open</span>=<span class="string">"ID in ("</span> <span class="attr">separator</span>=<span class="string">","</span> <span class="attr">close</span>=<span class="string">")"</span> <span class="attr">nullable</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">          #{item}</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span> </span><br></pre></td></tr></tbody></table></figure>

<p>其中，<code>collection="list</code> 的 list 属性可以用 map 作映射</p>
<p>sql：<code>select * from blog where ID in (item1,item2,item3)</code></p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"TestForEach"</span> <span class="attr">resultType</span>=<span class="string">"com.qing.TestMyBatis.entity.Blog"</span>&gt;</span></span><br><span class="line">    select * from blog</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">open</span>=<span class="string">"ID in ("</span> <span class="attr">separator</span>=<span class="string">","</span> <span class="attr">close</span>=<span class="string">")"</span>&gt;</span></span><br><span class="line">            #{item}</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="10-8-SQL-片段"><a href="#10-8-SQL-片段" class="headerlink" title="10.8 SQL 片段"></a>10.8 SQL 片段</h3><p>SQL 片段就是将 sql 语句中的公共部分提取出来，方便复用</p>
<p>语法：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"if-title-author"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"title != null"</span>&gt;</span></span><br><span class="line">        and title = #{title}</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"author != null"</span>&gt;</span></span><br><span class="line">        and author = #{author}</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryBlogIF"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span> <span class="attr">resultType</span>=<span class="string">"com.qing.TestMyBatis.entity.Blog"</span>&gt;</span></span><br><span class="line">    select * from blog</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"if-title-author"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>注意事项：</p>
<ul>
<li>最好基于单表来定义 SQL 片段，因为某些关键字并不是所有表都支持</li>
<li>不要存在 where 标签</li>
</ul>
<h2 id="11-缓存"><a href="#11-缓存" class="headerlink" title="11 缓存"></a>11 缓存</h2><ul>
<li>什么是缓存<ul>
<li>存在内存中的临时数据</li>
<li>将用户经常查询的数据放在内存中，用户查询数据就可以直接从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题</li>
</ul>
</li>
<li>为什么要使用缓存<ul>
<li>减少和数据库的交互，减少系统开销。</li>
</ul>
</li>
<li>什么样的数据使用缓存<ul>
<li>经常查询并且不经常改变的数据</li>
</ul>
</li>
</ul>
<p>MyBatis缓存原理：</p>
<ol>
<li>先看二级缓存中有没有想要的数据</li>
<li>再去一级缓存中查找</li>
<li>再去数据库中查找</li>
</ol>
<h3 id="11-1-一级缓存"><a href="#11-1-一级缓存" class="headerlink" title="11.1 一级缓存"></a>11.1 一级缓存</h3><ul>
<li>一级缓存也叫本地缓存，与数据库同一次会话期间查询到的数据会放在本地缓存中</li>
<li>MyBatis 默认开启一级缓存</li>
</ul>
<p><strong>一次会话的作用域：开启 SqlSession 到关闭</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtil.getSqlSession();</span><br><span class="line">        <span class="type">BlogMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(BlogMapper.class);</span><br><span class="line">        <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> mapper.getBlog(<span class="string">"%MyBatis%"</span>);</span><br><span class="line">        System.out.println(blog);</span><br><span class="line"></span><br><span class="line">        <span class="type">Blog</span> <span class="variable">blog2</span> <span class="operator">=</span> mapper.getBlog(<span class="string">"%MyBatis%"</span>);</span><br><span class="line">        System.out.println(blog == blog2);</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/../images/Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image_3PtJDMySrr.png"></p>
<p>上面的代码做了两次查询，但实际只从数据库中查了一次</p>
<p>缓存失效的情况：</p>
<ul>
<li>执行增删改操作，可能会改变原来的数据，所以一定会刷新缓存</li>
<li>查询不同的 Mapper.xml</li>
<li>手动清理缓存<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">sqlSession.clearCache();</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p>select 标签中还有一个属性 <code>useCache</code> 表示该元素是否使用缓存，<code>flushCache</code> 属性表示是否刷新缓存</p>
<h3 id="11-2-二级缓存"><a href="#11-2-二级缓存" class="headerlink" title="11.2 二级缓存"></a>11.2 二级缓存</h3><ul>
<li>二级缓存也称为全局缓存，是基于 <code>namespace</code> 级别的缓存</li>
<li>二级缓存的工作机制：<ul>
<li>一个会话查询一条数据，这个数据就会被放在一级缓存当中</li>
<li>如果当前会话关闭了，这个会话对应的一级缓存关闭，一级缓存中的数据就会保存到二级缓存当中</li>
<li>新的会话查询信息，就可以从二级缓存中获取内容</li>
</ul>
</li>
</ul>
<p>二级缓存的开启十分简单，只需要在 mapper.xml 中加上</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>这个简单语句的效果如下:</p>
<ul>
<li>映射语句文件中的所有 select 语句的结果将会被缓存。</li>
<li>映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。</li>
<li>缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存。</li>
<li>缓存不会定时进行刷新（也就是说，没有刷新间隔）。</li>
<li>缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。</li>
<li>缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。</li>
</ul>
<p>我们也可以自定义缓存</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span></span></span><br><span class="line"><span class="tag">  <span class="attr">eviction</span>=<span class="string">"FIFO"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">flushInterval</span>=<span class="string">"60000"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">size</span>=<span class="string">"512"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">readOnly</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>eviction</code> 表示清除策略，可用的清除策略有：</p>
<ul>
<li><code>LRU</code> – 最近最少使用：移除最长时间不被使用的对象。</li>
<li><code>FIFO</code> – 先进先出：按对象进入缓存的顺序来移除它们。</li>
<li><code>SOFT</code> – 软引用：基于垃圾回收器状态和软引用规则移除对象。</li>
<li><code>WEAK</code> – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。</li>
</ul>
<p><code>flushInterval</code> 表示刷新间隔，单位是毫秒</p>
<p><code>size</code> 表示缓存对象可以占用的内存资源</p>
<p><code>readOnly</code> 表示只读属性。只读的缓存会给所有调用者返回缓存对象的相同实例。 因此这些对象不能被修改。这就提供了可观的性能提升。而可读写的缓存会（通过序列化）返回缓存对象的拷贝。 速度上会慢一些，但是更安全，因此默认值是 false。</p>
<p><strong>注意：使用二级缓存的实体类必须实现 <strong><strong><code>Serializable</code></strong></strong> 接口</strong></p>
<p>来看下面一个例子：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtil.getSqlSession();</span><br><span class="line">        <span class="type">BlogMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(BlogMapper.class);</span><br><span class="line">        <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> mapper.getBlog(<span class="string">"%MyBatis%"</span>);</span><br><span class="line">        System.out.println(blog);</span><br><span class="line">        sqlSession.close();</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession1</span> <span class="operator">=</span> MyBatisUtil.getSqlSession();</span><br><span class="line">        <span class="type">BlogMapper</span> <span class="variable">mapper1</span> <span class="operator">=</span> sqlSession1.getMapper(BlogMapper.class);</span><br><span class="line">        <span class="type">Blog</span> <span class="variable">blog1</span> <span class="operator">=</span> mapper1.getBlog(<span class="string">"%MyBatis%"</span>);</span><br><span class="line">        System.out.println(blog1);</span><br><span class="line">        System.out.println(blog == blog1);</span><br><span class="line">        sqlSession1.close();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/../images/Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image_rkuGDtwrcZ.png"></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test2</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtil.getSqlSession();</span><br><span class="line">        <span class="type">BlogMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(BlogMapper.class);</span><br><span class="line">        <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> mapper.getBlog(<span class="string">"%MyBatis%"</span>);</span><br><span class="line">        System.out.println(blog);</span><br><span class="line"></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession1</span> <span class="operator">=</span> MyBatisUtil.getSqlSession();</span><br><span class="line">        <span class="type">BlogMapper</span> <span class="variable">mapper1</span> <span class="operator">=</span> sqlSession1.getMapper(BlogMapper.class);</span><br><span class="line">        <span class="type">Blog</span> <span class="variable">blog1</span> <span class="operator">=</span> mapper1.getBlog(<span class="string">"%MyBatis%"</span>);</span><br><span class="line">        System.out.println(blog1);</span><br><span class="line">        System.out.println(blog == blog1);</span><br><span class="line">        sqlSession.close();</span><br><span class="line">        sqlSession1.close();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/../images/Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image_EiFHuKpTUZ.png"></p>
<p>可以看到 Mybaitis 查询了两次，可见第一个 sqlSession 中的数据在会话关闭之前并没有被放进二级缓存中。并且，使用二级缓存查询出来的两个对象地址并不相等，而一级缓存是相等的。</p>
<p>总结：</p>
<ul>
<li>只要开启了二级缓存，在同一个 Mapper 下就有效</li>
<li>select 的数据会先放在一级缓存中，只有当一级缓存提交或者回滚时才会将数据放在二级缓存当中</li>
</ul>
<h2 id="12-常见-Bug"><a href="#12-常见-Bug" class="headerlink" title="12 常见 Bug"></a>12 常见 Bug</h2><p><img src="/../images/Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6523C60C4B66B4DA1C512EF1397AA555_2DWEdkXWkb.gif"></p>
<p>遇到的报错：</p>
<p><img src="/../images/Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image_459aZ2uDF4.png"></p>
<p>或 <code>java.lang.ExceptionInInitializerError</code> 初始化错误<strong>【最常见】</strong></p>
<p>原因：<strong>由于 Maven 的约定大于配置，xml 文件被过滤</strong></p>
<p>解决：在pom.xml中添加以下代码</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>SPI机制详解</title>
    <url>/2024/01/01/SPI%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>什么是SPI机制？</p>
<p><em><strong>SPI（Service Provider Interface）</strong></em>，是 JDK 内置的一种服务提供发现机制，具体表现为按照约定能够为同一接口提供多种不同的实现，常用来启用框架扩展和替换组件</p>
<p><img src="/../images/SPI%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/image_ieFj3Q2IEV.png"></p>
<p>Java 中 SPI 机制主要思想是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要，其核心思想就是 <strong>解耦</strong>。</p>
</blockquote>
<p>本文探讨SPI在Java和SpringBoot中的实现以及具体的使用姿势</p>
<h1 id="Java-SPI"><a href="#Java-SPI" class="headerlink" title="Java SPI"></a>Java SPI</h1><p>Java SPI 中有四个重要的组件：</p>
<ol>
<li><strong>服务接口</strong>：一个定义了服务提供者实现类契约方法的接口或者抽象类。</li>
<li><strong>服务实现</strong>：实际提供服务的实现类。</li>
<li><strong>SPI 配置文件</strong>：文件名必须存在于 <code>META-INF/services</code> 目录中。文件名应与服务提供商接口完全限定名完全相同。文件中的每一行都有一个实现服务类详细信息，即服务提供者类的完全限定名。</li>
<li><strong>ServiceLoader</strong>： Java SPI 关键类，用于加载服务提供者接口的服务。</li>
</ol>
<p>简单看一个demo：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 标准服务接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Compresser</span> {</span><br><span class="line">    <span class="type">byte</span>[] compress(<span class="type">byte</span>[] bytes);</span><br><span class="line">    <span class="type">byte</span>[] decompress(<span class="type">byte</span>[] bytes);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际服务提供者1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GzipCompresser</span> <span class="keyword">implements</span> <span class="title class_">Compresser</span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] compress(<span class="type">byte</span>[] bytes) {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"compress by Gzip"</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] decompress(<span class="type">byte</span>[] bytes) {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"decompress by Gzip"</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际服务提供者2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZipCompresser</span> <span class="keyword">implements</span> <span class="title class_">Compresser</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] compress(<span class="type">byte</span>[] bytes) {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"compress by Zip"</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] decompress(<span class="type">byte</span>[] bytes) {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"decompress by Zip"</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>编写SPI 配置文件：</p>
<p>在<code>META-INF/services</code>中创建<code>cn.ppphuang.demoserver.serviceproviders.Compresser</code>文件，注意文件名是标准服务接口类的<strong>全限定类名</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">cn.ppphuang.demoserver.serviceproviders.GzipCompresser</span><br><span class="line">cn.ppphuang.demoserver.serviceproviders.ZipCompresser cn.ppphuang.demoserver.serviceproviders.Compresser</span><br></pre></td></tr></tbody></table></figure>

<p>接下来通过 ServiceLoader 加载服务：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">  ServiceLoader&lt;Compresser&gt; serviceLoader = ServiceLoader.load(Compresser.class);</span><br><span class="line">  <span class="keyword">for</span> (Compresser service : serviceLoader) {</span><br><span class="line">    System.out.println(service.getClass().getClassLoader());</span><br><span class="line">    <span class="type">byte</span>[] compress = service.compress(<span class="string">"Hello"</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(compress));</span><br><span class="line">    <span class="type">byte</span>[] decompress = service.decompress(<span class="string">"Hello"</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(decompress));</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">-------------</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">compress by Gzip</span><br><span class="line">decompress by Gzip</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">compress by Zip</span><br><span class="line">decompress by Zip</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="常见SPI案例"><a href="#常见SPI案例" class="headerlink" title="常见SPI案例"></a>常见SPI案例</h2><ul>
<li><p>JDBC SPI</p>
<p>SPI的使用非常广泛，一个比较出名的实现就是JDBC</p>
<p>在JDBC中，我们一般会通过<code>DriverManager</code>去创建与数据库的连接；而<code>DriverManager</code>会查找并加载classPath中不同的<code>Driver</code>的实现</p>
</li>
<li><p>Common-Logging（JCL）</p>
<p>Common-Logging apache是常用的日志库门面。只有接口（<code>LogFactory</code>），没有实现。具体方案由各提供商实现</p>
</li>
</ul>
<h2 id="Java-SPI存在的问题"><a href="#Java-SPI存在的问题" class="headerlink" title="Java SPI存在的问题"></a>Java SPI存在的问题</h2><p>使用 Java SPI 能方便得解耦模块，使得接口的定义与具体业务实现分离。应用程序可以根据实际业务情况启用或替换具体组件。但是也有一些缺点：</p>
<ul>
<li><strong>不能按需加载</strong>。虽然 ServiceLoader 做了延迟载入，但是基本只能通过遍历全部获取，也就是接口的实现类得全部载入并实例化。如果你并不想用某些实现类，或者某些类实例化很耗时，它也被载入并实例化了，这就造成了浪费。</li>
<li><strong>获取某个实现类的方式不够灵活</strong>。只能通过 Iterator 形式获取，不能根据某个参数来获取对应的实现类。</li>
<li>多个并发多线程使用 ServiceLoader 类的实例是不安全的。</li>
</ul>
<h1 id="Spring-SPI"><a href="#Spring-SPI" class="headerlink" title="Spring SPI"></a>Spring SPI</h1><p>Spring的SPI机制其实就是SpringBoot自动装配的原理。在springboot的自动装配过程中，最终会加载<code>META-INF/spring.factories</code>文件，而加载的过程是由<code>SpringFactoriesLoader</code>加载的。</p>
<p><code>@SpringBootApplication</code> → <code>@EnableAutoConfinguration</code>  → <code>@Import(AutoConfigurationImportSelector.class)</code></p>
<p>核心类<code>AutoConfigurationImportSelector</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoConfigurationImportSelector</span> <span class="keyword">implements</span> <span class="title class_">DeferredImportSelector</span>, BeanClassLoaderAware,</span><br><span class="line">    ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered {</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) {</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) {</span><br><span class="line">      <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">AutoConfigurationEntry</span> <span class="variable">autoConfigurationEntry</span> <span class="operator">=</span> getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">    <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">protected</span> AutoConfigurationEntry <span class="title function_">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) {</span><br><span class="line">      <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> getAttributes(annotationMetadata);</span><br><span class="line">    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">    configurations = removeDuplicates(configurations);</span><br><span class="line">    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">    checkExcludedClasses(configurations, exclusions);</span><br><span class="line">    configurations.removeAll(exclusions);</span><br><span class="line">    configurations = getConfigurationClassFilter().filter(configurations);</span><br><span class="line">    fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AutoConfigurationEntry</span>(configurations, exclusions);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> List&lt;String&gt; <span class="title function_">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> {</span><br><span class="line">  List&lt;String&gt; configurations = ImportCandidates.load(AutoConfiguration.class, getBeanClassLoader())</span><br><span class="line">    .getCandidates();</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> configurations;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCATION</span> <span class="operator">=</span> <span class="string">"META-INF/spring/%s.imports"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取资源文件并获取Bean的URL</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ImportCandidates <span class="title function_">load</span><span class="params">(Class&lt;?&gt; annotation, ClassLoader classLoader)</span> {</span><br><span class="line">  Assert.notNull(annotation, <span class="string">"'annotation' must not be null"</span>);</span><br><span class="line">  <span class="type">ClassLoader</span> <span class="variable">classLoaderToUse</span> <span class="operator">=</span> decideClassloader(classLoader);</span><br><span class="line">  <span class="type">String</span> <span class="variable">location</span> <span class="operator">=</span> String.format(LOCATION, annotation.getName());</span><br><span class="line">  Enumeration&lt;URL&gt; urls = findUrlsInClasspath(classLoaderToUse, location);</span><br><span class="line">  List&lt;String&gt; importCandidates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">while</span> (urls.hasMoreElements()) {</span><br><span class="line">    <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> urls.nextElement();</span><br><span class="line">    importCandidates.addAll(readCandidateConfigurations(url));</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ImportCandidates</span>(importCandidates);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>我们可以看一下最后获取到的需要注入的Bean信息：</p>
<p><img src="/../images/SPI%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/image_aJce8e-8zN.png"></p>
<h1 id="Dubbo-SPI"><a href="#Dubbo-SPI" class="headerlink" title="Dubbo SPI"></a>Dubbo SPI</h1><p>补充一下Dubbo SPI 扩展能力的特性：</p>
<ul>
<li>按需加载。Dubbo 的扩展能力不会一次性实例化所有实现，可以根据别名实例化指定的扩展类</li>
<li>增加扩展类的 IOC 能力。Dubbo 的扩展能力并不仅仅只是发现扩展服务实现类，而是在此基础上更进一步，如果该扩展类的属性依赖其他对象，则 Dubbo 会自动的完成该依赖对象的注入功能。</li>
<li>增加扩展类的 AOP 能力。Dubbo 扩展能力会自动的发现扩展类的包装类，完成包装类的构造，增强扩展类的功能。</li>
<li>具备动态选择扩展实现的能力。Dubbo 扩展会基于参数，在运行时动态选择对应的扩展类，提高了 Dubbo 的扩展能力。</li>
<li>可以对扩展实现进行排序。能够基于用户需求，指定扩展实现的执行顺序。</li>
<li>提供扩展点的 Adaptive 能力。该能力可以使的一些扩展类在 consumer 端生效，一些扩展类在 provider 端生效。</li>
</ul>
<p>Dubbo SPI 加载扩展的工作流程：</p>
<p><img src="/../images/SPI%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/image_3P8oDOj5xz.png"></p>
<hr>
<p>参考：</p>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1985623" title="如何在项目中引入SPI">如何在项目中引入SPI</a></li>
<li><a href="https://blog.csdn.net/weixin_41564440/article/details/108705534" title="Spring SPI机制实现自动装配 实现自定义Starter组件">Spring SPI机制实现自动装配 实现自定义Starter组件</a></li>
</ul>
]]></content>
      <categories>
        <category>日常小记</category>
      </categories>
      <tags>
        <tag>SPI</tag>
      </tags>
  </entry>
  <entry>
    <title>Spingboot3.0 升级记录</title>
    <url>/2024/06/21/Spingboot3.0%20%E5%8D%87%E7%BA%A7%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<blockquote>
<p><strong>背景</strong>：在原来一个基于 Spring Boot 2.6.11 的项目中，引入了一个第三方库后，发现无法正常加载其自动装配的 Bean。经过排查，发现第三方库基于 Spring Boot 3.2.4 版本开发，存在依赖注入方式上的差异。为了兼容性，决定将原项目升级至 Spring Boot 3.2.4。鉴于 Spring Boot 3.0 的重大变化，本文详细记录了迁移过程中遇到的关键改动及解决方案。</p>
</blockquote>
<h2 id="Spring-Boot-3-0-主要改动"><a href="#Spring-Boot-3-0-主要改动" class="headerlink" title="Spring Boot 3.0 主要改动"></a>Spring Boot 3.0 主要改动</h2><p>以下是 Spring Boot 3.0 中最重要的变动：</p>
<ul>
<li><strong>最低 Java 版本要求</strong>：升级至 Java 17。</li>
<li><strong>移除内置配置</strong>：例如，MySQL 驱动等配置被移除，官方提供迁移工具协助升级：</li>
</ul>
<span id="more"></span>

<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-properties-migrator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>Jakarta EE 替代 Java EE</strong>：所有 <code>javax</code> 包被替换为 <code>jakarta</code> 包：</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">javax.persistence.*   -&gt; jakarta.persistence.*</span><br><span class="line">javax.validation.*    -&gt; jakarta.validation.*</span><br><span class="line">javax.servlet.*       -&gt; jakarta.servlet.*</span><br><span class="line">javax.annotation.*    -&gt; jakarta.annotation.*</span><br><span class="line">javax.transaction.*   -&gt; jakarta.transaction.*</span><br></pre></td></tr></tbody></table></figure>

<p>更多改动详情，参考官方文档：<a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Release-Notes">Spring Boot 3.0 发布说明</a></p>
<h2 id="项目迁移中发现的问题"><a href="#项目迁移中发现的问题" class="headerlink" title="项目迁移中发现的问题"></a>项目迁移中发现的问题</h2><h3 id="自定义-Starter-不兼容"><a href="#自定义-Starter-不兼容" class="headerlink" title="自定义 Starter 不兼容"></a>自定义 Starter 不兼容</h3><p>原版本中自定义 Starter 的方式为：在扫描类上使用 <code>@Configuration</code> 注解，并在 <code>META-INF/spring.factories</code> 文件中声明该扫描类：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">{{启动类路径}}</span><br></pre></td></tr></tbody></table></figure>

<p>新版中，自定义 Starter 应采用 <code>@AutoConfiguration</code> 注解，并在 <code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code> 文件中声明扫描类：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">{{启动类路径}}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Mybatis-兼容性问题"><a href="#Mybatis-兼容性问题" class="headerlink" title="Mybatis 兼容性问题"></a>Mybatis 兼容性问题</h3><p><img src="/../images/Spingboot3.0-%E5%8D%87%E7%BA%A7%E8%AE%B0%E5%BD%95/Secure2%20Image.png" alt="Secure2 Image"></p>
<p><strong>原因</strong>：Mybatis 旧版本与 Spring Boot 3.0 不兼容，需升级至 Mybatis 3.x 版本或更高。</p>
]]></content>
      <categories>
        <category>日常小记</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ学习笔记</title>
    <url>/2023/09/08/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="1-AMQP协议中的关键概念"><a href="#1-AMQP协议中的关键概念" class="headerlink" title="1 AMQP协议中的关键概念"></a>1 AMQP协议中的关键概念</h1><ul>
<li><code>Connection</code>socket连接，它封装了socket协议相关部分逻辑。你可以认为一个Connection就是一个Tcp连接。</li>
<li><code>Channel</code>生产者与Broker通信的通道，可以把通道理解成共享一个 TCP 连接的多个轻量化连接（通常每个thread创建单独的channel进行通讯）。</li>
</ul>
<blockquote>
<p><code>Connection</code>就是一个TCP连接对象，而<code>Channel</code>相当于连接池</p>
</blockquote>
<ul>
<li><code>Exchange</code>交换器，接收消息，按照路由规则将消息路由到一个或者多个队列</li>
<li><code>Queue</code>消息队列，用来保存消息，供消费者消费</li>
<li><code>Produce/Consumer</code>消息生产者和消费者</li>
<li><code>Binding</code>绑定，交换器和消息队列之间的虚拟连接，绑定中可以包含一个或者多个 RoutingKey。</li>
<li><code>RoutingKey</code>路由键，生产者将消息发送给交换器的时候，会指定一个 RoutingKey，用来指定路由规则，交换器根据路由键把消息发送到指定队列</li>
</ul>
<span id="more"></span>

<h1 id="2-消息队列模式"><a href="#2-消息队列模式" class="headerlink" title="2 消息队列模式"></a>2 消息队列模式</h1><h2 id="2-1-点对点模式"><a href="#2-1-点对点模式" class="headerlink" title="2.1 点对点模式"></a>2.1 点对点模式</h2><p><img src="/../images/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/e6053e18-99d6-4914-b06a-4dc65d258a30_1koS-yViN2.png"></p>
<p>点对点模式特点：<strong>一个具体的消息只能由一个消费者消费</strong>，多个生产者可以向同一个消息队列发送消息，但是一个消息在被一个消息者处理的时候，这个消息在队列上会被锁住或者被移除并且其他消费者无法处理该消息。</p>
<h2 id="2-2-发布-订阅模式"><a href="#2-2-发布-订阅模式" class="headerlink" title="2.2 发布/订阅模式"></a>2.2 发布/订阅模式</h2><p><strong>单个消息可以被多个订阅者并发的获取和处理</strong>。一般来说，订阅有两种类型：</p>
<ul>
<li>临时订阅：这种订阅只有在消费者启动并且运行的时候才存在。一旦消费者退出，相应的订阅以及尚未处理的消息就会丢失。</li>
<li>持久订阅：这种订阅会一直存在，除非主动去删除。消费者退出后，消息系统会继续维护该订阅，并且后续消息可以被继续处理。</li>
</ul>
<p><img src="/../images/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image_TSARw_VzVJ.png"></p>
<h1 id="3-RabbitMQ原理"><a href="#3-RabbitMQ原理" class="headerlink" title="3 RabbitMQ原理"></a>3 RabbitMQ原理</h1><p>RabbbitMQ使用Erlang语言开发，基于AMQP协议实现。AMQP协议由三部分组成，分别是消费者，生产者和服务端。执行流程如下：</p>
<ol>
<li><p>生产者连接到Server，建立一个连接，开启一个通道。</p>
</li>
<li><p>生产者声明交换器和队列，设置相关属性，并通过路由键将交换器和队列进行绑定。</p>
</li>
<li><p>消费者也需要进行建立连接，开启信道等操作，便于接收消息。</p>
</li>
<li><p>生产者发送消息，发送到服务端中的虚拟主机。</p>
</li>
<li><p>虚拟主机中的交换器根据路由键选择路由规则，发送到不同的消息队列中。</p>
</li>
<li><p>订阅了消息队列的消费者就可以获取到消息，进行消费。</p>
</li>
</ol>
<p><img src="/../images/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/82ff9d01-1ac7-4463-9733-a7372c642d35_wBUrxx8cW8.png"></p>
<blockquote>
<p>📌RabbitMQ 消息传递模型的核心思想是生产者从不直接向队列发送任何消息。实际上，生产者通常根本不知道消息是否会被传递到任何队列。</p>
<p>相反，生产者只能将消息发送到交换器。交换是一件非常简单的事情。一方面，它接收来自生产者的消息，另一方面，它将消息推送到队列。</p>
<p>交换机绑定多个队列，一个队列绑定一个键</p>
</blockquote>
<h2 id="3-1-交换机"><a href="#3-1-交换机" class="headerlink" title="3.1 交换机"></a>3.1 交换机</h2><p>Rabbitmq队列和交换机是绑定的，每个队列都有一个***<code>routingKey</code><em><strong>，发布者每次发布的消息也有一个</strong></em><code>routingKey</code>***，交换机会根据不同的匹配规则将消息匹配到与自己绑定的队列中</p>
<p>RabbitMQ常用交换机有四种：</p>
<h3 id="3-1-1-Direct"><a href="#3-1-1-Direct" class="headerlink" title="3.1.1 Direct"></a>3.1.1 Direct</h3><p>Direct exchange背后的路由算法很简单 - 消息进入其绑定键与消息的路由键完全匹配的队列。</p>
<p><img src="/../images/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image_gOLw0gI3JR.png"></p>
<blockquote>
<p>多重绑定</p>
<p>使用相同的绑定键绑定多个队列是完全合法的。在我们的示例中，我们可以使用绑定键black在X和Q1之间添加绑定。在这种情况下，直接交换的行为将类似于扇出，并将消息广播到所有匹配的队列。</p>
<p><img src="/../images/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image_ILV-y7PI8A.png"></p>
</blockquote>
<h3 id="3-1-2-Topic-exchange"><a href="#3-1-2-Topic-exchange" class="headerlink" title="3.1.2 Topic exchange"></a>3.1.2 Topic exchange</h3><p>**<code>topic</code>**：将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“*”只能匹配一个词</p>
<p>发送到Topic exchange的 <code>routing_key</code>它必须是一个由点分隔的单词列表。这些单词可以是任何内容，但通常它们指定与消息相关的一些功能。一些有效的路由键示例： <code>stock.usd.nyse</code> 、 <code>nyse.vmw</code> 、<code>quick.orange.rabbit</code> 。路由密钥中可以有任意多个单词，最多 255 个字节。</p>
<p><img src="/../images/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image_WeBDd2GgZO.png"></p>
<ul>
<li><code>*</code>可以恰好替代一个单词。</li>
<li><code>#</code>可以替代零个或多个单词。</li>
</ul>
<p>当队列与<code>#</code>绑定键绑定时 - 它将接收所有消息，无论路由键如何 - 就像在扇区交换器中一样。</p>
<h3 id="3-1-3-Fanout"><a href="#3-1-3-Fanout" class="headerlink" title="3.1.3 Fanout"></a>3.1.3 Fanout</h3><p>Fanout 不处理路由键，而是广播。你只需要简单的将队列绑定到交换机上。一个发送到该类型交换机的消息都会被广播到与该交换机绑定的所有队列上</p>
<h3 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a><strong>Headers</strong></h3><p>不处理路由键，而是根据发送的消息内容中的headers属性进行匹配。</p>
<h2 id="3-2-队列"><a href="#3-2-队列" class="headerlink" title="3.2 队列"></a>3.2 队列</h2><h3 id="3-2-1-死信队列"><a href="#3-2-1-死信队列" class="headerlink" title="3.2.1 死信队列"></a>3.2.1 死信队列</h3><p>来自队列的消息可能是“<strong>死信的</strong>”；也就是说，当发生以下任何事件时，重新发布到交换机：</p>
<ul>
<li>消费者使用<code>basic.reject</code>或 <code>basic.nack</code>否定确认消息，并将requeue参数设置为false。</li>
<li>由于每条消息 TTL（最大存活时间） 的原因，该消息过期；</li>
<li>由于队列超出长度限制，消息被丢弃</li>
</ul>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>一般用在较为重要的业务队列中，为了确保未被正确消费的消息不被丢弃，当发生异常时，通过死信队列，可以让未正确处理的消息暂存到另一个队列中。待后续排查清楚问题后，编写相应的处理代码来处理死信消息，这样比手工恢复数据要好太多了 。</p>
<h3 id="3-2-2-延时队列"><a href="#3-2-2-延时队列" class="headerlink" title="3.2.2 延时队列"></a>3.2.2 延时队列</h3><p>​ 延迟队列存储的对象肯定是对应的延时消息，所谓”延时消息”是指当消息被发送以后，并不想让消费者立即拿到消息，而是等待指定时间后，消费者才拿到这个消息进行消费。</p>
<p><a href="https://www.wolai.com/57hkFrHvCbQvHVKQW5Z4jk" title="官方文档">官方文档</a></p>
<h2 id="3-3-ACK机制"><a href="#3-3-ACK机制" class="headerlink" title="3.3 ACK机制"></a>3.3 ACK机制</h2><p>ACK机制是消费者从RabbitMQ收到消息并处理完成后，反馈给RabbitMQ，RabbitMQ收到反馈后才将次消息从队列中删除。如果消费者处理消息时出现异常，RabbitMQ会认为消息未被正常消费，将消息重新放入队列中。可以在消费消息中try-catch或在Consumer的配置文件中配置重试机制来解决这个问题。</p>
<h2 id="3-4-重试机制"><a href="#3-4-重试机制" class="headerlink" title="3.4 重试机制"></a>3.4 重试机制</h2><p>在消息<strong>消费失败</strong>的时候，Spring-AMQP 会通过<strong>消费重试</strong>机制，重新投递该消息给 Consumer ，让 Consumer 有机会重新消费消息，实现消费成功。</p>
<p>当然，Spring-AMQP 并不会无限重新投递消息给 Consumer 重新消费，而是在默认情况下，达到 N 次重试次数时，Consumer 还是消费失败时，该消息就会进入到<strong>死信队列</strong>。后续，我们可以通过对死信队列中的消息进行重发，来使得消费者实例再次进行消费。</p>
<p>为了效率和节省资源，我们一般会选择<code>CONNECTION</code>模式</p>
<h1 id="4-衡量标准"><a href="#4-衡量标准" class="headerlink" title="4 衡量标准"></a>4 衡量标准</h1><p>市面上的</p>
<ul>
<li><strong>消息顺序</strong>：发送到队列的消息，消费时是否可以保证消费的顺序，比如 A 先下单，B 后下单，应该是 A 先去扣库存，B 再去扣，顺序不能反。</li>
<li><strong>消息路由</strong>：根据路由规则，只订阅匹配路由规则的消息，比如有 A/B 两者规则的消息，消费者可以只订阅 A 消息，B 消息不会消费。</li>
<li>消息可靠性：是否会存在丢消息的情况，比如有 A/B 两个消息，最后只有 B 消息能消费，A 消息丢失。</li>
<li><strong>消息时序</strong>：主要包括 “消息存活时间” 和“延迟 / 预定的消息”，“消息存活时间”表示生产者可以对消息设置 TTL，如果超过该 TTL，消息会自动消失；“延迟 / 预定的消息”指的是可以延迟或者预订消费消息，比如延时 5 分钟，那么消息会 5 分钟后才能让消费者消费，时间未到的话，是不能消费的。</li>
<li><strong>消息留存</strong>：消息消费成功后，是否还会继续保留在消息队列。</li>
<li><strong>容错性</strong>：当一条消息消费失败后，是否有一些机制，保证这条消息是一种能成功，比如异步第三方退款消息，需要保证这条消息消费掉，才能确定给用户退款成功，所以必须保证这条消息消费成功的准确性。</li>
<li><strong>伸缩</strong>：当消息队列性能有问题，比如消费太慢，是否可以快速支持库容；当消费队列过多，浪费系统资源，是否可以支持缩容。</li>
<li><strong>吞吐量</strong>：支持的最高并发数。</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>中间件</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Environment体系</title>
    <url>/2024/06/21/Spring%20Environment%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><ul>
<li><code>PropertySource</code>：管理各种配置源的抽象类，即属性源</li>
<li><code>PropertySources</code>：用于统一管理和访问多个 PropertySource 实例</li>
<li><code>PropertyResolver</code>：通用属性解析<ul>
<li><code>Environment</code>：应用环境表示，提供属性访问，支持profile。</li>
<li><code>ConfigurablePropertyResolver</code>：属性解析配置，支持占位符解析。</li>
</ul>
</li>
<li><code>Binder</code>：配置绑定工具</li>
</ul>
<p>大致关系图：</p>
<p><img src="/../images/Spring-Environment%E4%BD%93%E7%B3%BB/image_98WWM6BQwA.png"></p>
<span id="more"></span>

<blockquote>
<p>图片来自<a href="https://www.apolloconfig.com/#/zh/design/apollo-design?id=_31-%E5%92%8Cspring%E9%9B%86%E6%88%90%E7%9A%84%E5%8E%9F%E7%90%86" title="https://www.apolloconfig.com/#/zh/design/apollo-design?id=_31-和spring集成的原理">https://www.apolloconfig.com/#/zh/design/apollo-design?id=_31-和spring集成的原理</a></p>
</blockquote>
<h2 id="PropertySource"><a href="#PropertySource" class="headerlink" title="PropertySource"></a>PropertySource</h2><p><img src="/../images/Spring-Environment%E4%BD%93%E7%B3%BB/image_eZgD5dC_Ym.png"></p>
<p>PropertySource是 Spring 框架中的一个关键抽象类，封装了一个属性源，属性源可以是一个<code>Map</code>、<code>Resource</code>对象、系统变量等等</p>
<h2 id="PropertySources"><a href="#PropertySources" class="headerlink" title="PropertySources"></a>PropertySources</h2><p><code>PropertySources</code> 是一个Spring框架中的接口，用于表示和管理一组属性源（<code>PropertySource</code>），这些属性源包含了应用程序环境中的配置数据。该接口提供了一系列方法来检索、添加、替换和删除这些属性源，允许开发者以统一的方式访问不同来源的配置信息，如环境变量、系统属性、配置文件等。</p>
<h2 id="PropertyResolver"><a href="#PropertyResolver" class="headerlink" title="PropertyResolver"></a>PropertyResolver</h2><p><code>PropertyResolver</code>是一个顶层接口，提供了一套灵活且强大的机制来处理应用程序配置属性。它定义了一些获取属性值，以及解析占位符的方法，用于访问和操纵来自各种源的属性值。</p>
<p><img src="/../images/Spring-Environment%E4%BD%93%E7%B3%BB/image_TL0vgbMjbo.png"></p>
<h3 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h3><p><code>Environment</code> 接口是 Spring 框架中的一个核心部分，它提供了一个统一的方式来访问各种外部化的配置数据（继承自<code>PropertyResolver</code>）；支持配置文件（Profiles）的概念，可以在不同环境下进行条件性的配置，管理多个属性源。</p>
<p>可以看到<code>Environment</code>是继承了<code>PropertyResolver</code>接口的，<strong>只是增加了一些环境信息方法(profile)</strong></p>
<p>其中<code>Environment</code>实例关于<code>PropertyResolver</code>接口的方法是通过组合模式实现的，内部持有一个<code>PropertySourcesPropertyResolver</code>实例。</p>
<h3 id="ConfigurablePropertyResolver"><a href="#ConfigurablePropertyResolver" class="headerlink" title="ConfigurablePropertyResolver"></a>ConfigurablePropertyResolver</h3><p><code>ConfigurablePropertyResolver</code> 接口则增加了一些配置方法，在Spring中关键作用是提供灵活的配置属性解析。它支持<strong>占位符解析</strong>，并解析这些占位符为实际的配置值，提升配置的动态性和灵活性。</p>
<h3 id="其他实现"><a href="#其他实现" class="headerlink" title="其他实现"></a>其他实现</h3><ul>
<li><code>ConfigurableEnvironment</code>，增加了一些配置的方法，以及可以获取到内部的<code>PropertySource</code>列表。</li>
<li><code>StandardEnvironment</code>，非web上下文使用的环境实例。</li>
<li><code>StandardServletEnvironment</code>，web上下文使用的环境实例。</li>
</ul>
<h2 id="属性绑定"><a href="#属性绑定" class="headerlink" title="属性绑定"></a>属性绑定</h2><h3 id="ConfigurationPropertySource"><a href="#ConfigurationPropertySource" class="headerlink" title="ConfigurationPropertySource"></a>ConfigurationPropertySource</h3><p>这是一个新的接口，不过它的实现类也是借助了<code>PropertySource</code>来实现，尽管他们之间没有任何继承关系。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConfigurationPropertySource</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据属性名获取对应的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ConfigurationProperty <span class="title function_">getConfigurationProperty</span><span class="params">(ConfigurationPropertyName name)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否包含后代属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> ConfigurationPropertyState <span class="title function_">containsDescendantOf</span><span class="params">(ConfigurationPropertyName name)</span> {</span><br><span class="line">        <span class="keyword">return</span> ConfigurationPropertyState.UNKNOWN;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册别名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> ConfigurationPropertySource <span class="title function_">withAliases</span><span class="params">(ConfigurationPropertyNameAliases aliases)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AliasedConfigurationPropertySource</span>(<span class="built_in">this</span>, aliases);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>ConfigurationPropertySources</code>提供了从environment中获取属性源构建ConfigurationPropertySource的方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Iterable&lt;ConfigurationPropertySource&gt; sources = ConfigurationPropertySources.get(environment);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h3><p>Spring提供了一个很强大的工具类<code>Binder</code>，依赖<code>ConfigurationPropertySource</code></p>
<p>作用：<em><strong>可以将<code>Environment</code>或者<code>ConfigurationPropertySource</code>中的属性绑定到一个Java对象中</strong></em>，且支持占位符，类型转换，宽松绑定。</p>
<p>他有两个重要方法：<code>bind()</code>和<code>bindOrCreate()</code>，两个方法有多重重载方式，这里列举了两种</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Binder</span> {</span><br><span class="line">  <span class="comment">// Binder 维护的属性源，在构造Binder时指定</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Iterable&lt;ConfigurationPropertySource&gt; sources;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将PropertySources绑定到指定的Bindable</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; BindResult&lt;T&gt; <span class="title function_">bind</span><span class="params">(ConfigurationPropertyName name, Bindable&lt;T&gt; target, BindHandler handler)</span> {</span><br><span class="line">    <span class="type">T</span> <span class="variable">bound</span> <span class="operator">=</span> bind(name, target, handler, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> BindResult.of(bound);</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将PropertySources绑定到指定的Bindable，或者如果绑定的结果是null，则使用Bindable的类型创建新实例</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">bindOrCreate</span><span class="params">(ConfigurationPropertyName name, Bindable&lt;T&gt; target, BindHandler handler)</span> {</span><br><span class="line">    <span class="keyword">return</span> bind(name, target, handler, <span class="literal">true</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><code>Binder</code>类还提供一个静态方法<code>get()</code>来构造<code>Binder</code>实例，可以从<code>Environment</code>实例获取<code>PropertySources</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Binder <span class="title function_">get</span><span class="params">(Environment environment)</span> {  </span><br><span class="line">    <span class="keyword">return</span> get(environment, <span class="literal">null</span>);  </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Binder <span class="title function_">get</span><span class="params">(Environment environment, BindHandler defaultBindHandler)</span> {</span><br><span class="line">    Iterable&lt;ConfigurationPropertySource&gt; sources = ConfigurationPropertySources.get(environment);</span><br><span class="line">    <span class="type">PropertySourcesPlaceholdersResolver</span> <span class="variable">placeholdersResolver</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">PropertySourcesPlaceholdersResolver</span>(environment);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Binder</span>(sources, placeholdersResolver, <span class="literal">null</span>, <span class="literal">null</span>, defaultBindHandler);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>我们项目中常用于配置注入的<code>@ConfigurationProperties</code>，实现原理也是通过Binder</p>
<h3 id="ConfigurationProperties实现原理"><a href="#ConfigurationProperties实现原理" class="headerlink" title="@ConfigurationProperties实现原理"></a>@ConfigurationProperties实现原理</h3><p><code>@ConfigurationProperties</code>注解在Spring Boot中常用来绑定属性到Java Bean中，不难猜出内部原理便是使用上面所介绍的<code>Binder</code>类来实现的。</p>
<p>使用该注解时常常搭配<code>@EnableConfigurationProperties</code>注解一起使用，<code>@EnableConfigurationProperties</code>的主要作用就是注册了一个<code>ConfigurationPropertiesBindingPostProcessor</code>Bean</p>
<p>绑定的核心逻辑在<code>ConfigurationPropertiesBindingPostProcessor</code>中</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException {</span><br><span class="line">  <span class="keyword">if</span> (!hasBoundValueObject(beanName)) {</span><br><span class="line">    bind(ConfigurationPropertiesBean.get(<span class="built_in">this</span>.applicationContext, bean, beanName));</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> bean;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(ConfigurationPropertiesBean bean)</span> {</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    <span class="built_in">this</span>.binder.bind(bean);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConfigurationPropertiesBindException</span>(bean, ex);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">BindResult&lt;?&gt; bind(ConfigurationPropertiesBean propertiesBean) {</span><br><span class="line">  Bindable&lt;?&gt; target = propertiesBean.asBindTarget();</span><br><span class="line">  <span class="type">ConfigurationProperties</span> <span class="variable">annotation</span> <span class="operator">=</span> propertiesBean.getAnnotation();</span><br><span class="line">  <span class="type">BindHandler</span> <span class="variable">bindHandler</span> <span class="operator">=</span> getBindHandler(target, annotation);</span><br><span class="line">  <span class="comment">// 绑定ConfigurationPropertySource中的属性源和ConfigurationPropertiesBean对象</span></span><br><span class="line">  <span class="keyword">return</span> getBinder().bind(annotation.prefix(), target, bindHandler);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Binder <span class="title function_">getBinder</span><span class="params">()</span> {</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.binder == <span class="literal">null</span>) {</span><br><span class="line">    <span class="built_in">this</span>.binder = <span class="keyword">new</span> <span class="title class_">Binder</span>(getConfigurationPropertySources(), getPropertySourcesPlaceholdersResolver(),</span><br><span class="line">        getConversionServices(), getPropertyEditorInitializer(), <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.binder;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从注入的属性源构建ConfigurationPropertySource</span></span><br><span class="line"><span class="keyword">private</span> Iterable&lt;ConfigurationPropertySource&gt; <span class="title function_">getConfigurationPropertySources</span><span class="params">()</span> {</span><br><span class="line">  <span class="keyword">return</span> ConfigurationPropertySources.from(<span class="built_in">this</span>.propertySources);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 从注入的属性源构建PropertySourcesResolver, 支持解析占位符</span></span><br><span class="line"><span class="keyword">private</span> PropertySourcesPlaceholdersResolver <span class="title function_">getPropertySourcesPlaceholdersResolver</span><span class="params">()</span> {</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PropertySourcesPlaceholdersResolver</span>(<span class="built_in">this</span>.propertySources);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 类型转换</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ConversionService&gt; <span class="title function_">getConversionServices</span><span class="params">()</span> {</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConversionServiceDeducer</span>(<span class="built_in">this</span>.applicationContext).getConversionServices();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Consumer&lt;PropertyEditorRegistry&gt; <span class="title function_">getPropertyEditorInitializer</span><span class="params">()</span> {</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.applicationContext <span class="keyword">instanceof</span> ConfigurableApplicationContext configurableContext) {</span><br><span class="line">    <span class="keyword">return</span> configurableContext.getBeanFactory()::copyRegisteredEditorsTo;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>关键点在于使用Binder将<code>ConfigurationPropertySource</code>中的属性源和实际的<code>ConfigurationPropertiesBean</code>对象绑定在了一起，实现配置的注入。注意<code>ConfigurationPropertySource</code>中的属性源是带有<code>prefix</code>的</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrefixedConfigurationPropertySource</span> <span class="keyword">implements</span> <span class="title class_">ConfigurationPropertySource</span> {</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ConfigurationPropertySource source;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ConfigurationPropertyName prefix;</span><br><span class="line"></span><br><span class="line">  PrefixedConfigurationPropertySource(ConfigurationPropertySource source, String prefix) {</span><br><span class="line">    Assert.notNull(source, <span class="string">"Source must not be null"</span>);</span><br><span class="line">    Assert.hasText(prefix, <span class="string">"Prefix must not be empty"</span>);</span><br><span class="line">    <span class="built_in">this</span>.source = source;</span><br><span class="line">    <span class="built_in">this</span>.prefix = ConfigurationPropertyName.of(prefix);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<p>参考：</p>
<ul>
<li><a href="https://www.cnblogs.com/wt20/p/17588895.html" title="https://www.cnblogs.com/wt20/p/17588895.html">https://www.cnblogs.com/wt20/p/17588895.html</a></li>
<li><a href="https://spring.hhui.top/spring-blog/2023/06/18/230618-SpringBoot%E4%B9%8B%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%B1%9E%E6%80%A7%E7%BB%91%E5%AE%9ABinder/" title="https://spring.hhui.top/spring-blog/2023/06/18/230618-SpringBoot之编程式属性绑定Binder/">https://spring.hhui.top/spring-blog/2023/06/18/230618-SpringBoot之编程式属性绑定Binder/</a></li>
</ul>
]]></content>
      <categories>
        <category>Spring源码系列</category>
      </categories>
      <tags>
        <tag>Spring源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Lazy-init 踩坑记录</title>
    <url>/2023/11/01/Spring%20Lazy-init%20%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<blockquote>
<p>起因：在写一个Springboot项目时，队友将项目加载方式改为<code>lazy-init</code>，理由是能加快重启的速度，但是导致了Bug</p>
</blockquote>
<span id="more"></span>

<p><img src="/../images/289b54f1b37819da340708c7cfb9e261_rfYNVwE36_.png"></p>
<p><img src="/../images/1551908c7fb3dddbbc2d3b1e90a48cf1_gLwVbcWEG6.png"></p>
<p>Spring在Bean初始化阶段会对所有继承了<code>ApplicationContextAware</code>接口的类注入<code>ApplicationContext</code></p>
<p>但是如果设置了<code>lazy-init</code>，bean加载顺序变了，<code>setApplicationContext</code>就不执行了</p>
]]></content>
      <categories>
        <category>日常小记</category>
      </categories>
      <tags>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring IoC之体系结构</title>
    <url>/2024/05/10/Spring-IoC%E4%B9%8B%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>Spring Bean 的创建是典型的工厂模式，在顶层的结构设计主要围绕着 BeanFactory 和 xxxRegistry 进行：</p>
<ul>
<li><strong>BeanFactory： 工厂模式定义了 IOC 容器的基本功能</strong></li>
<li><strong>BeanRegistry： 提供手动注册 BeanDefinition到容器中的方法</strong></li>
</ul>
<p><img src="/../images/Spring-IoC%E4%B9%8B%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image_etoRGn8l6k.png"></p>
<span id="more"></span>

<h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p><strong>BeanFactory作为最顶层的一个接口类，它定义了IOC容器的基本功能</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanFactory</span> {    </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//用于取消引用实例并将其与FactoryBean创建的bean区分开来。例如，如果命名的bean是FactoryBean，则获取将返回Factory，而不是Factory返回的实例。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">FACTORY_BEAN_PREFIX</span> <span class="operator">=</span> <span class="string">"&amp;"</span>; </span><br><span class="line">        </span><br><span class="line">    <span class="comment">//根据bean的名字和Class类型等来得到bean实例    </span></span><br><span class="line">    Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException;    </span><br><span class="line">    Object <span class="title function_">getBean</span><span class="params">(String name, Class requiredType)</span> <span class="keyword">throws</span> BeansException;    </span><br><span class="line">    Object <span class="title function_">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">    &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">    &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回指定bean的Provider</span></span><br><span class="line">    &lt;T&gt; ObjectProvider&lt;T&gt; <span class="title function_">getBeanProvider</span><span class="params">(Class&lt;T&gt; requiredType)</span>;</span><br><span class="line">    &lt;T&gt; ObjectProvider&lt;T&gt; <span class="title function_">getBeanProvider</span><span class="params">(ResolvableType requiredType)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查工厂中是否包含给定name的bean，或者外部注册的bean</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">containsBean</span><span class="params">(String name)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查所给定name的bean是否为单例/原型</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断所给name的类型与type是否匹配</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isTypeMatch</span><span class="params">(String name, Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取给定name的bean的类型</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回给定name的bean的别名</span></span><br><span class="line">    String[] getAliases(String name);</span><br><span class="line">     </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>BeanFactory 有三个子类：<code>ListableBeanFactory</code>、<code>HierarchicalBeanFactory</code> 和<code>AutowireCapableBeanFactory</code>。</p>
<ul>
<li>**<code>ListableBeanFactory</code>**：该接口定义了访问容器中 Bean 基本信息的若干方法，如查看 Bean 的个数、获取某一类型 Bean 的配置名、查看容器中是否包括某一 Bean 等方法；</li>
<li>**<code>HierarchicalBeanFactory</code>**：父子级联 IoC 容器的接口，子容器可以通过接口方法访问父容器； 通过 HierarchicalBeanFactory 接口， Spring 的 IoC 容器可以建立父子层级关联的容器体系，子容器可以访问父容器中的 Bean，但父容器不能访问子容器的 Bean。Spring 使用父子容器实现了很多功能，比如在 Spring MVC 中，展现层 Bean 位于一个子容器中，而业务层和持久层的 Bean 位于父容器中。这样，展现层 Bean 就可以引用业务层和持久层的 Bean，而业务层和持久层的 Bean 则看不到展现层的 Bean。</li>
<li>**<code>ConfigurableBeanFactory</code>**：是一个重要的接口，增强了 IoC 容器的可定制性，它定义了设置类装载器、属性编辑器、容器初始化后置处理器等方法；</li>
<li><strong><code>ConfigurableListableBeanFactory</code></strong>: ListableBeanFactory 和 ConfigurableBeanFactory 的融合；</li>
<li>**<code>AutowireCapableBeanFactory</code>**：定义了将容器中的 Bean 按某种规则（如按名字匹配、按类型匹配等）进行自动装配的方法</li>
</ul>
<h2 id="BeanRegistry"><a href="#BeanRegistry" class="headerlink" title="BeanRegistry"></a>BeanRegistry</h2><p> BeanDefinitionRegistry 接口提供了向容器手工注册 BeanDefinition 对象的方法</p>
<h2 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h2><p>Bean 对象存在依赖嵌套等关系，所以设计者设计了 BeanDefinition，它用来对 Bean 对象及关系定义；我们在理解时只需要抓住如下三个要点：</p>
<ul>
<li><code>BeanDefinition</code> 定义了各种 Bean 对象及其相互的关系</li>
<li><code>BeanDefinitionReader</code> 这是 BeanDefinition 的解析器</li>
<li><code>BeanDefinitionHolder</code> 这是 BeanDefination 的包装类，用来存储 BeanDefinition，name 以及 aliases 等。</li>
</ul>
<p><img src="/../images/Spring-IoC%E4%B9%8B%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image_bZorDDTlue.png"></p>
<h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><p>ApplicationContext是IoC容器的接口，除了继承了BeanFactory的能力，还拓展了配置资源的加载、应用事件、国际化等功能</p>
<p><img src="/../images/Spring-IoC%E4%B9%8B%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image_LT5sne3EVd.png"></p>
<ul>
<li><strong>ApplicationEventPublisher</strong>：让容器拥有发布应用上下文事件的功能，包括容器启动事件、关闭事件等。</li>
<li><strong>MessageSource</strong>：为应用提供 i18n 国际化消息访问的功能；</li>
<li><strong>ResourcePatternResolver</strong> ：资源模式解析接口，可以通过带前缀的 Ant 风格的资源文件路径装载 Spring 的配置文件。</li>
<li><strong>LifeCycle</strong>：提供了 <code>start()</code> 和 <code>stop()</code> 两个方法，主要用于控制异步处理过程。在具体使用时，该接口同时被 ApplicationContext 实现及具体 Bean 实现， ApplicationContext 会将 start/stop 的信息传递给容器中所有实现了该接口的 Bean，以达到管理和控制 JMX、任务调度等目的。</li>
</ul>
<h3 id="ApplicationContext体系"><a href="#ApplicationContext体系" class="headerlink" title="ApplicationContext体系"></a>ApplicationContext体系</h3><p><img src="/../images/Spring-IoC%E4%B9%8B%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image_-3W-afYUAj.png"></p>
<blockquote>
<p>为什么设计这么多ApplicationContext？</p>
<p><strong>第一，从类结构设计上看， 围绕着是否需要 Refresh 容器衍生出两个抽象类</strong>：</p>
<ul>
<li><code>GenericApplicationContext</code>： 是初始化的时候就创建容器，往后的每次 refresh 都不会更改</li>
<li><code>AbstractRefreshableApplicationContext</code>： <code>AbstractRefreshableApplicationContext</code> 及子类的每次 refresh 都是先清除已有 (如果不存在就创建) 的容器，然后再重新创建，因此无法做到像 <code>GenericApplicationContext</code> <strong>混合搭配从不同源头获取 bean 的定义信息</strong></li>
</ul>
<p><strong>第二， 从加载的源来看（比如 xml,groovy,annotation 等）， 衍生出众多类型的 ApplicationContext, 典型比如</strong>:</p>
<ul>
<li><code>FileSystemXmlApplicationContext</code>： 从文件系统下的一个或多个 xml 配置文件中加载上下文定义，也就是说系统盘符中加载 xml 配置文件。</li>
<li><code>ClassPathXmlApplicationContext</code>： 从类路径下的一个或多个 xml 配置文件中加载上下文定义，适用于 xml 配置的方式。</li>
<li><code>AnnotationConfigApplicationContext</code>： 从一个或多个基于 java 的配置类中加载上下文定义，适用于 java 注解的方式。</li>
<li><code>ConfigurableApplicationContext</code>： 扩展于 ApplicationContext，它新增加了两个主要的方法： <code>refresh()</code> 和 <code>close()</code>，让 ApplicationContext 具有启动、刷新和关闭应用上下文的能力。在应用上下文关闭的情况下调用 <code>refresh()</code> 即可启动应用上下文，在已经启动的状态下，调用 <code>refresh()</code> 则清除缓存并重新装载配置信息，而调用 <code>close()</code> 则可关闭应用上下文。</li>
</ul>
<p><strong>第三， 更进一步理解</strong>：</p>
<p>***设计者在设计时 <code>AnnotationConfigApplicationContext</code> 为什么是继承 <code>GenericApplicationContext</code>***？ 因为基于注解的配置，是不太会被运行时修改的，这意味着不需要进行动态 Bean 配置和刷新容器，所以只需要 <code>GenericApplicationContext</code>。</p>
<p>而基于 XML 这种配置文件，这种文件是容易修改的，需要动态性刷新 Bean 的支持，所以 XML 相关的配置必然继承 <code>AbstractRefreshableApplicationContext</code>； 且存在多种 xml 的加载方式（位置不同的设计），所以必然会设计出 <code>AbstractXmlApplicationContext</code>, 其中包含对 XML 配置解析成 BeanDefination 的过程。</p>
<p>那么细心的你从上图可以***发现 <code>AnnotationWebConfigApplicationContext</code> 却是继承了 <code>AbstractRefreshableApplicationContext</code> 而不是 <code>GenericApplicationContext</code>***？ 因为用户可以通过 ApplicationContextInitializer 来设置 contextInitializerClasses（context-param / init-param）， 在这种情况下用户倾向于刷新 Bean 的，所以设计者选择让 <code>AnnotationWebConfigApplicationContext</code> 继承了 <code>AbstractRefreshableApplicationContext</code>。</p>
</blockquote>
<p>这一段解释封神，我直接复制粘贴😆</p>
<p>参考：</p>
<ul>
<li><a href="https://pdai.tech/md/spring/spring-x-framework-ioc-source-1.html" title="https://pdai.tech/md/spring/spring-x-framework-ioc-source-1.html">https://pdai.tech/md/spring/spring-x-framework-ioc-source-1.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Spring源码系列</category>
      </categories>
      <tags>
        <tag>IoC</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis实现动态注册bean的两种方式</title>
    <url>/2024/03/26/Mybatis%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8Cbean%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>我们都知道MyBatis可以通过<code>@MapperScanner</code>和<code>@Mapper</code>两种方法将Mapper注入到Spring容器中，本文介绍MyBatis如何实现动态注册Bean的两种方式的实现原理，以便在其他类似的场景作为参考。</p>
<h2 id="MyBatis代理DAO接口类过程"><a href="#MyBatis代理DAO接口类过程" class="headerlink" title="MyBatis代理DAO接口类过程"></a>MyBatis代理DAO接口类过程</h2><p>先看一下MyBatis代理Bean的过程：</p>
<ul>
<li><code>MapperScannerConfigurer</code>核心配置类<ul>
<li><code>MapperScannerConfigurer#postProcessBeanDefinitionRegistry</code>负责在Bean注册后扫描调用<code>ClassPathMapperScanner</code>全部的Mapper</li>
</ul>
</li>
<li><code>ClassPathMapperScanner</code>类扫描器，继承自<code>ClassPathBeanDefinitionScanner</code>，负责在classPath中扫描所有的继承了Mapper的DAO接口，对扫描到的Mapper接口进行封装<ul>
<li>封装方式：使用<code>MapperFactoryBean</code>替换接口的<code>BeanDefinition</code>，会把<code>sqlSessionFactory</code>，<code>sqlSessionTemplate</code>等参数传递给<code>MapperFactoryBean</code>，从而创建<code>SqlSession</code>(<code>SqlSessionTemplate</code>)，通过<code>getObject()</code>返回代理类</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="动态注册Bean"><a href="#动态注册Bean" class="headerlink" title="动态注册Bean"></a>动态注册Bean</h2><p>那么<code>MapperScannerConfigurer</code>扫描的路径、参数、是否懒加载等配置是在什么时候注入的呢？不同的MyBatis使用姿势实现的方式不同：</p>
<ul>
<li><code>@MapperScan</code><ul>
<li>通过<code>ImportBeanDefinitionRegistrar</code>注入<code>MapperScannerRegistrar</code>，其中<code>ImportBeanDefinitionRegistrar</code>也是Spring官方动态注册bean的常用套路</li>
<li><code>MapperScannerRegistrar</code>中构造了<code>MapperScannerConfigurer</code>，配置了<code>MapperScannerConfigurer</code>的基本属性，如basePackage、annotationClass等等</li>
</ul>
</li>
<li><code>@Mapper</code><ul>
<li><code>@Mapper</code>的扫描逻辑在<code>AutoConfiguredMapperScannerRegistrar</code>（通过自动装配注入），在不使用<code>@MapperScanner</code>指定扫描路径的情况下只会扫描启动类所在的classPath</li>
<li>同上，<code>AutoConfiguredMapperScannerRegistrar</code>中构造了<code>MapperScannerConfigurer</code>并进行属性注入</li>
</ul>
</li>
</ul>
<hr>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/qq_31086797/article/details/124488829">https://blog.csdn.net/qq_31086797/article/details/124488829</a></li>
<li><a href="https://cofcool.github.io/tech/2018/06/20/mybatis-sourcecode-1#11-mapper%E6%89%AB%E6%8F%8F">https://cofcool.github.io/tech/2018/06/20/mybatis-sourcecode-1</a></li>
</ul>
]]></content>
      <categories>
        <category>日常小记</category>
      </categories>
  </entry>
  <entry>
    <title>🤨 Spring Security架构体系</title>
    <url>/2023/09/12/Spring-Security%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p><em>本文暂未完善</em></p>
<p>SpringSecurity的逻辑架构主要分为两部分：认证架构和授权架构</p>
<h1 id="Servlet-认证架构"><a href="#Servlet-认证架构" class="headerlink" title="Servlet 认证架构"></a>Servlet 认证架构</h1><p>总体架构：</p>
<p><img src="/../images/Spring-Security%E6%9E%B6%E6%9E%84/image_hWPD8lsRmI.png"></p>
<p>关键组件：</p>
<p><code>AuthenticationFilter</code>：用于获取请求中的信息，并创建 <code>Authentication</code>对象</p>
<p><code>AuthenticationProvider</code>：用于验证登录逻辑，对<code>Authentication</code>进行进一步的身份认证</p>
<span id="more"></span>

<p>用户携带认证token进行请求，请求中的用户身份信息会被AuthenTicationFilter提取出来并交给<code>AuthenticationManager</code>，<code>AuthenticationManager</code>负责对用户的身份信息进行认证</p>
<p><img src="/../images/Spring-Security%E6%9E%B6%E6%9E%84/image_67F-kIkJIp.png"></p>
<h2 id="逻辑关系"><a href="#逻辑关系" class="headerlink" title="逻辑关系"></a>逻辑关系</h2><p><img src="/../images/Spring-Security%E6%9E%B6%E6%9E%84/image_BnjQG1hUFj.png"></p>
<h2 id="ProviderManager"><a href="#ProviderManager" class="headerlink" title="ProviderManager"></a>ProviderManager</h2><p>ProviderManager中包含了一系列的Provider，这些Provider负责执行实际的身份验证。例如，<code>DaoAuthenticationProvider</code>支持基于用户名/密码的身份验证，同时<code>JwtAuthenticationProvider</code>支持对 JWT 令牌进行身份验证。每个<code>AuthenticationProvider</code>执行特定类型的身份验证。</p>
<p><img src="/../images/Spring-Security%E6%9E%B6%E6%9E%84/image_3sJrWUgN3w.png"></p>
<p><img src="/../images/Spring-Security%E6%9E%B6%E6%9E%84/image_nA3iwqM0Zb.png"></p>
<h2 id="DaoAuthenticationProvider"><a href="#DaoAuthenticationProvider" class="headerlink" title="DaoAuthenticationProvider"></a>DaoAuthenticationProvider</h2><p>输入Username和Password，返回UserDetails和Authorities</p>
<p>作用：是一个<code>AuthenticationProvider</code>，用于校验账号密码</p>
<p><img src="/../images/Spring-Security%E6%9E%B6%E6%9E%84/image_KiWYyJMnjI.png"></p>
<h1 id="SecurityContextHolder"><a href="#SecurityContextHolder" class="headerlink" title="SecurityContextHolder"></a>SecurityContextHolder</h1><p>Spring Security 身份验证模型的核心是<code>SecurityContextHolder</code>，它存在于TreadLocal中</p>
<p><img src="/../images/Spring-Security%E6%9E%B6%E6%9E%84/image_2QYvifZK3U.png"></p>
<h2 id="设置SecurityContextHolder"><a href="#设置SecurityContextHolder" class="headerlink" title="设置SecurityContextHolder"></a>设置SecurityContextHolder</h2><p>不能直接通过<code>SecurityContextHolder.getContext().setAuthentication(authentication)</code>来设置Holder中的context，否则多线程情况下会出现问题。应该为每个线程创建单独的实例：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">SecurityContext</span> <span class="variable">context</span> <span class="operator">=</span> SecurityContextHolder.createEmptyContext(); </span><br><span class="line"><span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">TestingAuthenticationToken</span>(<span class="string">"username"</span>, <span class="string">"password"</span>, <span class="string">"ROLE_USER"</span>); </span><br><span class="line">context.setAuthentication(authentication);</span><br><span class="line"></span><br><span class="line">SecurityContextHolder.setContext(context); </span><br></pre></td></tr></tbody></table></figure>

<h2 id="访问当前经过身份验证的用户"><a href="#访问当前经过身份验证的用户" class="headerlink" title="访问当前经过身份验证的用户"></a>访问当前经过身份验证的用户</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">SecurityContext</span> <span class="variable">context</span> <span class="operator">=</span> SecurityContextHolder.getContext();</span><br><span class="line"><span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> context.getAuthentication();</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> authentication.getName();</span><br><span class="line"><span class="type">Object</span> <span class="variable">principal</span> <span class="operator">=</span> authentication.getPrincipal();</span><br><span class="line">Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; authorities = authentication.getAuthorities();</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>默认情况下，SecurityContextHolder使用 <code>ThreadLocal</code>来存储这些详细信息。</li>
<li>ThreadLocal如果在处理当前主体的请求后注意清除线程，Spring Security 的<code>FilterChainProxy</code>确保SecurityContext始终清除。</li>
<li>三者包含关系：SecurityContextHolder→ SecurityContext → Authentication</li>
</ul>
<p><code>Authentication</code>中包含：</p>
<ul>
<li><code>principal</code>：标识用户。当使用用户名/密码进行身份验证时，这通常是<a href="https://docs.spring.io/spring-security/reference/servlet/authentication/passwords/user-details.html#servlet-authentication-userdetails" title="UserDetails">UserDetails</a>.</li>
<li><code>credentials</code>: 通常是密码。很多情况下，这个是在用户通过认证后清除的，以保证不被泄露。</li>
<li><code>Collection&lt;? extends GrantedAuthority&gt;</code>：<a href="https://docs.spring.io/spring-security/reference/servlet/authentication/architecture.html#servlet-authentication-granted-authority" title="GrantedAuthority">GrantedAuthority</a>实例是授予用户的高级权限。</li>
</ul>
<blockquote>
<p><code>UserDetails</code>、<code>UserDetailsService</code>关系：</p>
<p>UserDetails由UserDetailsService返回。<code>DaoAuthenticationProvider</code>验证UserDetails，然后返回一个Authentication，该Authentication的主体是配置的UserDetailsService返回的UserDetails。</p>
</blockquote>
<h1 id="Security授权流程"><a href="#Security授权流程" class="headerlink" title="Security授权流程"></a>Security授权流程</h1><p><img src="/../images/Spring-Security%E6%9E%B6%E6%9E%84/image_YR7XuKyby2.png"></p>
]]></content>
      <categories>
        <category>日常小记</category>
      </categories>
      <tags>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 事务体系</title>
    <url>/2024/05/08/Spring-%E4%BA%8B%E5%8A%A1%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<p>最近了解到，Spring中的事务是由AOP实现的（当然这里说的是声明式事务），至于里面具体的逻辑是怎么样的，今天花了一天的时间看代码，总算弄是明白了大概流程😎，至于里面很多技术细节还没去深挖，先这样吧╮(╯_╰)╭</p>
<h2 id="Spring-事务相关的API"><a href="#Spring-事务相关的API" class="headerlink" title="Spring 事务相关的API"></a>Spring 事务相关的API</h2><p>先看看概念：</p>
<p><strong>事务操作相关的API</strong></p>
<ul>
<li><code>@Transactional</code> - Spring事务注解</li>
<li><code>@EnableTranSactionManagement</code> - Spring事务模块驱动</li>
</ul>
<p><strong>事务抽象相关的API</strong></p>
<ul>
<li><strong><code>PlatformTransactionManager</code></strong> - Spring平台事务管理器，负责执行事务的关键类</li>
<li><code>TransactionStatus</code> - Spring事务状态</li>
<li><code>TransactionDefinition</code> - Spring事务定义</li>
<li><strong><code>ProxyTransactionManagementConfiguration</code></strong> - Spring事务代理配置类</li>
</ul>
<p><strong>AOP相关的API</strong></p>
<ul>
<li><strong><code>BeanFactoryTransactionAttrubuteSourceAdvisor</code></strong> - Spring事务PointcutAdvisor实现</li>
<li><strong><code>TransactionInterceptor</code></strong> - 事务执行切面，负责事务执行的核心类</li>
<li><strong><code>TransactionAttributeSource</code></strong> - Spring事务属性源</li>
<li><strong><code>TransactionAnnotationParser</code></strong> - 解析器，负责扫描并解析所有的带有@Transactional的方法或类，并将数据封装为<code>TransactionAttributeSource</code></li>
<li><code>TransactionSynchronizationAdapter</code> - 事务同步器，感知事务是成功还是失败，在事务提交前后通知，这个在做一些需要监听事务状态的业务需求估计会比较有用吧🤨</li>
</ul>
<span id="more"></span>

<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p><code>ProxyTransactionManagementConfiguration</code>是通过<code>@EnableTranSactionManagement</code>注入的核心配置类，内部实际注册了三个Bean，这三个Bean其实是AOP的三部分：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line"><span class="meta">@ImportRuntimeHints(TransactionRuntimeHints.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTransactionManagementConfiguration</span> <span class="keyword">extends</span> <span class="title class_">AbstractTransactionManagementConfiguration</span> {</span><br><span class="line"></span><br><span class="line">  <span class="comment">// AOP的PointcutAdvisor</span></span><br><span class="line">  <span class="comment">// PointcutAdvisor = PointCut + Advice</span></span><br><span class="line">  <span class="meta">@Bean(name = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME)</span></span><br><span class="line">  <span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line">  <span class="keyword">public</span> BeanFactoryTransactionAttributeSourceAdvisor <span class="title function_">transactionAdvisor</span><span class="params">(</span></span><br><span class="line"><span class="params">      TransactionAttributeSource transactionAttributeSource, TransactionInterceptor transactionInterceptor)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="type">BeanFactoryTransactionAttributeSourceAdvisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanFactoryTransactionAttributeSourceAdvisor</span>();</span><br><span class="line">    advisor.setTransactionAttributeSource(transactionAttributeSource);</span><br><span class="line">    advisor.setAdvice(transactionInterceptor);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.enableTx != <span class="literal">null</span>) {</span><br><span class="line">      advisor.setOrder(<span class="built_in">this</span>.enableTx.&lt;Integer&gt;getNumber(<span class="string">"order"</span>));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> advisor;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PointCut</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line">  <span class="keyword">public</span> TransactionAttributeSource <span class="title function_">transactionAttributeSource</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// Accept protected @Transactional methods on CGLIB proxies, as of 6.0.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnnotationTransactionAttributeSource</span>(<span class="literal">false</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Advice</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line">  <span class="keyword">public</span> TransactionInterceptor <span class="title function_">transactionInterceptor</span><span class="params">(TransactionAttributeSource transactionAttributeSource)</span> {</span><br><span class="line">    <span class="type">TransactionInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionInterceptor</span>();</span><br><span class="line">    interceptor.setTransactionAttributeSource(transactionAttributeSource);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.txManager != <span class="literal">null</span>) {</span><br><span class="line">      interceptor.setTransactionManager(<span class="built_in">this</span>.txManager);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> interceptor;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中<code>BeanFactoryTransactionAttributeSourceAdvisor</code>负责将<code>PointCut</code>和<code>Advice</code>注入到AOP中，没有什么复杂的逻辑</p>
<p>下面介绍一下<code>TransactionAttributeSource</code>和<code>TransactionInterceptor</code></p>
<h3 id="TransactionAttributeSource"><a href="#TransactionAttributeSource" class="headerlink" title="TransactionAttributeSource"></a>TransactionAttributeSource</h3><p>上面注入了一个<code>AnnotationTransactionAttributeSource</code>，我们来看看这个Bean做了什么</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 添加解析器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationTransactionAttributeSource</span><span class="params">(<span class="type">boolean</span> publicMethodsOnly)</span> {</span><br><span class="line">  <span class="built_in">this</span>.publicMethodsOnly = publicMethodsOnly;</span><br><span class="line">  <span class="keyword">if</span> (jta12Present || ejb3Present) {</span><br><span class="line">    <span class="built_in">this</span>.annotationParsers = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">this</span>.annotationParsers.add(<span class="keyword">new</span> <span class="title class_">SpringTransactionAnnotationParser</span>());</span><br><span class="line">    <span class="keyword">if</span> (jta12Present) {</span><br><span class="line">      <span class="built_in">this</span>.annotationParsers.add(<span class="keyword">new</span> <span class="title class_">JtaTransactionAnnotationParser</span>());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (ejb3Present) {</span><br><span class="line">      <span class="built_in">this</span>.annotationParsers.add(<span class="keyword">new</span> <span class="title class_">Ejb3TransactionAnnotationParser</span>());</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span> {</span><br><span class="line">    <span class="built_in">this</span>.annotationParsers = Collections.singleton(<span class="keyword">new</span> <span class="title class_">SpringTransactionAnnotationParser</span>());</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> TransactionAttribute <span class="title function_">findTransactionAttribute</span><span class="params">(Method method)</span> {</span><br><span class="line">  <span class="keyword">return</span> determineTransactionAttribute(method);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析方法上的Transactional注解</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> TransactionAttribute <span class="title function_">determineTransactionAttribute</span><span class="params">(AnnotatedElement element)</span> {</span><br><span class="line">  <span class="keyword">for</span> (TransactionAnnotationParser parser : <span class="built_in">this</span>.annotationParsers) {</span><br><span class="line">    <span class="type">TransactionAttribute</span> <span class="variable">attr</span> <span class="operator">=</span> parser.parseTransactionAnnotation(element);</span><br><span class="line">    <span class="keyword">if</span> (attr != <span class="literal">null</span>) {</span><br><span class="line">      <span class="keyword">return</span> attr;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>所以这个类的作用大概就是解析所有方法上的Transactional注解然后封装为<code>TransactionAttributeSource</code>，最后担任<code>PointCut</code>角色</p>
<h3 id="TransactionInterceptor"><a href="#TransactionInterceptor" class="headerlink" title="TransactionInterceptor"></a>TransactionInterceptor</h3><p>执行事务的核心方法，这个方法很长很复杂没有耐心看了🥲，看了网上的博客大概是这么说的：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">invokeWithinTransaction</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass,</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> InvocationCallback invocation)</span> <span class="keyword">throws</span> Throwable {</span><br><span class="line"></span><br><span class="line">  <span class="type">TransactionAttributeSource</span> <span class="variable">tas</span> <span class="operator">=</span> getTransactionAttributeSource();</span><br><span class="line">  <span class="keyword">final</span> <span class="type">TransactionAttribute</span> <span class="variable">txAttr</span> <span class="operator">=</span> (tas != <span class="literal">null</span> ? tas.getTransactionAttribute(method, targetClass) : <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">final</span> <span class="type">PlatformTransactionManager</span> <span class="variable">tm</span> <span class="operator">=</span> determineTransactionManager(txAttr);</span><br><span class="line">  <span class="keyword">final</span> <span class="type">String</span> <span class="variable">joinpointIdentification</span> <span class="operator">=</span> methodIdentification(method, targetClass, txAttr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取事务</span></span><br><span class="line">  <span class="type">TransactionInfo</span> <span class="variable">txInfo</span> <span class="operator">=</span> createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line">  <span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    <span class="comment">//执行目标方法crud</span></span><br><span class="line">    retVal = invocation.proceedWithInvocation();</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">    <span class="comment">// crud执行异常回滚事务</span></span><br><span class="line">    completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">finally</span> {</span><br><span class="line">    cleanupTransactionInfo(txInfo);</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//提交事务</span></span><br><span class="line">  commitTransactionAfterReturning(txInfo);</span><br><span class="line">  <span class="keyword">return</span> retVal;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中调用了<code>PlatformTransactionManager</code>去执行物理事务，是负责执行增强任务的<code>Advice</code></p>
<h3 id="PlatformTransactionManager"><a href="#PlatformTransactionManager" class="headerlink" title="PlatformTransactionManager"></a>PlatformTransactionManager</h3><p>PlatformTransactionManager是Spring对于事务模型的抽象，它代表事务的整体执行过程。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PlatformTransactionManager</span> {</span><br><span class="line">    <span class="comment">// 获取事务的执行状态</span></span><br><span class="line">    TransactionStatus <span class="title function_">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">    <span class="comment">// 提交事务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">    <span class="comment">// 回滚事务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="其他的一些知识点"><a href="#其他的一些知识点" class="headerlink" title="其他的一些知识点"></a>其他的一些知识点</h2><h3 id="Spring中事务的传播行为"><a href="#Spring中事务的传播行为" class="headerlink" title="Spring中事务的传播行为"></a>Spring中事务的传播行为</h3><p>Spring中事务的传播模式有以下几种：</p>
<p><img src="/../images/Spring-%E4%BA%8B%E5%8A%A1%E4%BD%93%E7%B3%BB/%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%A8%A1%E5%BC%8F.png"></p>
<p>事务分为逻辑事务和物理事务：</p>
<ul>
<li>逻辑事务是指代码中事务的操作，即表面的业务逻辑</li>
<li>物理事务是数据库层面的操作，即从获取数据库连接到数据库执行事务完毕整个过程</li>
</ul>
<h3 id="事务失效的几种场景"><a href="#事务失效的几种场景" class="headerlink" title="事务失效的几种场景"></a>事务失效的几种场景</h3><p>这个部分是根据网上的博客总结出来的😎</p>
<ol>
<li>方法为<code>private</code>：事务代理类要求被代理方法必须是<code>public</code>的，否则不进行代理<ul>
<li>从 Spring 6.0 开始，<code>protected</code>方法可以被 CGLIB 代理</li>
</ul>
</li>
<li>方法用<code>final</code>修饰：Spring事务底层是基于AOP的，被final修饰的方法无法被代理类重写</li>
<li>方法内部调用：同理，代理类根据<code>@Transactional</code>代理方法，方法内部调用会绕过代理</li>
<li>多线程调用、异常捕获不对（默认捕获<code>RunningTimeError</code>）、未被Spring管理等等</li>
</ol>
<hr>
<p>参考：</p>
<ul>
<li><a href="https://juejin.cn/post/7106158883055353870">深入浅出Spring事务的实现原理</a></li>
<li><a href="https://juejin.cn/post/7003949263281455112?share_token=1c6f49e0-3d47-4380-af8d-de4d2b72a783">Spring事务不生效的12中场景</a></li>
<li><a href="https://juejin.cn/post/7212142580708802615?from=search-suggest">女朋友不懂Spring事务原理，今天给她讲清楚了！</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1808649">从 AbstractPointcutAdvisor 开始： Spring AOP 之 Advisor、PointcutAdvisor 介绍</a></li>
</ul>
]]></content>
      <categories>
        <category>Spring源码系列</category>
      </categories>
      <tags>
        <tag>Spring源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot实现GitHub第三方登录</title>
    <url>/2023/05/14/SpringBoot%E5%AE%9E%E7%8E%B0GitHub%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<h2 id="Github登录原理"><a href="#Github登录原理" class="headerlink" title="Github登录原理"></a>Github登录原理</h2><p>Github登录的原理是借助OAuth 2.0协议来实现，具体的流程是：首先用户被重定向到GitHub的授权页面，证明自己的身份并同意授权后获取一个授权码，然后客户端拿着授权码请求授权服务器获得一个Access Token</p>
<p>之后客户端就可以通过Access Token来与资源服务器进行交互，这个token是长期有效的，也可以服务端自行留存。服务端拿着这个token就可以请求GitHub并获得用户信息</p>
<p><img src="/../images/SpringBoot%E5%AE%9E%E7%8E%B0GitHub%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/image_u3kxu-6By6.png"></p>
<p>我们常见的单点登录平台，如Casdoor、logto等等，他们会在保存授权后获得的Access Token，并作为授权服务器提供服务。利用这些平台我们能更方便的管理账号系统，不用再去对不同的第三方平台做不同的授权实</p>
<span id="more"></span>

<p><img src="/../images/SpringBoot%E5%AE%9E%E7%8E%B0GitHub%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/2760332-20220412195835959-694117279_q0bggeLtdi.gif"></p>
<h1 id="SpringBoot实现GitHub登录"><a href="#SpringBoot实现GitHub登录" class="headerlink" title="SpringBoot实现GitHub登录"></a>SpringBoot实现GitHub登录</h1><p>首先，你需要在GitHub上创建一个<a href="https://github.com/settings/applications/new" title="Application">Application</a>，将我们的应用注册到GitHub</p>
<p><img src="/../images/SpringBoot%E5%AE%9E%E7%8E%B0GitHub%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/image_FUKgEjhTXM.png"></p>
<p>注意这个回调地址，它是用户授权后GitHub重定向用户的地址</p>
<p>注册完成后，将<code>client_id</code>和<code>client_secret</code>配置到SpringBoot应用中：</p>
<p><img src="/../images/SpringBoot%E5%AE%9E%E7%8E%B0GitHub%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/image_qoOfOfER8X.png"></p>
<p>下面是Demo：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(path = "oauth")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OAuthController</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value("${github.client.id}")</span></span><br><span class="line">    <span class="keyword">private</span> String clientId;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Value("${github.client.secret}")</span></span><br><span class="line">    <span class="keyword">private</span> String clientSecret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跳转到授权页面</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(path = "github")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">auth</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="type">String</span> <span class="variable">authorizeUri</span> <span class="operator">=</span> <span class="string">"https://github.com/login/oauth/authorize"</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">redirectUri</span> <span class="operator">=</span> <span class="string">"http://localhost:8080/oauth/redirect"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> authorizeUri </span><br><span class="line">                + <span class="string">"?client_id="</span> + githubClientProperties.getClientId()</span><br><span class="line">                + <span class="string">"&amp;redirect_uri="</span> + redirectUri;</span><br><span class="line">        response.sendRedirect(url);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Github回调接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestToken 授权码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(path = "redirect")</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleRedirect</span><span class="params">(<span class="meta">@RequestParam("code")</span> String requestToken, HttpServletResponse response)</span> {</span><br><span class="line">        <span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取Token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">tokenUrl</span> <span class="operator">=</span> <span class="string">"https://github.com/login/oauth/access_token"</span></span><br><span class="line">                + <span class="string">"?client_id="</span> + githubClientProperties.getClientId()</span><br><span class="line">                + <span class="string">"&amp;client_secret="</span> + githubClientProperties.getClientSecret()</span><br><span class="line">                + <span class="string">"&amp;code="</span> + requestToken;</span><br><span class="line"></span><br><span class="line">        <span class="type">AccessTokenResponse</span> <span class="variable">tokenResponse</span> <span class="operator">=</span> restTemplate.postForObject(tokenUrl, <span class="literal">null</span>, AccessTokenResponse.class);</span><br><span class="line">        <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> tokenResponse.getAccessToken();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取用户信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">apiUrl</span> <span class="operator">=</span> <span class="string">"https://api.github.com/user"</span>;</span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">        headers.set(<span class="string">"Authorization"</span>, <span class="string">"Bearer "</span> + accessToken);</span><br><span class="line">        HttpEntity&lt;String&gt; entity = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;&gt;(<span class="string">"parameters"</span>, headers);</span><br><span class="line">        ResponseEntity&lt;String&gt; resp = restTemplate.exchange(apiUrl, HttpMethod.GET, entity, String.class);</span><br><span class="line">        <span class="type">String</span> <span class="variable">userData</span> <span class="operator">=</span> resp.getBody();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将token返回给客户端</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">githubToken</span> <span class="operator">=</span> newCookie(<span class="string">"github_token"</span>, accessToken, <span class="string">"/"</span>, COOKIE_AGE);</span><br><span class="line">        response.addCookie(githubToken);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ResVo.ok(userData);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Cookie <span class="title function_">newCookie</span><span class="params">(String key, String session, String path, <span class="type">int</span> maxAge)</span> {</span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(key, session);</span><br><span class="line">        cookie.setPath(path);</span><br><span class="line">        cookie.setMaxAge(maxAge);</span><br><span class="line">        <span class="keyword">return</span> cookie;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<p>相关文档：</p>
<ul>
<li><a href="https://docs.github.com/zh/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps#web-application-flow" title="https://docs.github.com/zh/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps#web-application-flow">https://docs.github.com/zh/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps#web-application-flow</a></li>
<li><a href="https://casdoor.org/docs/overview" title="https://casdoor.org/docs/overview">https://casdoor.org/docs/overview</a></li>
</ul>
]]></content>
      <categories>
        <category>技术方案</category>
      </categories>
      <tags>
        <tag>oauth</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring中几个关键的后置处理器以及执行顺序</title>
    <url>/2024/01/26/Spring%E4%B8%AD%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E7%9A%84%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BB%A5%E5%8F%8A%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="BeanDefinitionRegistryPostProcessor"><a href="#BeanDefinitionRegistryPostProcessor" class="headerlink" title="BeanDefinitionRegistryPostProcessor"></a>BeanDefinitionRegistryPostProcessor</h2><p>作用时机：<strong>在所有 BeanDefinition被加载后执行，但在<code>BeanFactoryPostProcessor</code>之前</strong>。 </p>
<p>常见应用: 动态注册新的 bean 定义、修改或移除已有的 BeanDefinition。</p>
<h2 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h2><p>BeanFactory标准初始化之后，所有的BeanDefinition已经被加载，但标准Bean的实例还没被创建（不包括<code>BeanFactoryPostProcessor</code>类型）。该方法通常用于修改BeanDefinition，Bean的属性值等，甚至可以在此快速初始化Bean。</p>
<span id="more"></span>

<h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h2><p>作用时机：Bean初始化前后</p>
<p><code>BeanPostProcessors#ProcessBeforeInitialization()</code>在Bean初始化前调用</p>
<p><code>BeanPostProcessors#ProcessaAfterInitialization()</code>在Bean初始化后调用</p>
<p>…待补充</p>
]]></content>
      <categories>
        <category>Spring源码系列</category>
      </categories>
  </entry>
  <entry>
    <title>SpringMVC 实现原理</title>
    <url>/2024/05/12/SpringMVC-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>先看一下SpringMVC的处理流程：</p>
<p><img src="/../images/SpringMVC-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/image_HJ0Hg7mzst.png"></p>
<p>各个组件的作用：</p>
<ul>
<li><code>DispatcherServlet</code>：分发请求</li>
<li><code>HandlerMapping</code>：根据URL匹配能够处理当前<code>request</code>的<code>Handler</code>（也就是我们的 <code>Controller</code> ）和拦截器</li>
<li><code>HandlerAdapter</code>：负责实际执行<code>Handler</code>的处理方法，并返回<code>ModelAndView</code></li>
<li><code>ViewResolver</code>：将<code>ModelAndView</code>解析为实际的视图</li>
</ul>
<span id="more"></span>

<h2 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h2><ol>
<li><strong>首先用户发送请求——&gt;DispatcherServlet</strong>，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行 处理，作为统一访问点，进行全局的流程控制；</li>
<li><strong>DispatcherServlet——&gt;HandlerMapping</strong>， HandlerMapping 将会把请求映射为 <code>HandlerExecutionChain</code> 对象（包含Handler 处理器和<code>HandlerInterceptor</code> 拦截器）对象</li>
<li><strong>DispatcherServlet——&gt;HandlerAdapter</strong>，HandlerAdapter 将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理，并返回 ModelAndView；</li>
<li><strong>ModelAndView 的逻辑视图名——&gt; ViewResolver</strong>，ViewResolver 将把逻辑视图名解析为具体的 View</li>
<li><strong>View——&gt; 渲染</strong>，View 会根据传进来的 Model 模型数据进行渲染</li>
<li><strong>返回控制权给 DispatcherServlet</strong>，由 DispatcherServlet 返回响应给用户，到此一个流程结束。</li>
</ol>
<hr>
<p>上面的流程有两个关键点：<code>HandlerMapping</code>和<code>HandlerAdapter</code>，<code>HandlerAdapter</code>据说是使用了适配器模式，但具体适配了什么，我一直不知道🤨，直到后面看到了一篇博客才明白。至于它俩的作用，还得从Controller的定义方式说起</p>
<p>SpringMVC中定义Controller的方式有三种：</p>
<ul>
<li><code>@RequestMapping</code>最最最常用的方式，除了这个都不知道其他的了🤣</li>
<li>继承 org.springframework.web.servlet.mvc.Controller接口，大概是这样：</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component("/home")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomeController</span> <span class="keyword">implements</span> <span class="title class_">Controller</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handleRequest</span><span class="params">(HttpServletRequest request, </span></span><br><span class="line"><span class="params">            HttpServletResponse response)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>继承 org.springframework.web.HttpRequestHandler接口</li>
</ul>
<p>不管后面两个怎么实现，总之，他们仨的处理方式是不一样的，需要用到不同的<code>HandlerMapping</code>和<code>HandlerAdapter</code>处理，比如：</p>
<ul>
<li><code>@RequestMapping</code>→<code>RequestMappingHandlerMapping</code>和<code>RequestMappingHandlerAdapter</code></li>
<li><code>Controller</code>接口 → <code>BeanNameUrlHandlerMapping</code>和<code>HttpRequestHandlerAdapter</code></li>
<li><code>HttpRequestHandler</code>接口 → <code>BeanNameUrlHandlerMapping</code>和<code>HttpRequestHandlerAdapter</code></li>
</ul>
<h2 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h2><p><code>HandlerMapping</code>处理后所有的URL和对应的Handler都会被放在一个Map里做映射，这里其实是用了一个<em><strong>策略模式</strong></em>，<u><em><strong>根据Controller定义方式的不同使用不同策略的<code>HandlerMapping</code>去处理</strong></em></u></p>
<p>  <code>HandlerMapping</code> 是一个策略接口，<code>RequestMappingHandlerMapping</code>和<code>BeanNameUrlHandlerMapping</code>是对应的具体策略</p>
<p>  <code>HandlerExecutionChain</code>是一个封装策略的上下文角色</p>
<p>来看一下如何根据<code>request</code>来获取<code>HandlerMapping</code>：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerExecutionChain <span class="title function_">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.handlerMappings != <span class="literal">null</span>) {</span><br><span class="line">      <span class="keyword">for</span> (HandlerMapping mapping : <span class="built_in">this</span>.handlerMappings) {</span><br><span class="line">        <span class="type">HandlerExecutionChain</span> <span class="variable">handler</span> <span class="operator">=</span> mapping.getHandler(request);</span><br><span class="line">        <span class="keyword">if</span> (handler != <span class="literal">null</span>) {</span><br><span class="line">          <span class="keyword">return</span> handler;</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h2><p>说完<code>HandlerMapping</code>之后，下面就要来介绍<code>HandlerAdapter</code>了。</p>
<p>既然<code>Handler</code>有多种实现形式，但是Servlet需要的处理方法的结构却是固定的，都是以<code>request</code>和<code>response</code>作为方法入参，因此<code>HandlerAdapter</code>的实现类都实现了统一的<code>handle()</code>方法来处理Servlet</p>
<p>不过由于上面提到的<code>Handler</code>的形式不同，<u><em><strong><code>@RequestMapping</code>对应的<code>Handler</code>是一个方法，而其他两个对应的<code>Handler</code>是一个类，</strong></em></u>而HandlerAdapter使用了<em><strong>适配器模式</strong></em>能够模糊掉具体的实现，从而就能提供统一访问接口（妙😎）</p>
<p>我们来看一下<code>getHandlerAdapter()</code>方法，注意<code>Handler</code>是Object类型：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerAdapter <span class="title function_">getHandlerAdapter</span><span class="params">(Object handler)</span> </span><br><span class="line">        <span class="keyword">throws</span> ServletException {</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.handlerAdapters != <span class="literal">null</span>) {</span><br><span class="line">    <span class="keyword">for</span> (HandlerAdapter adapter : <span class="built_in">this</span>.handlerAdapters) {</span><br><span class="line">      <span class="keyword">if</span> (adapter.supports(handler)) {</span><br><span class="line">        <span class="keyword">return</span> adapter;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="DispatcherServlet的分发流程"><a href="#DispatcherServlet的分发流程" class="headerlink" title="DispatcherServlet的分发流程"></a>DispatcherServlet的分发流程</h2><p>最后看一下<code>DispatcherServlet#doDispatch()</code>的分发流程，注意<code>DispatcherServlet</code>是如何使用<code>HandlerMapping</code>和<code>HandlerAdapter</code>：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//1、根据URL（当然不一定非得是URL）匹配到一个处理器</span></span><br><span class="line">    mappedHandler = getHandler(processedRequest);</span><br><span class="line">    <span class="keyword">if</span> (mappedHandler == <span class="literal">null</span>) {</span><br><span class="line">      <span class="comment">// 若匹配不到Handler处理器，就404了</span></span><br><span class="line">      noHandlerFound(processedRequest, response);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、从HandlerExecutionChain里拿出Handler，然后找到属于它的适配器</span></span><br><span class="line">    <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//3、执行Handler上的所有拦截器的Pre方法</span></span><br><span class="line">    <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) {</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//4、真正执行handle方法，得到一个ModelAndView</span></span><br><span class="line">    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、视图渲染</span></span><br><span class="line">    applyDefaultViewName(processedRequest, mv);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6、执行拦截器的post方法（视图渲染完成后执行）</span></span><br><span class="line">    mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//7、执行拦截器的afterCompletion方法（不管抛出与否）</span></span><br><span class="line">  }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/zxd1435513775/article/details/103000992">https://blog.csdn.net/zxd1435513775/article/details/103000992</a></li>
</ul>
]]></content>
      <categories>
        <category>Spring源码系列</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>📌 Spring实现动态更新配置</title>
    <url>/2024/07/31/Spring%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>最近又在我的论坛项目中造轮子，场景是由于一些业务原因，比如接入了ChatGPT，<code>openai_key</code>可能会频繁的更新，或者添加新的敏感词等等都会造成项目中配置的变化，每次变动都需要修改配置文件并重新部署应用，这样是非常不方便的，动态的更新这些内存中的配置是需要解决的问题。</p>
<p>常见的做法是接入一个配置中心，如Apollo、ZK等等，但是目前项目中是没有用到这些中间件的，接入这些配置中心可能会给项目带来一些风险，况且我这是个单体项目，用这些复杂的配置中心有点大材小用了，再说直接拿来就用没什么意思</p>
<p>鉴于此，我参考了网上和Apollo配置中心的一些技术方案，实现了一个非常实用的配置拓展，支持从自定义数据源中获取配置，并注入到Environment中，且优先级最高，同时也支持配置的动态刷新</p>
<span id="more"></span>

<blockquote>
<p>为了更好的理解本文的逻辑，你可能需要以下前置知识点：<a href="/2024/06/21/Spring%20Environment%E4%BD%93%E7%B3%BB/">Spring Environment体系</a></p>
</blockquote>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><u><em><strong>直接说思路：</strong></em></u>借助Mysql，维护一个配置表<code>global_config</code>（原因是方便构造自定义数据源和持久化用户配置），在Spring启动时读取数据库中的数据构造我们自定义的属性源，并注入到<code>Environment</code>中，再<strong>利用<code>Binder</code>更新</strong>内存中的<code>ConfigurationProperties</code>对象，这样就可以实现覆盖<code>properties</code>文件中的配置</p>
<blockquote>
<p>其实这里存在一个问题，就是如果能在<code>PropertySourcesPropertyResolver</code>的配置解析阶段就将自定义的属性源注入，那么初始化后的<code>ConfigurationProperties</code>对象和 <code>@Value</code>标记的字段本身就是我们自定义数据源中的配置，但我尝试后发现无论如何都无法在解析前将自定义数据源注入到Environment中，于是只能在项目完全启动后刷新所有配置<br><img src="/../images/Spring%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E9%85%8D%E7%BD%AE/image_Secure2_Image.png"></p>
</blockquote>
<h2 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h2><p>我的项目中配置的使用姿势主要分两种：</p>
<ol>
<li>通过<code>@ConfigurationProperties</code>注入的<code>Property</code>对象</li>
<li>通过<code>@Value</code>注入的配置字段</li>
</ol>
<p>两个部分需要不同的更新方式，因此配置的更新方式分为以下两部分：</p>
<h3 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a><code>@ConfigurationProperties</code></h3><ul>
<li>在初始化阶段：读取数据库中的配置表 → 生成自定义<code>MapPropertySource</code> → <strong>将自定义<code>MapPropertySource</code>添加到Environment中并设置为最高优先级</strong></li>
<li>监听到配置变更：检查DB中的数据库与当前缓存中的<code>MapPropertySource</code>是否一致 ，如果不一致就调用<code>refresh()</code>方法刷新Environment中的<code>MapPropertySource</code>。refresh方法的逻辑其实就是<strong>重新使用Binder绑定内存中的<code>ConfigurationProperties</code></strong></li>
</ul>
<h3 id="Value"><a href="#Value" class="headerlink" title="@Value"></a><code>@Value</code></h3><p>这部分的配置更新参考了<a href="https://github.com/apolloconfig/apollo/pull/972">Apollo PR#972</a>的实现：利用一个<strong>括号匹配</strong>算法，在<code>BeanPostProcessor</code>阶段扫描所有带<code>@Value</code>占位符的Bean，包括表达式、占位符等等，连带对应的Bean引用全部存起来</p>
<p>当有相关的key变化时，通过Bean的引用反射更新对应的Bean字段，你也可以使用观察者模式监听对应的key的变化，就可以做到当配置变化后自动触发对应Bean字段的更新</p>
<blockquote>
<p> 📌 这里两种方式不同是因为<code>@ConfigurationProperties</code>是借助<code>Environment</code>中的属性源实现的，而<code>@Value</code>的实现则是依赖于<code>ConfigurablePropertyResolver</code>，两者虽然都实现了PropertyResolver但是没有任何直接关系，属于不同的属性解析器，因此改变<code>Environment</code>中的属性源并不能影响<code>@Value</code>，需要额外对<code>@Value</code>配置的属性做更新</p>
<p><img src="/../images/Spring%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E9%85%8D%E7%BD%AE/image_env.png"></p>
</blockquote>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>这部分的代码具体实现其实也参考了<code>ConfigurationProperties</code>的注入原理——</p>
<p>（<code>ConfigurationPropertiesBindingPostProcessor</code>）的实现。为了缩减篇幅删除了一些非核心逻辑：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义的动态配置工厂类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> qing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024/8/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicConfigContainer</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span>, InitializingBean, EnvironmentAware, CommandLineRunner {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConfigurableEnvironment environment;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储db中的全局配置，优先级最高</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DynamicConfigBinder binder;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        cache = Maps.newHashMap();</span><br><span class="line">        <span class="built_in">this</span>.binder = <span class="keyword">new</span> <span class="title class_">DynamicConfigBinder</span>(<span class="built_in">this</span>.applicationContext, environment.getPropertySources());</span><br><span class="line">        bindBeansFromLocalCache(<span class="string">"dbConfig"</span>, cache);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从db中获取全量的配置信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 表示有信息变更; false 表示无信息变更</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">loadAllConfigFromDb</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">"select `key`, `value` from global_conf where deleted = 0"</span>;</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; list = applicationContext.getBean(JdbcTemplate.class).queryForList(sql);</span><br><span class="line">        Map&lt;String, Object&gt; val = Maps.newHashMapWithExpectedSize(list.size());</span><br><span class="line">        <span class="keyword">for</span> (Map&lt;String, Object&gt; conf : list) {</span><br><span class="line">            val.put(conf.get(<span class="string">"key"</span>).toString(), conf.get(<span class="string">"value"</span>).toString());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (val.equals(cache)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        cache.clear();</span><br><span class="line">        cache.putAll(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bindBeansFromLocalCache</span><span class="params">(String namespace, Map&lt;String, Object&gt; cache)</span> {</span><br><span class="line">        <span class="comment">// 将内存的配置信息设置为最高优先级</span></span><br><span class="line">        <span class="type">MapPropertySource</span> <span class="variable">propertySource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapPropertySource</span>(namespace, cache);</span><br><span class="line">        environment.getPropertySources().addFirst(propertySource);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Bindable bindable)</span> {</span><br><span class="line">        binder.bind(bindable);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听配置的变更</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reloadConfig</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">before</span> <span class="operator">=</span> JsonUtil.toStr(cache);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">toRefresh</span> <span class="operator">=</span> loadAllConfigFromDb();</span><br><span class="line">        <span class="keyword">if</span> (toRefresh) {</span><br><span class="line">            refreshConfig();</span><br><span class="line">            log.info(<span class="string">"config update! Old:{}, New:{}"</span>, before, JsonUtil.toStr(cache));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持配置的动态刷新</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">refreshConfig</span><span class="params">()</span> {</span><br><span class="line">        applicationContext.getBeansWithAnnotation(ConfigurationProperties.class).values().forEach(bean -&gt; {</span><br><span class="line">            Bindable&lt;?&gt; target = Bindable.ofInstance(bean).withAnnotations(AnnotationUtils.findAnnotation(bean.getClass(), ConfigurationProperties.class));</span><br><span class="line">            bind(target);</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 应用启动之后，执行的动态配置初始化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        reloadConfig();</span><br><span class="line">        <span class="comment">// SpringValueRegistry.updateAll();</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicConfigBinder</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PropertySources propertySources;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Binder binder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicConfigBinder</span><span class="params">(ApplicationContext applicationContext, PropertySources propertySources)</span> {</span><br><span class="line">        <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">        <span class="built_in">this</span>.propertySources = propertySources;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Bindable&lt;T&gt; bindable)</span> {</span><br><span class="line">        <span class="type">ConfigurationProperties</span> <span class="variable">propertiesAno</span> <span class="operator">=</span> bindable.getAnnotation(ConfigurationProperties.class);</span><br><span class="line">        <span class="keyword">if</span> (propertiesAno != <span class="literal">null</span>) {</span><br><span class="line">            <span class="type">BindHandler</span> <span class="variable">bindHandler</span> <span class="operator">=</span> getBindHandler(propertiesAno);</span><br><span class="line">            getBinder().bind(propertiesAno.prefix(), bindable, bindHandler);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(String prefix, Bindable&lt;T&gt; bindable, BindHandler bindHandler)</span> {</span><br><span class="line">        getBinder().bind(prefix, bindable, bindHandler);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BindHandler <span class="title function_">getBindHandler</span><span class="params">(ConfigurationProperties annotation)</span> {</span><br><span class="line">        <span class="type">BindHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IgnoreTopLevelConverterNotFoundBindHandler</span>();</span><br><span class="line">        <span class="keyword">if</span> (annotation.ignoreInvalidFields()) {</span><br><span class="line">            handler = <span class="keyword">new</span> <span class="title class_">IgnoreErrorsBindHandler</span>(handler);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!annotation.ignoreUnknownFields()) {</span><br><span class="line">            <span class="type">UnboundElementsSourceFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnboundElementsSourceFilter</span>();</span><br><span class="line">            handler = <span class="keyword">new</span> <span class="title class_">NoUnboundElementsBindHandler</span>(handler, filter);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参考ConfigurationPropertiesBindingPostProcessor</span></span><br><span class="line">    <span class="keyword">private</span> Binder <span class="title function_">getBinder</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.binder == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) {</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.binder == <span class="literal">null</span>) {</span><br><span class="line">                    <span class="built_in">this</span>.binder = <span class="keyword">new</span> <span class="title class_">Binder</span>(getConfigurationPropertySources(),</span><br><span class="line">                            getPropertySourcesPlaceholdersResolver(), getConversionService(),</span><br><span class="line">                            getPropertyEditorInitializer());</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.binder;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><img src="/../images/Spring%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E9%85%8D%E7%BD%AE/image_Spring%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E9%85%8D%E7%BD%AE.png"></p>
<p>这里就可以看到我们自定义的属性源<code>dbConfig</code>已经被注入成功啦😃</p>
<p>除此之外，当监听到对应的配置更新时，除了更新数据库，还需要推送对应的消息，在这里由于我项目中使用的是Spring Event实现的消息机制，因此监听者的操作如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ConfigRefreshEvent event)</span> {</span><br><span class="line">    dynamicConfigContainer.reloadConfig();</span><br><span class="line">    <span class="comment">// SpringValueRegistry.updateValue(event.getKey());</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>至于<code>@Value</code>的部分，代码比较多就不贴了，具体可以参考在<a href="https://github.com/qing-wq/SAI-Forum-backend/tree/rabbitmq/sai-core/src/main/java/ink/whi/core/autoconf/apollo">https://github.com/qing-wq/SAI-Forum-backend/tree/rabbitmq/sai-core/src/main/java/ink/whi/core/autoconf/apollo</a></p>
]]></content>
      <categories>
        <category>技术方案</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>✍🏻 Spring源码阅读记录</title>
    <url>/2024/03/31/Spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<blockquote>
<p>标记的表示已读</p>
</blockquote>
<h1 id="Spring-Core"><a href="#Spring-Core" class="headerlink" title="Spring Core"></a>Spring Core</h1><h2 id="资源加载与访问"><a href="#资源加载与访问" class="headerlink" title="资源加载与访问"></a>资源加载与访问</h2><ul>
<li>Resource：抽象接口，表示文件、类路径等，用于访问不同来源的资源。</li>
<li>ResourceLoader：资源获取核心接口，实现统一加载不同位置资源的策略。</li>
<li>ResourcePatternResolver：资源模式解析接口，用于灵活加载应用中的多种资源。</li>
<li>DocumentLoader：XML文档加载解析核心接口，支持后台自动配置Spring应用。</li>
</ul>
<span id="more"></span>

<h2 id="元数据与过滤"><a href="#元数据与过滤" class="headerlink" title="元数据与过滤"></a>元数据与过滤</h2><ul>
<li>MetadataReader：类元数据获取核心，支持组件扫描、条件化注解、AOP等高级功能。</li>
<li>AnnotationMetadata：动态获取和操作运行时类注解信息。</li>
<li>TypeFilter：组件扫描时自定义类筛选，支持复杂条件和精确过滤。</li>
<li>Condition：条件判断，决定Bean创建和配置的灵活机制。</li>
</ul>
<h2 id="验证、数据绑定和类型转换"><a href="#验证、数据绑定和类型转换" class="headerlink" title="验证、数据绑定和类型转换"></a>验证、数据绑定和类型转换</h2><ul>
<li>Validator：提供自定义数据验证逻辑，确保模型对象满足业务规则。</li>
<li>PropertyEditor：自定义JavaBean属性的转换逻辑，处理属性类型转换。</li>
<li>Converter：用于不同类型间的转换，定义简单的源至目标类型转换规则。</li>
<li>ConverterFactory：创建针对特定源类型的转换器，用于类型转换。</li>
<li>GenericConverter：更复杂的转换器，支持多种源和目标类型转换。</li>
<li>ConditionalConverter：根据条件选择是否执行转换的转换器。</li>
<li>ConversionService：提供统一的类型转换服务接口，管理转换器。</li>
<li>Printer：用于将对象格式化为文本，专注于格式化输出。</li>
<li>Parser：用于将文本解析为对象，专注于解析逻辑。</li>
</ul>
<h2 id="Spring-表达式语言（SpEL）"><a href="#Spring-表达式语言（SpEL）" class="headerlink" title="Spring 表达式语言（SpEL）"></a>Spring 表达式语言（SpEL）</h2><ul>
<li>ExpressionParser: 解析字符串形式的 SpEL 表达式，创建并返回 Expression 实例。</li>
<li>Expression: 对表达式字符串进行求值的功能，支持类型转换、获取原始字符串等操作。</li>
<li>EvaluationContext: 管理SpEL表达式的上下文信息。</li>
<li>PropertyAccessor: 用于读取和写入对象的属性，可用于实现自定义的属性访问逻辑。</li>
<li>ConstructorResolver: 解析构造函数确定bean的实例化方式。</li>
<li>MethodResolver: 解析类方法，确保正确调用，处理重载和参数匹配。</li>
<li>BeanResolver: 解析bean定义，包括依赖、属性设置，实例化并返回。</li>
<li>TypeLocator: 动态查找类，返回Class对象，在表达式解析、类型转换等。</li>
<li>TypeConverter: 类型转换功能，将表达式中的数据从一种类型转换为另一种类型。</li>
<li>TypeComparator: 类型比较功能，定义了比较两个对象是否相等的方法。</li>
<li>OperatorOverloader: 运算符重载功能，对表达式中的运算符进行自定义操作的方法。</li>
</ul>
<h2 id="Bean定义与注册"><a href="#Bean定义与注册" class="headerlink" title="Bean定义与注册"></a>Bean定义与注册</h2><ul>
<li><u>BeanDefinition</u>：详细描述Bean，支持依赖注入、AOP、作用域控制等核心功能。</li>
<li><u>BeanDefinitionHolder</u>：管理和操作BeanDefinition的关键类。</li>
<li><u>BeanDefinitionRegistry</u>：Bean定义注册管理关键接口，处理Bean元数据。</li>
</ul>
<h2 id="Bean定义读取与扫描"><a href="#Bean定义读取与扫描" class="headerlink" title="Bean定义读取与扫描"></a>Bean定义读取与扫描</h2><ul>
<li>XmlBeanDefinitionReader：加载解析XML配置，构建IOC容器，注册Bean定义。</li>
<li>PropertiesBeanDefinitionReader：属性文件加载，解析为Bean定义。</li>
<li>GroovyBeanDefinitionReader：Groovy脚本解析为Bean定义。</li>
<li>AnnotatedBeanDefinitionReader：注解配置，自动扫描注册Spring组件，简化Bean定义配置。</li>
<li><u>ClassPathBeanDefinitionScanner</u>：类路径扫描注册Spring Bean，支持自动装配。</li>
</ul>
<h2 id="Bean工厂"><a href="#Bean工厂" class="headerlink" title="Bean工厂"></a>Bean工厂</h2><ul>
<li><u>BeanFactory</u>：Spring的核心接口，提供对Bean的配置、创建、管理的基本功能。</li>
<li>ListableBeanFactory：支持按类型获取Bean的集合。</li>
<li>HierarchicalBeanFactory：支持父子容器关系，实现Bean定义的层次结构。</li>
<li>ConfigurableBeanFactory：提供对BeanFactory配置的扩展，如属性编辑器、作用域等。</li>
<li>AutowireCapableBeanFactory：Bean创建、初始化、注入、销毁的核心功能接口。</li>
<li><u>ConfigurableListableBeanFactory</u>：支持配置和列表操作的可配置Bean工厂接口。</li>
</ul>
<h2 id="容器上下文"><a href="#容器上下文" class="headerlink" title="容器上下文"></a>容器上下文</h2><ul>
<li><u>ClassPathXmlApplicationContext</u>：类路径（classpath）加载 XML 配置文件的上下文。</li>
<li><u>AnnotationConfigApplicationContext</u>：注解配置类中加载配置信息的上下文。</li>
<li><u>GenericApplicationContext</u>：支持多种配置方式，XML、注解、手动注册的上下文。</li>
</ul>
<h2 id="Bean定义导入与组合"><a href="#Bean定义导入与组合" class="headerlink" title="Bean定义导入与组合"></a>Bean定义导入与组合</h2><ul>
<li><u>ImportBeanDefinitionRegistrar</u>：运行时动态注册 Bean，实现灵活配置，扩展配置类功能。</li>
<li><u>ImportSelector</u>：运行时动态导入配置类，实现条件选择和灵活配置。</li>
<li>DeferredImportSelector：运行时动态导入配置，支持条件选择和按组别延迟加载。</li>
</ul>
<h2 id="Bean生命周期"><a href="#Bean生命周期" class="headerlink" title="Bean生命周期"></a>Bean生命周期</h2><ul>
<li><u>Bean的定义注册过程</u>：加载与解析配置文件，注册解析Bean定义，类名、作用域、属性等。</li>
<li><u>Bean的初始化过程</u>：实例化、属性注入、Aware回调、后置处理器、初始化方法调用。</li>
<li><u>Bean的依赖解析过程</u>：声明依赖，查找依赖，注入依赖，处理循环依赖，延迟依赖解析。</li>
<li><u>Bean的销毁过程</u>：销毁方法调用，接口回调，后处理清理，通知触发，GC回收资源。</li>
</ul>
<h2 id="属性解析和环境配置"><a href="#属性解析和环境配置" class="headerlink" title="属性解析和环境配置"></a>属性解析和环境配置</h2><blockquote>
<p><a href="/2024/06/21/Spring%20Environment%E4%BD%93%E7%B3%BB/">Spring Environment体系</a></p>
</blockquote>
<ul>
<li><u>PropertySource</u>：管理各种配置源的抽象类，支持灵活地加载和访问应用配置。</li>
<li><u>PropertySources</u>：用于统一管理和访问多个 PropertySource 实例，简化配置数据的处理。</li>
<li><u>PropertyResolver</u>：通用属性解析，获取配置值，处理属性缺失，简便灵活。</li>
<li><u>ConfigurablePropertyResolver</u>：属性解析配置，占位符设置，适应不同配置需求。</li>
<li><u>Environment</u>：应用环境表示，提供属性访问，支持配置文件，实现动态配置。</li>
<li><u>ConfigurableEnvironment</u>：动态配置应用环境，激活、默认配置，提升应用灵活性。</li>
</ul>
<h2 id="Bean初始化与扩展点"><a href="#Bean初始化与扩展点" class="headerlink" title="Bean初始化与扩展点"></a>Bean初始化与扩展点</h2><ul>
<li><u>InitializingBean</u>：提供Bean初始化时执行自定义逻辑的接口。</li>
<li>DisposableBean：定义Bean销毁前执行清理操作的接口。</li>
<li><u>BeanDefinitionRegistryPostProcessor</u>：在容器启动时，对BeanDefinition动态修改或添加。</li>
<li><u>BeanFactoryPostProcessor</u>：在Bean实例化前，对BeanFactory进行全局修改或配置。</li>
<li><u>BeanPostProcessor</u>：在Bean初始化前后，进行自定义处理，可影响所有Bean。</li>
<li>InstantiationAwareBeanPostProcessor：提供更深层次的实例化和属性注入控制。</li>
<li>DestructionAwareBeanPostProcessor： 允许在Bean销毁前进行额外的清理操作。</li>
<li>MergedBeanDefinitionPostProcessor：在合并Bean定义时对BeanDefinition进行处理。</li>
<li>SmartInstantiationAwareBeanPostProcessor：提供更智能的实例化控制。</li>
<li>SmartInitializingSingleton：在所有单例Bean初始化完成后，执行自定义逻辑。</li>
</ul>
<h2 id="Aware接口系列"><a href="#Aware接口系列" class="headerlink" title="Aware接口系列"></a>Aware接口系列</h2><ul>
<li>BeanNameAware：让Bean获取自身在容器中的名字。</li>
<li>BeanClassLoaderAware：允许Bean获取其类加载器。</li>
<li>BeanFactoryAware：提供Bean获取所属的BeanFactory。</li>
<li><u>EnvironmentAware</u>：允许Bean获取应用程序环境配置。</li>
<li>EmbeddedValueResolverAware：允许Bean解析嵌入式值占位符。</li>
<li>ResourceLoaderAware：允许Bean获取资源加载器。</li>
<li>ApplicationEventPublisherAware：允许Bean发布应用程序事件。</li>
<li>MessageSourceAware：允许Bean获取消息源。</li>
<li><u>ApplicationContextAware</u>：允许Bean获取应用程序上下文。</li>
<li>ImportAware：允许被导入的配置类获取导入它的类的信息。</li>
</ul>
<h2 id="核心注解"><a href="#核心注解" class="headerlink" title="核心注解"></a>核心注解</h2><ul>
<li><u>@Configuration</u>：声明类为配置类，定义Bean和Bean之间的依赖关系。</li>
<li><u>@ComponentScan</u>：启用组件扫描，自动发现并注册标记为组件的类。</li>
<li><u>@Bean</u>：在配置类中声明方法，返回Bean实例。</li>
<li><u>@Import</u>：引入其他配置类，将其Bean定义合并到当前容器。</li>
<li>@PropertySource：指定属性文件，加载外部配置到环境中。</li>
<li>@DependsOn：指定Bean的依赖顺序，确保特定Bean在其他Bean之前初始化。</li>
<li><u>@Conditional</u>：根据条件决定是否创建Bean。</li>
<li>@Lazy：指定Bean的延迟初始化，只有在首次使用时才创建。</li>
<li>@Value：注入简单值或表达式到Bean的字段或方法参数。</li>
<li><u>@Autowired</u>：自动装配Bean依赖。</li>
<li>@Primary：指定在多个候选Bean中优先选择的首选Bean。</li>
<li>@Role：为Bean提供角色提示，用于区分相似类型的Bean。</li>
<li>@Indexed： 标记Bean用于索引。</li>
<li>@Order：指定Bean的加载顺序。</li>
</ul>
<h2 id="JSR规范"><a href="#JSR规范" class="headerlink" title="JSR规范"></a>JSR规范</h2><ul>
<li>@Inject：JSR-330标准的依赖注入注解。</li>
<li>@Named：JSR-330标准的命名注解。</li>
<li>@Resource：Java EE标准的资源注入注解。</li>
<li>@Qualifier：用于限定注入的Bean。</li>
<li>@Scope：指定Bean的作用域。</li>
<li>@Singleton：指定Bean为单例。</li>
<li>@PostConstruct：指定初始化方法。</li>
<li>@PreDestroy：指定销毁方法。</li>
<li>Provider：Java标准库提供的通用Bean工厂接口。</li>
</ul>
<h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><ul>
<li>JDK动态代理：接口实现，动态生成代理类，处理方法调用，统一横切关注点。</li>
<li>Cglib动态代理：基于字节码生成的库，无需接口，可拦截类方法并进行增强。</li>
<li>ClassFilter：确定类是否匹配拦截条件。</li>
<li>MethodMatcher：确定方法是否匹配拦截条件。</li>
<li>Pointcut：定义切入点，匹配被拦截的方法。</li>
<li>Advice：AOP中定义各种通知类型行为的核心接口。</li>
<li>MethodInterceptor：拦截方法执行，允许在前后添加额外逻辑。</li>
<li>MethodBeforeAdvice：允许在方法调用之前插入自定义逻辑。</li>
<li>AfterReturningAdvice：允许在方法调用之后插入自定义逻辑。&lt;</li>
<li>ThrowsAdvice：异常通知，捕获方法抛出的异常，执行额外逻辑。</li>
<li>IntroductionInterceptor：动态地向目标对象引入新的功能或属性。</li>
<li>Advisor：用于将通知和切点结合，实现切面编程的横切关注点。</li>
<li>Advised：配置AOP代理的通知、通知器、目标等。</li>
<li>ProxyFactory：一种便捷的方式来创建代理对象。</li>
<li>AopProxyFactory：创建AOP代理工厂，支持JDK和CGLIB。</li>
<li>AopProxy：创建和管理AOP代理对象。</li>
<li>AdvisorChainFactory：创建Advisor链的工厂接口。</li>
<li>AdvisorAdapterRegistry：适配各种Advice到AOP拦截器，注册和管理Advisor适配器。</li>
<li>AdvisorAdapter：适配不同类型通知到拦截器链。</li>
<li>ProxyMethodInvocation：AOP方法调用代理，处理拦截器链和方法调用。</li>
<li>@EnableAspectJAutoProxy：启用AspectJ切面自动代理。</li>
<li>AnnotationAwareAspectJAutoProxyCreator：创建AOP代理以应用AspectJ风格的切面。</li>
<li>BeanFactoryAdvisorRetrievalHelper：帮助检索并管理Spring AOP 中的 Advisor Beans。</li>
<li>BeanFactoryAspectJAdvisorsBuilder：构建@AspectJ注解切面，生成Spring AOP Advisors。</li>
<li>AspectInstanceFactory：创建切面实例，支持多种实现方式。</li>
<li>MetadataAwareAspectInstanceFactory：管理切面实例和元数据，支持多种实例化策略。</li>
<li>AspectJAdvisorFactory：创建AspectJ通知器实例，管理切面通知的创建和配置。</li>
<li>TargetSource：管理AOP代理对象的获取与释放。</li>
<li>TargetSourceCreator：创建特殊的目标源，定制代理对象的创建和管理。</li>
<li>AopContext：获取Spring AOP代理对象的工具。</li>
<li>ExposeInvocationInterceptor：暴露Spring AOP方法调用上下文的拦截器。</li>
<li>@EnableLoadTimeWeaving：启用Spring加载时编织。</li>
</ul>
<h2 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h2><blockquote>
<p><a href="2024/05/08/Spring-%E4%BA%8B%E5%8A%A1%E4%BD%93%E7%B3%BB/">Spring 事务体系</a></p>
</blockquote>
<ul>
<li>Connection：管理数据库连接，执行SQL，处理事务。</li>
<li>DataSource：提供高效管理数据库连接的接口。</li>
<li>DriverManager：管理和建立数据库连接的核心类。</li>
<li>JdbcTemplate：简化了JDBC操作，提供了方便的数据库访问抽象。</li>
<li><u>TransactionDefinition</u>：定义事务的传播行为和隔离级别。</li>
<li><u>TransactionAttributeSource</u>：用于获取事务属性的策略接口。</li>
<li><u>PlatformTransactionManager</u>：用于管理和协调事务的生命周期和执行。</li>
<li><u>TransactionTemplate</u>：简化事务管理，支持编程式事务控制与异常处理。</li>
<li><u>SpringTransactionAnnotationParser</u>：解析 @Transactional注解并转换为事务配置。</li>
<li><u>TransactionInterceptor</u>：事务拦截器，用于管理方法级别的事务处理。</li>
<li><u>EnableTransactionManagement</u>：启用Spring的注解驱动事务管理。</li>
</ul>
]]></content>
      <categories>
        <category>Spring源码系列</category>
      </categories>
      <tags>
        <tag>Spring源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>项目中的全局异常处理</title>
    <url>/2022/09/08/Spring%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h2><p><strong>自定义异常</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BusinessException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(BusinessException.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String errorMsg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getErrorMsg</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> errorMsg;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setErrorMsg</span><span class="params">(String errorMsg)</span> {</span><br><span class="line">        <span class="built_in">this</span>.errorMsg = errorMsg;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BusinessException <span class="title function_">withErrorCode</span><span class="params">(String message)</span> {</span><br><span class="line">        <span class="type">BusinessException</span> <span class="variable">businessException</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>();</span><br><span class="line">        businessException.setErrorMsg(message);</span><br><span class="line">        <span class="keyword">return</span> businessException;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<span id="more"></span>

<p><strong>全局异常捕获</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.MissingServletRequestParameterException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.file.AccessDeniedException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数格式异常处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler({IllegalArgumentException.class})</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.BAD_REQUEST)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResult&lt;String&gt; <span class="title function_">badRequestException</span><span class="params">(IllegalArgumentException ex)</span> {</span><br><span class="line">        log.error(<span class="string">"[Error]: 参数格式不合法：{}"</span>, ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiResult</span>&lt;&gt;(HttpStatus.BAD_REQUEST.value() + <span class="string">""</span>, <span class="string">"参数格式不符！"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 权限不足异常处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler({AccessDeniedException.class})</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.FORBIDDEN)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResult&lt;String&gt; <span class="title function_">badRequestException</span><span class="params">(AccessDeniedException ex)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiResult</span>&lt;&gt;(HttpStatus.FORBIDDEN.value() + <span class="string">""</span>, ex.getMessage());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数缺失异常处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler({MissingServletRequestParameterException.class})</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.BAD_REQUEST)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResult&lt;String&gt; <span class="title function_">badRequestException</span><span class="params">(Exception ex)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiResult</span>&lt;&gt;(HttpStatus.BAD_REQUEST.value() + <span class="string">""</span>, <span class="string">"缺少必填参数！"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空指针异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(NullPointerException.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResult&lt;String&gt; <span class="title function_">handleTypeMismatchException</span><span class="params">(NullPointerException ex)</span> {</span><br><span class="line">        log.error(<span class="string">"[Error]: 空指针异常，{}"</span>, ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> ApiResult.fail(<span class="string">"空指针异常"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResult&lt;String&gt; <span class="title function_">handleUnexpectedServer</span><span class="params">(Exception ex)</span> {</span><br><span class="line">        log.error(<span class="string">"[Error]: 系统异常："</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> ApiResult.fail(<span class="string">"系统发生异常，请联系管理员"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 系统异常处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Throwable.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResult&lt;String&gt; <span class="title function_">exception</span><span class="params">(Throwable throwable)</span> {</span><br><span class="line">        log.error(<span class="string">"[Error]: 系统异常"</span>, throwable);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiResult</span>&lt;&gt;(HttpStatus.INTERNAL_SERVER_ERROR.value() + <span class="string">"系统异常，请联系管理员！"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 自定义异常处理类</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@Order</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.BAD_REQUEST)</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = BusinessException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResult&lt;String&gt; <span class="title function_">BusinessHandler</span><span class="params">(BusinessException e)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> e.getErrorMsg();</span><br><span class="line">        log.error(<span class="string">"[Error]: {}"</span>, e.getErrorMsg());</span><br><span class="line">        <span class="keyword">return</span> ApiResult.fail(msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="响应参数封装"><a href="#响应参数封装" class="headerlink" title="响应参数封装"></a>响应参数封装</h2><p><strong>错误码枚举类</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ResponseCodeEnums</span> {</span><br><span class="line"></span><br><span class="line">    SUCCESS(<span class="number">200</span>, <span class="string">"success"</span>),</span><br><span class="line">    FAIL(<span class="number">500</span>, <span class="string">"fail"</span>),</span><br><span class="line"></span><br><span class="line">    HTTP_STATUS_200(<span class="number">200</span>, <span class="string">"ok"</span>),</span><br><span class="line">    HTTP_STATUS_400(<span class="number">400</span>, <span class="string">"request error"</span>),</span><br><span class="line">    HTTP_STATUS_401(<span class="number">401</span>, <span class="string">"no authentication"</span>),</span><br><span class="line">    HTTP_STATUS_403(<span class="number">403</span>, <span class="string">"authorities"</span>),</span><br><span class="line">    HTTP_STATUS_500(<span class="number">500</span>, <span class="string">"server error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>统一返回结果实体类</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiResult</span>&lt;T&gt; {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 状态码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> String message;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ApiResult&lt;T&gt; <span class="title function_">success</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiResult</span>&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ApiResult&lt;T&gt; <span class="title function_">success</span><span class="params">(T data)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiResult</span>&lt;&gt;(data);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ApiResult&lt;T&gt; <span class="title function_">fail</span><span class="params">(String message)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiResult</span>&lt;&gt;(ResponseCodeEnums.FAIL.getCode(), message);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ApiResult</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">this</span>.code = ResponseCodeEnums.SUCCESS.getCode();</span><br><span class="line">        <span class="built_in">this</span>.message = ResponseCodeEnums.SUCCESS.getMessage();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ApiResult</span><span class="params">(ResponseCodeEnums statusEnums)</span> {</span><br><span class="line">        <span class="built_in">this</span>.code = statusEnums.getCode();</span><br><span class="line">        <span class="built_in">this</span>.message = statusEnums.getMessage();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 若没有数据返回，可以人为指定状态码和提示信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ApiResult</span><span class="params">(<span class="type">int</span> code, String msg)</span> {</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.message = msg;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有数据返回时，状态码为200，默认提示信息为“操作成功！”</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ApiResult</span><span class="params">(T data)</span> {</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.code = ResponseCodeEnums.SUCCESS.getCode();</span><br><span class="line">        <span class="built_in">this</span>.message = ResponseCodeEnums.SUCCESS.getMessage();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有数据返回，状态码为 200，人为指定提示信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ApiResult</span><span class="params">(T data, String msg)</span> {</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.code = ResponseCodeEnums.SUCCESS.getCode();</span><br><span class="line">        <span class="built_in">this</span>.message = msg;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="全局响应"><a href="#全局响应" class="headerlink" title="全局响应"></a>全局响应</h2><p>对api的返回值进行二次封装</p>
<p><code>HandlerMethodReturnValueHandler</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.assertj.core.util.Lists;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.MethodParameter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.AntPathMatcher;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.NativeWebRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.method.support.HandlerMethodReturnValueHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.method.support.ModelAndViewContainer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHandlerMethodReturnValueHandler</span> <span class="keyword">implements</span> <span class="title class_">HandlerMethodReturnValueHandler</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HandlerMethodReturnValueHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyHandlerMethodReturnValueHandler</span><span class="params">(HandlerMethodReturnValueHandler handler)</span> {</span><br><span class="line">        <span class="built_in">this</span>.handler = handler;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理器支持相应的返回值类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> returnType the method return type to check</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsReturnType</span><span class="params">(MethodParameter returnType)</span> {</span><br><span class="line"><span class="comment">//        return ApiResult.class.isAssignableFrom(returnType.getParameterType());  // 处理返回值为ApiResult的情况</span></span><br><span class="line">        <span class="keyword">return</span> handler.supportsReturnType(returnType);  <span class="comment">// 处理全部返回值</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对方法返回值进行处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> returnValue the value returned from the handler method</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> returnType the type of the return value. This type must have</span></span><br><span class="line"><span class="comment">     * previously been passed to {<span class="doctag">@link</span> #supportsReturnType} which must</span></span><br><span class="line"><span class="comment">     * have returned {<span class="doctag">@code</span> true}.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mavContainer the ModelAndViewContainer for the current request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> webRequest the current request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleReturnValue</span><span class="params">(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="comment">// 判断返回值外层是否被ApiResult包裹，如果是就交给handler处理</span></span><br><span class="line">        <span class="keyword">if</span> (returnValue <span class="keyword">instanceof</span> ApiResult) {</span><br><span class="line">            <span class="built_in">this</span>.handler.handleReturnValue(returnValue,returnType,mavContainer,webRequest);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">nativeRequest</span> <span class="operator">=</span> webRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> nativeRequest != <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> nativeRequest.getMethod();</span><br><span class="line">        <span class="type">String</span> <span class="variable">servletPath</span> <span class="operator">=</span> nativeRequest.getServletPath();</span><br><span class="line">        <span class="type">String</span> <span class="variable">restfulPath</span> <span class="operator">=</span> method + <span class="string">":"</span> + servletPath;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isHandlerReturnValue</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">AntPathMatcher</span> <span class="variable">matcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AntPathMatcher</span>();</span><br><span class="line">        <span class="comment">// 判断api是否需要封装</span></span><br><span class="line">        <span class="keyword">for</span> (String s : Lists.newArrayList(<span class="string">"POST:/*"</span>)) {  <span class="comment">// 不需要封装的接口</span></span><br><span class="line">            <span class="keyword">if</span> (matcher.match(s, restfulPath)) {</span><br><span class="line">                isHandlerReturnValue = <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">this</span>.handler.handleReturnValue(</span><br><span class="line">                isHandlerReturnValue ? ApiResult.success(returnValue) : returnValue,</span><br><span class="line">                returnType, mavContainer, webRequest);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>一般不需要进行封装：</p>
<ul>
<li>回调地址</li>
<li>指定字符串</li>
</ul>
<p>配置 <code>MyHandlerMethodReturnValueHandler</code> 使之生效：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.method.support.HandlerMethodReturnValueHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReturnValueConfig</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> {</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RequestMappingHandlerAdapter requestMappingHandlerAdapter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        List&lt;HandlerMethodReturnValueHandler&gt; originHandlers = requestMappingHandlerAdapter.getReturnValueHandlers();</span><br><span class="line">        List&lt;HandlerMethodReturnValueHandler&gt; newHandlers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(originHandlers.size());</span><br><span class="line">        <span class="keyword">for</span> (HandlerMethodReturnValueHandler originHandler : originHandlers) {</span><br><span class="line">            <span class="keyword">if</span> (originHandler <span class="keyword">instanceof</span> RequestResponseBodyMethodProcessor) {</span><br><span class="line">                newHandlers.add(<span class="keyword">new</span> <span class="title class_">MyHandlerMethodReturnValueHandler</span>(originHandler));</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                newHandlers.add(originHandler);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        requestMappingHandlerAdapter.setReturnValueHandlers(newHandlers);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/360175994">Spring Boot 中如何统一 API 接口响应格式？</a></li>
<li><a href="https://juejin.cn/post/7127448265146138660">SpringBoot：如何优雅地进行响应数据封装、异常处理？</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>ThreadPoolExecutor源码分析</title>
    <url>/2024/07/13/ThreadPoolExecutor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>最近看到了个比较有意思的面试题：线程池执行任务的时候，不显示的进行异常捕获，任务执行遇到异常会怎么样？线程会崩溃吗？</p>
</blockquote>
<p>看到这两个问题我看到的时候就发现自己遇到了知识盲区，不读源码我觉得是搞不明白的🤨，因此本文以此问题为切入点来读读<code>ThreadPoolExecutor</code>的核心源代码</p>
<h1 id="1-Executor-体系"><a href="#1-Executor-体系" class="headerlink" title="1 Executor 体系"></a>1 Executor 体系</h1><p><img src="/../images/ThreadPoolExecutor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image_oHB0igmhIc.png"></p>
<h2 id="1-1-ExecutorService"><a href="#1-1-ExecutorService" class="headerlink" title="1.1 ExecutorService"></a>1.1 ExecutorService</h2><p><code>ExecutorService</code>提供了线程池的顶级抽象，以下是它的核心方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Executor</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ExecutorService</span> <span class="keyword">extends</span> <span class="title class_">Executor</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻止提交任务，在所有线程执行完后结束</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用shutdownNow()后触发，线程池不再接受新的任务，尝试终止所有正在执行的任务</span></span><br><span class="line">    List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span>; </span><br><span class="line">    </span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line">    </span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line">    </span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="1-2-ThreadPoolExecutor"><a href="#1-2-ThreadPoolExecutor" class="headerlink" title="1.2 ThreadPoolExecutor"></a>1.2 ThreadPoolExecutor</h2><p><code>ThreadPoolExecutor</code>对<code>ExecutorService</code>的方法做了实现。我们从源码分析一下线程池的任务执行流程：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 这个变量很巧妙，同时存放了线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span> {</span><br><span class="line">    <span class="keyword">return</span> c &amp; CAPACITY;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> {</span><br><span class="line">    <span class="comment">// 如果任务为null，则抛出异常。</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 当前线程数量 &lt; corePoolSize </span></span><br><span class="line">    <span class="comment">// 通过addWorker(command, true)新建一个线程，将任务添加到该线程中并执行</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) {</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 2. 当前线程数量 &gt; corePoolSize </span></span><br><span class="line">    <span class="comment">// 尝试将任务加入队列，如果工作队列未满则加入成功</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 再次获取线程池状态，如果不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span></span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">            <span class="comment">// 如果当前工作线程数量为0，新创建一个线程并执行。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 3.队列已满后尝试添加worker</span></span><br><span class="line">    <span class="comment">// 注意这里是先执行addWorker再判断，如果addWorker返回false（意味着当前线程数超过max）才会走拒绝策略 </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">        <span class="comment">// 4.队列已满且无法添加线程将会拒绝</span></span><br><span class="line">        reject(command);  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>addWorker()</code>能够添加新的工作线程到线程池，其中<code>largestPoolSize</code>（线程池最大大小）和<code>workers</code>（工作线程集合）都属于临界资源，会有多线程竞争问题，因此通过全局锁来进行互斥；而<code>ctl</code>（工作线程数量）则是通过CAS去保证线程安全的。以下是内部实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 全局锁，并发操作必备</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">// 跟踪线程池的最大大小，只有在持有全局锁mainLock的前提下才能访问此集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> largestPoolSize;</span><br><span class="line"><span class="comment">// 工作线程集合，存放线程池中所有的（活跃的）工作线程，只有在持有全局锁mainLock的前提下才能访问此集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//获取线程池状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStateOf</span><span class="params">(<span class="type">int</span> c)</span>     { <span class="keyword">return</span> c &amp; ~CAPACITY; }</span><br><span class="line"><span class="comment">//判断线程池的状态是否为 Running</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isRunning</span><span class="params">(<span class="type">int</span> c)</span> {</span><br><span class="line">    <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加新的工作线程到线程池</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> firstTask 要执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> core参数为true的话表示使用线程池的基本大小，为false使用线程池最大大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 添加成功就返回true否则返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> {</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="comment">//这两句用来获取线程池的状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">           <span class="comment">//获取线程池中工作的线程的数量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">            <span class="comment">// core参数为false的话表明队列也满了，线程池大小变为 maximumPoolSize</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           <span class="comment">//原子操作将workcount的数量加1</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">// 如果线程的状态改变了就再次执行上述操作</span></span><br><span class="line">            c = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 标记工作线程是否启动成功</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 标记工作线程是否创建成功</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line"></span><br><span class="line">        w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) {</span><br><span class="line">          <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">               <span class="comment">//获取线程池状态</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());</span><br><span class="line">               <span class="comment">//rs &lt; SHUTDOWN 如果线程池状态依然为RUNNING,并且线程的状态是存活的话，就会将工作线程添加到工作线程集合中</span></span><br><span class="line">              <span class="comment">//(rs=SHUTDOWN &amp;&amp; firstTask == null)如果线程池状态小于STOP，也就是RUNNING或者SHUTDOWN状态下，同时传入的任务实例firstTask为null，则需要添加到工作线程集合和启动新的Worker</span></span><br><span class="line">               <span class="comment">// firstTask == null证明只新建线程而不执行任务</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) {</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                   <span class="comment">//更新当前工作线程的最大容量</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                  <span class="comment">// 工作线程是否启动成功</span></span><br><span class="line">                    workerAdded = <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                <span class="comment">// 释放锁</span></span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//// 如果成功添加工作线程，则调用Worker内部的线程实例t的Thread#start()方法启动真实的线程实例</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) {</span><br><span class="line">                t.start();</span><br><span class="line">              <span class="comment">/// 标记线程启动成功</span></span><br><span class="line">                workerStarted = <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">       <span class="comment">// 线程启动失败，需要从工作线程中移除对应的Worker</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>以上就是线程池实现的原理，核心代码就在这两个方法中</p>
<h2 id="1-3-拓展面试题"><a href="#1-3-拓展面试题" class="headerlink" title="1.3 拓展面试题"></a>1.3 拓展面试题</h2><p>了解了上面的核心原理，现在就可以回答最开始的面试题了：</p>
<h3 id="1-3-1-不显示的进行异常捕获，任务执行遇到异常会怎么样？"><a href="#1-3-1-不显示的进行异常捕获，任务执行遇到异常会怎么样？" class="headerlink" title="1.3.1 不显示的进行异常捕获，任务执行遇到异常会怎么样？"></a>1.3.1 不显示的进行异常捕获，任务执行遇到异常会怎么样？</h3><p>具体的结果其实跟任务提交方式有关。ExecutorService提供了两种任务提交的方式：<code>execute()</code>和<code>submit()</code>。上面已经介绍过了<code>execute()</code>，我们再来看看<code>submit()</code>方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) {</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="literal">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// FutureTask</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTask</span>&lt;V&gt; <span class="keyword">implements</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; {</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">      <span class="keyword">if</span> (state != NEW || !UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, runnerOffset,</span><br><span class="line">                                       <span class="literal">null</span>, Thread.currentThread()))</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">try</span> {</span><br><span class="line">          Callable&lt;V&gt; c = callable;</span><br><span class="line">          <span class="comment">// 1、状态检查</span></span><br><span class="line">          <span class="keyword">if</span> (c != <span class="literal">null</span> &amp;&amp; state == NEW) {</span><br><span class="line">              V result;</span><br><span class="line">              <span class="type">boolean</span> ran;</span><br><span class="line">              <span class="keyword">try</span> {</span><br><span class="line">                  <span class="comment">// 2、调用包装前的实际方法执行并获取返回值</span></span><br><span class="line">                  result = c.call();</span><br><span class="line">                  ran = <span class="literal">true</span>;</span><br><span class="line">              } <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">                  <span class="comment">// 3、如果执行失败，则保存异常信息</span></span><br><span class="line">                  result = <span class="literal">null</span>;</span><br><span class="line">                  ran = <span class="literal">false</span>;</span><br><span class="line">                  setException(ex);</span><br><span class="line">              }</span><br><span class="line">              <span class="comment">// 4、如果执行成功，则将返回值保存起来</span></span><br><span class="line">              <span class="keyword">if</span> (ran)</span><br><span class="line">                  set(result);</span><br><span class="line">          }</span><br><span class="line">      } <span class="keyword">finally</span> {</span><br><span class="line">          runner = <span class="literal">null</span>;</span><br><span class="line">          <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">          <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">              handlePossibleCancellationInterrupt(s);</span><br><span class="line">      }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>可以看到<code>submit()</code>将任务封装成了<code>RunnableFuture</code>（无论是Runnable还是Callable），但本质上还是执行了<code>execute()</code></p>
<p>因此两者最根本的区别在<code>RunnableFuture.run()</code>方法里，FutureTask会捕获线程执行的异常并保存失败信息，因此如果遇到线程执行异常，执行<code>submit()</code>任务的线程不会崩溃退出，并能通过<code>get()</code>获取到异常信息，如果不get就啥也不会发生，而<code>execute()</code>内部是没有进行异常捕获的，因此会让线程崩溃</p>
<h3 id="1-3-2-为什么队列满了再进行创建普通线程执行任务？"><a href="#1-3-2-为什么队列满了再进行创建普通线程执行任务？" class="headerlink" title="1.3.2 为什么队列满了再进行创建普通线程执行任务？"></a>1.3.2 为什么队列满了再进行创建普通线程执行任务？</h3><p>普通线程有一个别名，叫急救线程，意在面临工作队列溢出的情况下帮助处理任务。他们就相当于厂里的临时工，只有在正式员工（核心线程）忙不过来且仓库（工作队列）没空间的时候才会用到，因此这样设计的好处是节约系统的资源，创建线程需要获取全局锁，开销较大；而放入队列开销相对较低</p>
<p>但是像 Tomcat 线程池的做法是，遇到超量的任务，先创建普通线程，普通线程不够了再往队列里丢 ，这样做的原因是Tomcat 面临大量网络I/O请求、短连接，放入队列意味着用户需要一直等待，用户肯定不乐意，本着物尽其用的道理，谁也别想闲着。</p>
<h3 id="1-3-3-Tomcat线程池是如何做的"><a href="#1-3-3-Tomcat线程池是如何做的" class="headerlink" title="1.3.3 Tomcat线程池是如何做的?"></a>1.3.3 Tomcat线程池是如何做的?</h3><p>简单的说</p>
<ol>
<li>新线程池继承JDK线程池接口，重写了<code>execute()</code>方法：当抛出拒绝策略了再给一次机会，尝试往阻塞队列里插任务，尽最大努力的去执行任务 <em>(意思是不抛弃不放弃，免得用户请求失败)</em></li>
<li>新阻塞队列继承了LinkedBlockingQueue，重写了<code>offer()</code>方法：每次向队列插入任务，判断如果当前线程数小于最大线程数则插入失败。进而逼线程池创建新线程来处理任务 <em>(意思你别想偷懒，把任务丢到队列就不管了)</em></li>
</ol>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/Hellowenpan/article/details/119991280" title="ThreadPoolExecutor线程池execute和submit的区别">ThreadPoolExecutor线程池execute和submit的区别</a></li>
<li><a href="https://javaguide.cn/java/concurrent/java-thread-pool-summary.html#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-%E9%87%8D%E8%A6%81" title="JavaGuide | Java 线程池详解">JavaGuide | Java 线程池详解</a></li>
<li><a href="https://www.cnblogs.com/ttaall/p/15220042.html" title="浅聊Tomcat线程池">浅聊Tomcat线程池</a></li>
</ul>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>线程池</tag>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池在业务中的实践以及对应参数如何设计</title>
    <url>/2024/02/03/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9C%A8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5%E4%BB%A5%E5%8F%8A%E5%AF%B9%E5%BA%94%E5%8F%82%E6%95%B0%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<blockquote>
<p>参考：</p>
<p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">Java线程池实现原理及其在美团业务中的实践 - 美团技术团队</a></p>
</blockquote>
<h1 id="线程池核心参数"><a href="#线程池核心参数" class="headerlink" title="线程池核心参数"></a>线程池核心参数</h1><ol>
<li>核心线程数<code>corePoolSize</code><br>如果项目有固定的线程开销可以使用核心线程</li>
<li>最大线程<code>maximumPoolSize</code><br>如果项目中多线程的场景不是很多，将线程池中的线程全部设置为普通线程，用完后就释放，减少资源占用</li>
<li>工作队列<code>workQueue</code><br>指定有界或无界队列，队列长度，一般我们选择有界队列，无界队列容易导致OOM</li>
</ol>
<span id="more"></span>

<h3 id="场景一：快速响应用户请求"><a href="#场景一：快速响应用户请求" class="headerlink" title="场景一：快速响应用户请求"></a>场景一：快速响应用户请求</h3><p>场景：需要快速响应的场景，如<strong>首屏加载</strong>、商品详情页加载这种越快越好的场景</p>
<p><strong>应该不设置队列去缓冲并发任务，而是调高<code>corePoolSize</code>和<code>maxPoolSize</code>去尽可能创造多的线程快速执行任务。</strong></p>
<p><img src="/../images/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9C%A8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5%E4%BB%A5%E5%8F%8A%E5%AF%B9%E5%BA%94%E5%8F%82%E6%95%B0%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1/image_dAKT_1wRJI.png"></p>
<h3 id="场景2：快速处理批量任务"><a href="#场景2：快速处理批量任务" class="headerlink" title="场景2：快速处理批量任务"></a>场景2：快速处理批量任务</h3><p><strong>描述</strong>：离线的大量计算任务，需要快速执行。比如说，统计某个报表，需要计算出全国各个门店中有哪些商品有某种属性，用于后续营销策略的分析，那么我们需要查询全国所有门店中的所有商品，并且记录具有某属性的商品，然后快速生成报表。</p>
<p><strong>分析</strong>：这种场景需要执行大量的任务，我们也会希望任务执行的越快越好。这种情况下，也应该使用多线程策略，并行计算。但与响应速度优先的场景区别在于，<strong>这类场景任务量巨大，并不需要瞬时的完成，而是关注如何使用有限的资源，尽可能在单位时间内处理更多的任务，也就是吞吐量优先的问题。</strong>所以<strong>应该设置队列去缓冲并发任务，调整合适的corePoolSize去设置处理任务的线程数</strong>。<strong>在这里，设置的线程数过多可能还会引发线程上下文切换频繁的问题，也会降低处理任务的速度，降低吞吐量。</strong></p>
<p><img src="/../images/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9C%A8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5%E4%BB%A5%E5%8F%8A%E5%AF%B9%E5%BA%94%E5%8F%82%E6%95%B0%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1/image_uK86I9zjp7.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>考虑到在实际应用中我们获取并发性的场景主要是两种：</p>
<ol>
<li>并行执行子任务，提高响应速度。这种情况下，应该使用同步队列，没有什么任务应该被缓存下来，而是应该立即执行</li>
<li>并行执行大批次任务，提升吞吐量。这种情况下，应该使用有界队列，使用队列去缓冲大批量的任务，队列容量必须声明，防止任务无限制堆积。所以线程池只需要提供这三个关键参数的配置，并且提供两种队列的选择，就可以满足绝大多数的业务需求，Less is More</li>
</ol>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>《深度学习进阶：自然语言处理》阅读笔记</title>
    <url>/2024/04/08/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="1-神经网络"><a href="#1-神经网络" class="headerlink" title="1 神经网络"></a>1 神经网络</h1><h2 id="1-1-向量"><a href="#1-1-向量" class="headerlink" title="1.1 向量"></a>1.1 向量</h2><p>向量内积和矩阵乘积：</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_1bqyqcgBZu.png"></p>
<span id="more"></span>

<h2 id="1-2-激活函数"><a href="#1-2-激活函数" class="headerlink" title="1.2 激活函数"></a>1.2 激活函数</h2><h3 id="1-2-1-sigmoid"><a href="#1-2-1-sigmoid" class="headerlink" title="1.2.1 sigmoid"></a>1.2.1 sigmoid</h3><p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_9HSiif9JfV.png"></p>
<h3 id="1-2-2-tanh"><a href="#1-2-2-tanh" class="headerlink" title="1.2.2 tanh"></a>1.2.2 tanh</h3><p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_QIEQOJAnOF.png"></p>
<h2 id="1-3-Softmax"><a href="#1-3-Softmax" class="headerlink" title="1.3 Softmax"></a>1.3 Softmax</h2><p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_N3Vili_wTq.png"></p>
<p>作用：将输出转化为概率和为1的概率分布（概率标准化</p>
<p>交叉熵误差</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_zZKfBVcMoO.png"></p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_Chw1F7Akcw.png"></p>
<p>链式法则</p>
<p>链式法则的重要之处在于，无论我们要处理的函数有多复杂（无论复合了多少个函数），都可以根据它们各自的导数来求复合函数的导数。</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_haS6PoUyjG.png" alt="计算图" title="计算图"></p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_UXq-rgO7SR.png"></p>
<h2 id="1-4-反向传播"><a href="#1-4-反向传播" class="headerlink" title="1.4 反向传播"></a>1.4 反向传播</h2><p>公式</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_3Nd6MpmQmw.png"></p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_Y-jRNJkCgn.png"></p>
<blockquote>
<p>本书将矩阵乘积称为 MatMul（Matrix Multiply）节点。</p>
</blockquote>
<p>代码</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_ikLUqD3eNu.png"></p>
<p>链式法则：复合函数的导数可以根据各个简单函数的导数来求。</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_FjE1dwS714.png"></p>
<h3 id="1-4-1-Softmax-with-Loss-层"><a href="#1-4-1-Softmax-with-Loss-层" class="headerlink" title="1.4.1 Softmax with Loss 层"></a>1.4.1 Softmax with Loss 层</h3><p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_oi4iYIorJU.png"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Softmax with Loss</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SoftmaxWithLoss</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.parame = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, t</span>):</span><br><span class="line">        <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">        <span class="variable language_">self</span>.t = t</span><br><span class="line">        <span class="variable language_">self</span>.y = np.exp(x) / np.<span class="built_in">sum</span>(np.exp(x))</span><br><span class="line">        <span class="variable language_">self</span>.loss = -np.<span class="built_in">sum</span>(t * np.log(<span class="variable language_">self</span>.y))</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.loss</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">        dx = <span class="variable language_">self</span>.y - <span class="variable language_">self</span>.t</span><br><span class="line">        <span class="keyword">return</span> dx</span><br></pre></td></tr></tbody></table></figure>

<h2 id="1-5-梯度下降"><a href="#1-5-梯度下降" class="headerlink" title="1.5 梯度下降"></a>1.5 梯度下降</h2><p>随机梯度下降法</p>
<p>梯度下降：在训练过程中，反向传播将不断更新权重的梯度，让损失不断降低</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_39HQB-HZlV.png"></p>
<p>首先，选择 mini-batch 数据，根据误差反向传播法获得权重的梯度。这个梯度指向当前的权重参数所处位置中损失增加最多的方向。因此，通过将参数向该梯度的反方向更新，可以降低损失。这就是梯度下降法</p>
<p>权重更新方法：</p>
<ul>
<li><p>随机梯度下降法 SGD</p>
<ul>
<li>“随机”是指使用随机选择的数据（mini-batch）的梯度。<br><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_hqK0eTi6_4.png"></li>
</ul>
<p>η 表示学习率</p>
</li>
<li><p>批量梯度下降算法BGD</p>
</li>
<li><p>小批量 梯度下降算法MBGD</p>
</li>
</ul>
<h2 id="1-6-单层感知机"><a href="#1-6-单层感知机" class="headerlink" title="1.6 单层感知机"></a>1.6 单层感知机</h2><p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_oiKZuVifVq.png"></p>
<p>单层感知器属于单层前向网络，<strong>即除输入层和输出层之外，只拥有一层神经元节点</strong>。前向网络的特点是，输入数据从输入层经过隐藏层向输出层逐层传播，相邻两层的神经元之间相互连接， 同一层的神经元之间则没有连接。</p>
<h1 id="2-自然语言处理"><a href="#2-自然语言处理" class="headerlink" title="2 自然语言处理"></a>2 自然语言处理</h1><p>要想让计算机理解自然语言的前提就是让其理解每个单词的含义。我们主要有3种方法实现：</p>
<ul>
<li>基于同义词词典的方法<ul>
<li><strong>WordNet</strong></li>
</ul>
</li>
<li>基于计数的方法</li>
<li>基于推理的方法（word2vec）</li>
</ul>
<h2 id="单词的分布式表示"><a href="#单词的分布式表示" class="headerlink" title="单词的分布式表示"></a><strong>单词的分布式表示</strong></h2><p>我们能不能将类似于颜色RGB表示方法运用到单词上呢？在单词领域构建紧凑合理的向量表示，在自然语言处理领域，这称为<strong>分布式表示</strong>。单词的分布式表示将单词表示为固定长度的向量。这种向量的特征在于它是用密集向量表示的。</p>
<p><strong>密集向量</strong>：向量的各个元素（大多数）是由非 0 实数表示的。例如三维分布式表示是$[0.21,-0.45,0.83]$</p>
<p><strong>分布式假设</strong>：“某个单词的含义由它周围的单词形成”，称为<strong>分布式假设</strong>。</p>
<h2 id="2-2-基于计数的方法"><a href="#2-2-基于计数的方法" class="headerlink" title="2.2 基于计数的方法"></a>2.2 基于计数的方法</h2><p>基于计数的方法根据一个单词周围的单词的出现频数来表示该单词。具体来说，先生成所有单词的共现矩阵，再对这个矩阵进行SVD，以获得密集向量（单词的分布式表示）。但是，基于计数的方法在处理大规模语料库时会出现问题。</p>
<blockquote>
<p>奇异值分解（Singular Value Decomposition，SVD）是矩阵分解的一种方法，将一个矩阵分解为三个矩阵的乘积：$M = U \Sigma V^T$，其中 $U$ 和 $V$是正交矩阵，$\Sigma$是对角矩阵，包含奇异值。</p>
</blockquote>
<p>通过SVD，可以将原始高维稀疏矩阵压缩为低维稠密矩阵。这些低维矩阵的行向量或列向量就可以作为单词的向量表示。</p>
<p>SVD的作用：降维、去噪、稠密表示等</p>
<p>缺点：计算量太大导致计算机难以处理</p>
<h3 id="语料库的预处理"><a href="#语料库的预处理" class="headerlink" title="语料库的预处理"></a><strong>语料库的预处理</strong></h3><p>现在，我们对一个非常小的文本数据（语料库）进行预处理。这里所说的预处理是指：</p>
<ol>
<li>将文本分割成单词</li>
<li>单词列表转化为单词ID列表</li>
</ol>
<h3 id="2-2-2-共现矩阵"><a href="#2-2-2-共现矩阵" class="headerlink" title="2.2.2 共现矩阵"></a>2.2.2 共现矩阵</h3><p>用表格表示单词的上下文中包含的单词的频数，作为单词的向量表示</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_4rUGq7V2am.png"></p>
<p>对一个句子中所有的单词进行处理，就可以得到如下的共现矩阵：</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_6Te4nILf4k.png"></p>
<h3 id="2-2-3-余弦相似度（cosine-similarity）"><a href="#2-2-3-余弦相似度（cosine-similarity）" class="headerlink" title="2.2.3 余弦相似度（cosine similarity）"></a>2.2.3 余弦相似度（cosine similarity）</h3><p>在测量单词的向量表示的相似度方面，余弦相似度是很常用的。</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_K3SNNXUSNA.png"></p>
<h3 id="2-2-4-点互信息"><a href="#2-2-4-点互信息" class="headerlink" title="2.2.4 点互信息"></a>2.2.4 点互信息</h3><p>共现矩阵的元素表示两个单词同时出现的次数。但是，这种“原始”的次数并不具备好的性质。</p>
<p>比如“the car…”这样的短语，它们的共现次数将会很大。另外，car 和 drive 也明显有很强的相关性。但是，如果只看单词的出现次数，那么与 drive 相比，the 和 car 的相关性更强。这意味着，仅仅因为 the 是个常用词，它就被认为与 car 有很强的相关性，这显然不是我们想要的。</p>
<p>点互信息被用于解决这一问题：</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_VLIsIt84wg.png"></p>
<p>其中，P(x) 表示 x 发生的概率，P(y) 表示 y 发生的概率，P(x, y) 表示 x 和 y 同时发生的概率。PMI 的值越高，表明相关性越强。</p>
<h4 id="2-2-4-1-正的点互信息"><a href="#2-2-4-1-正的点互信息" class="headerlink" title="2.2.4.1 正的点互信息"></a>2.2.4.1 正的点互信息</h4><p>解决当两个单词的共现次数为 0 时，log20 = −∞。</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_mvK3ZF2ygS.png"></p>
<p>尽管PPMI矩阵能够改善之前共现矩阵存在的高频词汇问题，但是这两种方法都存在一个共性问题：<strong>随着单词数目的增加，矩阵的维数也在增加，而其中很多元素都为0(不重要的元素)；向量容易受到噪声的影响，稳定性差。</strong></p>
<hr>
<p>基于计数的方法使用整个语料库的统计数据（共现矩阵和 PPMI 等 ），通过一次处理（SVD 等）获得单词的分布式表示。而基于推理的方法使用神经网络，通常在 mini-batch 数据上进行学习。这意味着神经网络一次只需要看一部分学习数据（mini-batch），并反复更新权重。这种学习机制上的差异如图 3-1 所示。</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_hUDNVonnr_.png"></p>
<h2 id="2-3-基于推理的方法"><a href="#2-3-基于推理的方法" class="headerlink" title="2.3 基于推理的方法"></a>2.3 基于推理的方法</h2><p>基于推理的方法的主要操作是“推理”。当给出周围的单词（上下文）时，预测“？”处会出现什么单词，这就是推理。</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_9BpxVzfK51.png"></p>
<h3 id="2-3-1-word2vec"><a href="#2-3-1-word2vec" class="headerlink" title="2.3.1 word2vec"></a>2.3.1 word2vec</h3><p>word2vec 一词最初用来指程序或者工具，但是随着该词的流行，在某些语境下，也指神经网络的模型。</p>
<p>word2vec 中使用的两个神经网络分别是CBOW 模型和 skip-gram 模型</p>
<h4 id="2-3-1-1-CBOW-模型"><a href="#2-3-1-1-CBOW-模型" class="headerlink" title="2.3.1.1 CBOW 模型"></a>2.3.1.1 CBOW 模型</h4><p>continuous bag-of-words（CBOW）连续词袋模型</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_tDuQKVJFk5.png"></p>
<blockquote>
<p>中间层的神经元数量比输入层少这一点很重要。中间层需要将预测单词所需的信息压缩保存，从而产生密集的向量表示。这时，中间层被写入了我们人类无法解读的代码，这相当于“编码”工作。而从中间层的信息获得期望结果的过程则称为“解码”。这一过程将被编码的信息复原为我们可以理解的形式。</p>
</blockquote>
<hr>
<h5 id="2-3-1-1-1-CBOW模型的学习"><a href="#2-3-1-1-1-CBOW模型的学习" class="headerlink" title="2.3.1.1.1 CBOW模型的学习"></a>2.3.1.1.1 CBOW模型的学习</h5><p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_qsAFx46tbi.png"></p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_IJZAZJ2j13.png"></p>
<p>CBOW模型只是学习语料库中单词的出现模式。如果语料库不一样，学习到的单词的分布式表示也不一样。比如，只使用“体育”相关的文章得到的单词的分布式表示，和只使用“音乐”相关的文章得到的单词的分布式表示将有很大不同。</p>
<h5 id="2-3-1-1-2-CBOW损失函数"><a href="#2-3-1-1-2-CBOW损失函数" class="headerlink" title="2.3.1.1.2 CBOW损失函数"></a>2.3.1.1.2 CBOW损失函数</h5><p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_8RkALBaVVW.png"></p>
<p>CBOW 模型学习的任务就是让损失函数尽可能地小。那时的权重参数就是我们想要的单词的分布式表示。</p>
<h4 id="2-3-1-2-word2vec的权重和分布式表示"><a href="#2-3-1-2-word2vec的权重和分布式表示" class="headerlink" title="2.3.1.2 word2vec的权重和分布式表示"></a>2.3.1.2 word2vec的权重和分布式表示</h4><p>word2vec 中使用的网络有两个权重，分别是输入侧的全连接层的权重（$W_{in} $）和输出侧的全连接层的权重（$W_{out} $）。</p>
<p>就 word2vec（特别是 skip-gram 模型）而言，最受欢迎的是只使用输入侧的权重。</p>
<h3 id="2-3-2-skip-gram模型"><a href="#2-3-2-skip-gram模型" class="headerlink" title="2.3.2 skip-gram模型"></a>2.3.2 skip-gram模型</h3><p>skip-gram 是反转了 CBOW 模型处理的上下文和目标词的模型。</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_NWBJQnGsQh.png"></p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_Nx1lhLuzli.png"></p>
<h1 id="3-word2vec的高速化"><a href="#3-word2vec的高速化" class="headerlink" title="3 word2vec的高速化"></a>3 word2vec的高速化</h1><p>TODO</p>
<h1 id="4-RNN"><a href="#4-RNN" class="headerlink" title="4 RNN"></a>4 RNN</h1><blockquote>
<p>前馈神经网络FNN：最简单的网络，各神经元分层排列，每个神经元只与前一层的神经元相连。接收前一层的输出，并输出给下一层，各层间没有反馈</p>
</blockquote>
<p>到目前为止，我们看到的神经网络都是前馈型神经网络。虽然前馈网络结构简单、易于理解，但是可以应用于许多任务中。不过，这种网络存在一个大问题，就是不能很好地处理时间序列数据。更确切地说，单纯的前馈网络无法充分学习时序数据的性质。于是，RNN（Recurrent Neural Network，循环神经网络）便应运而生。</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_SlgtJLs9XQ.png"></p>
<p>RNN 的特征就在于拥有这样一个环路。这个环路可以使数据不断循环。通过数据的循环，RNN 一边记住过去的数据，一边更新到最新的数据。</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_OYNUHRviQU.png"></p>
<p>RNN 有两个权重，分别是将输入 x 转化为输出 h 的权重$  W_{x}  $和将前一个 RNN 层的输出转化为当前时刻的输出的权重 $W_{h}$。</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_N7X68U_dRV.png" alt="RNN三维表现" title="RNN三维表现"></p>
<p>$$<br>\boldsymbol{h}<em>{t}=\tanh \left(\boldsymbol{h}</em>{t-1} \boldsymbol{W}<em>{h}+\boldsymbol{x}</em>{t} \boldsymbol{W}_{x}+\boldsymbol{b}\right)<br>$$</p>
<p>从另一个角度看，这可以解释为，RNN 具有“状态”$h$，并以上式的形式被更新。这就是说RNN层是“具有状态的层”或“具有存储（记忆）的层”的原因。RNN 的输出 $h_{t}$称为<strong>隐藏状态</strong>或<strong>隐藏状态向量</strong></p>
<p>RNN有两个权重：$W_{h}$和$W_{x}$</p>
<h2 id="4-1-Backpropagation-Through-Time"><a href="#4-1-Backpropagation-Through-Time" class="headerlink" title="4.1 Backpropagation Through Time"></a>4.1 Backpropagation Through Time</h2><p>RNN的误差反向传播法是“按时间顺序展开的神经网络的误差反向传播法”，所以称为 Backpropagation Through Time（基于时间的反向传播），简称 BPTT。</p>
<h3 id="4-1-1-Truncated-BPTT"><a href="#4-1-1-Truncated-BPTT" class="headerlink" title="4.1.1 Truncated BPTT"></a>4.1.1 Truncated BPTT</h3><p>在处理长时序数据时，通常的做法是将网络连接截成适当的长度。具体来说，就是将时间轴方向上过长的网络在合适的位置进行截断，从而创建多个小型网络，然后对截出来的小型网络执行误差反向传播法，这个方法称为 Truncated BPTT（截断的 BPTT）。 </p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_elYrdSfgP7.png"></p>
<p>这里需要注意的是，虽然反向传播的连接会被截断，但是正向传播的连接不会。</p>
<h2 id="4-2-RNN反向传播"><a href="#4-2-RNN反向传播" class="headerlink" title="4.2 RNN反向传播"></a>4.2 RNN反向传播</h2><p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_0FJeCOAdIc.png" alt="RNN正向传播" title="RNN正向传播"></p>
<hr>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_U92MnE7C6K.png" alt="RNN反向传播" title="RNN反向传播"></p>
<h2 id="4-3-RNNLM"><a href="#4-3-RNNLM" class="headerlink" title="4.3  RNNLM"></a>4.3  RNNLM</h2><p>基于 RNN 的语言模型称为 RNNLM（RNN Language Model，RNN 语言模型）</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_CkpsNamznS.png"></p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_tfhaOlgpid.png"></p>
<p> Embedding 层：将单词 ID 转化为单词的分布式表示（单词向量）</p>
<h3 id="4-3-1-梯度消失和梯度爆炸"><a href="#4-3-1-梯度消失和梯度爆炸" class="headerlink" title="4.3.1 梯度消失和梯度爆炸"></a>4.3.1 梯度消失和梯度爆炸</h3><blockquote>
<p>RNN 层通过向过去传递“有意义的梯度”，能够学习时间方向上的依赖关系。此时梯度（理论上）包含了那些应该学到的有意义的信息，通过将这些信息向过去传递，RNN 层学习长期的依赖关系。但是，如果这个梯度在中途变弱（甚至没有包含任何信息），则权重参数将不会被更新。也就是说，RNN 层无法学习长期的依赖关系。不幸的是，随着时间的回溯，这个简单 RNN 未能避免梯度变小（梯度消失）或者梯度变大（梯度爆炸）的命运。</p>
</blockquote>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_TXW0mkOOdJ.png"></p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_Susys1EeV1.png"></p>
<p>当反向传播的梯度经过tanh 节点时，它的值会越来越小。因此，如果经过 tanh 函数 T 次，则梯度也会减小 T 次。</p>
<blockquote>
<p>RNN 层的激活函数一般使用 tanh 函数，但是如果改为 ReLU 函数，则有希望抑制梯度消失的问题（当 ReLU 的输入为 x 时，它的输出是max(0, x)）。这是因为，在 ReLU 的情况下，当 x 大于 0 时，反向传播将上游的梯度原样传递到下游，梯度不会“退化”。</p>
</blockquote>
<h2 id="4-4-Gated-RNN"><a href="#4-4-Gated-RNN" class="headerlink" title="4.4 Gated RNN"></a>4.4 Gated RNN</h2><p>上文提到的RNN 不擅长学习时序数据的长期依赖关系，原因是 BPTT 会发生梯度消失和梯度爆炸的问题。</p>
<p>当我们说 RNN 时，更多的是指 LSTM 层，而不是上一章的 RNN。</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_T4L3lbsK4w.png"></p>
<p>LSTM 与 RNN 的接口的不同之处在于，LSTM 还有路径 c。这个 c 称为记忆单元（或者简称为“单元”），相当于 LSTM 专用的记忆部门。</p>
<p>记忆单元的特点是，仅在 LSTM 层内部接收和传递数据。也就是说，记忆单元在 LSTM 层内部结束工作，不向其他层输出。而 LSTM 的隐藏状态 h 和 RNN 层相同，会被（向上）输出到其他层。</p>
<h2 id="4-5-LSTM"><a href="#4-5-LSTM" class="headerlink" title="4.5 LSTM"></a>4.5 LSTM</h2><h3 id="4-5-1-输出门"><a href="#4-5-1-输出门" class="headerlink" title="4.5.1 输出门"></a>4.5.1 输出门</h3><p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_SOAi8mJDjY.png"></p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_J8SXWBJc3n.png"></p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_kYPB-1QNDR.png"></p>
<blockquote>
<p>sigmoid 函数用 $σ()$ 表示</p>
</blockquote>
<blockquote>
<p>tanh的输出是−1.0 ~ 1.0的实数。我们可以认为这个−1.0 ~ 1.0的数值表示某种被编码的“信息”的强弱（程度）。而sigmoid 函数的输出是0.0~1.0的实数，表示数据流出的比例。因此，在大多数情况下，门使用sigmoid函数作为激活函数，而包含实质信息的数据则使用tanh函数作为激活函数。</p>
</blockquote>
<h3 id="4-5-2-遗忘门"><a href="#4-5-2-遗忘门" class="headerlink" title="4.5.2 遗忘门"></a>4.5.2 遗忘门</h3><p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_YIl0qmaVTK.png"></p>
<h3 id="4-5-3-新的记忆单元"><a href="#4-5-3-新的记忆单元" class="headerlink" title="4.5.3 新的记忆单元"></a>4.5.3 新的记忆单元</h3><p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_h4Nin6H2kA.png"></p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_J-HmVurGyH.png"></p>
<h3 id="4-5-4-输入门"><a href="#4-5-4-输入门" class="headerlink" title="4.5.4 输入门"></a>4.5.4 输入门</h3><p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_ThsOkpY5xe.png"></p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_soLXg37NZ1.png"></p>
<h3 id="4-5-5-LSTM的实现"><a href="#4-5-5-LSTM的实现" class="headerlink" title="4.5.5 LSTM的实现"></a>4.5.5 LSTM的实现</h3><p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_cQJVJXL5NX.png"></p>
<p>简化后：</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_N71KUQFLnj.png"></p>
<h1 id="5-Attention"><a href="#5-Attention" class="headerlink" title="5 Attention"></a>5 Attention</h1><h2 id="5-1-seq2seq改进"><a href="#5-1-seq2seq改进" class="headerlink" title="5.1 seq2seq改进"></a>5.1 seq2seq改进</h2><p>seq2seq存在的问题：无论输入语句多长，编码器都将其塞入固定长度的向量中，有用的信息也会从向量中溢出。</p>
<h3 id="5-1-1-编码器优化"><a href="#5-1-1-编码器优化" class="headerlink" title="5.1.1 编码器优化"></a>5.1.1 编码器优化</h3><p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_7o88_Ids4Y.png"></p>
<p>使用各个时刻（各个单词）的隐藏状态向量，可以获得和输入的单词数相同数量的向量。</p>
<p>编码器输出的 $h_{s}$ 矩阵就可以视为各个单词对应的向量集合。</p>
<p>这样一来，编码器就摆脱了“一个固定长度的向量”的制约。</p>
<h3 id="5-1-2-解码器的改进"><a href="#5-1-2-解码器的改进" class="headerlink" title="5.1.2 解码器的改进"></a>5.1.2 解码器的改进</h3><p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_bSlinKoTI_.png"></p>
<hr>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_HLsC5sqpbj.png"></p>
<p>网络所做的工作是提取单词对齐信息。具体来说，就是从 $h_{s}$ 中选出与各个时刻解码器输出的单词有对应关系的单词向量。但是“选择”这一操作是不可微分的，这里使用了单词重要度的权重$a$，计算$a$和$h_{s}$ 加权和可以获得目标向量：</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_q4blJe5wuo.png"></p>
<p>上下文向量 c 中包含了当前时刻进行变换（翻译）所需的信息。更确切地说，模型要从数据中学习出这种能力。 </p>
<hr>
<p><strong>如何获取</strong>$a$<strong>？</strong></p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_P7kOhf1xaa.png"></p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_onuLtYwAEz.png"></p>
<p> $h$ 表示解码器的 LSTM 层的隐藏状态向量，用$h$和$h_{s}$的内积表示这个 h 在多大程度上和 hs 的各个单词向量“相似”，并将其结果表示为 s，正则化后就得到了a</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_lSZYS8dvFC.png"></p>
<h3 id="5-1-3-Attention结构"><a href="#5-1-3-Attention结构" class="headerlink" title="5.1.3 Attention结构"></a>5.1.3 Attention结构</h3><p>总结：</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_XPq89glvv-.png"></p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_ZxHnftpiMc.png"></p>
<p>我们上面对seq2seq的优化实际就是加了一层Attention层：</p>
<p><img src="/../images/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%EF%BC%9A%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image_wE13ZakECp.png"></p>
<hr>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务理论体系</title>
    <url>/2023/02/08/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<h1 id="1-微服务发展历史"><a href="#1-微服务发展历史" class="headerlink" title="1 微服务发展历史"></a>1 微服务发展历史</h1><ul>
<li><p><em><strong>单体应用阶段</strong></em></p>
<p>早期互联网公司的架构：</p>
<ul>
<li>LAMP（Linux + Apache + MySQL + PHP）</li>
<li>MVC（Spring + iBatis/Hibernate + Tomcat）<br>特点：团队规模一般不超过5人</li>
</ul>
</li>
<li><p><em><strong>服务化思想</strong></em></p>
<p>把原来整个大的项目粗略分为不同的业务模块，拆分出来进行独立部署，并以RPC接口的形式对外提供服务。这样原来的模块就会由进程内调用变为远程RPC调用，也就可以独立开发、测试、上线和运维，甚至交给不同的团队去做。</p>
</li>
<li><p><em><strong>微服务阶段</strong></em></p>
<p>相比于服务化，微服务拆分粒度更细，服务之间更加独立，并且由于拆分后的服务更多，需要有一个同一个管理平台去维护，需要做服务监控、服务追踪、服务治理等去管理</p>
</li>
</ul>
<span id="more"></span>

<h2 id="1-1-服务发布和引用"><a href="#1-1-服务发布和引用" class="headerlink" title="1.1 服务发布和引用"></a>1.1 服务发布和引用</h2><blockquote>
<p>📌最常见的服务发布和引用的方式有三种：</p>
<ul>
<li>RESTful API</li>
<li>XML配置</li>
<li>IDL文件</li>
</ul>
</blockquote>
<h3 id="1-1-1-RESTful-API"><a href="#1-1-1-RESTful-API" class="headerlink" title="1.1.1 RESTful API"></a>1.1.1 RESTful API</h3><p>主要被<strong>用作HTTP或者HTTPS协议的接口定义</strong>，即使在非微服务架构体系下，也被广泛采用。</p>
<p>服务提供者和消费者间通过HTTP协议进行交互，适合需要向其他业务部分提供服务或者给外网提供服务的场景</p>
<h3 id="1-1-2-XML配置"><a href="#1-1-2-XML配置" class="headerlink" title="1.1.2 XML配置"></a>1.1.2 XML配置</h3><p>这种方式的服务发布和引用主要分三个步骤：</p>
<ul>
<li>服务提供者定义接口，并实现接口。</li>
<li>服务提供者进程启动时，通过加载server.xml配置文件将接口暴露出去。</li>
<li>服务消费者进程启动时，通过加载client.xml配置文件来引入要调用的接口。</li>
</ul>
<p>服务提供者和服务消费者之间维持一份对等的XML配置文件，来保证服务消费者按照服务提供者的约定来进行服务调用。在这种方式下，如果服务提供者变更了接口定义，不仅需要更新server.xml，还需要同时更新client.xml。</p>
<p>适用场景：</p>
<ul>
<li>私有RPC框架（性能要求高）</li>
<li>公司内部联系比较紧密的业务</li>
</ul>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context-2.5.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">motan:service</span> <span class="attr">ref</span>=<span class="string">"userLastStatusLocalService"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">requestTimeout</span>=<span class="string">"50"</span> <span class="attr">retries</span>=<span class="string">"2"</span>    <span class="attr">interface</span>=<span class="string">"com.weibo.api.common.status.service.UserLastStatusService"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">basicService</span>=<span class="string">"serviceBasicConfig"</span> <span class="attr">export</span>=<span class="string">"motan:8882"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">"getLastStatusId"</span> <span class="attr">requestTimeout</span>=<span class="string">"300"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">retries</span>=<span class="string">"0"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">"getLastStatusIds"</span> <span class="attr">requestTimeout</span>=<span class="string">"300"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">retries</span>=<span class="string">"0"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">motan:service</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="1-1-3-IDL文件"><a href="#1-1-3-IDL文件" class="headerlink" title="1.1.3 IDL文件"></a>1.1.3 IDL文件</h3><p>通过一种中立的方式来描述接口，使得在不同的平台上运行的对象和不同语言编写的程序可以相互通信交流。</p>
<p>有两种最常用的IDL：</p>
<ul>
<li>Facebook开源的<strong>Thrift协议</strong></li>
<li>Google开源的<strong>gRPC协议</strong>。</li>
</ul>
<h2 id="1-2-注册中心"><a href="#1-2-注册中心" class="headerlink" title="1.2 注册中心"></a>1.2 注册中心</h2><ul>
<li>服务注册</li>
<li>服务发现</li>
</ul>
<h3 id="1-2-1-注册中心原理"><a href="#1-2-1-注册中心原理" class="headerlink" title="1.2.1 注册中心原理"></a>1.2.1 注册中心原理</h3><p><img src="/../images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB/image_qRiIliPDtc.png"></p>
<ul>
<li>RPC Server提供服务，在启动时，根据服务发布文件server.xml中的配置的信息，向Registry注册自身服务，并向Registry定期发送心跳汇报存活状态。</li>
<li>RPC Client调用服务，在启动时，根据服务引用文件client.xml中配置的信息，向Registry订阅服务，把Registry返回的服务节点列表缓存在本地内存中，并与RPC Sever建立连接。</li>
<li>当RPC Server节点发生变更时，Registry会同步变更，RPC Client感知后会刷新本地内存中缓存的服务节点列表。</li>
<li>RPC Client从本地缓存的服务节点列表中，<strong>基于负载均衡算法</strong>选择一台RPC Sever发起调用。</li>
</ul>
<h3 id="1-2-2-注册中心实现方式"><a href="#1-2-2-注册中心实现方式" class="headerlink" title="1.2.2 注册中心实现方式"></a>1.2.2 注册中心实现方式</h3><h4 id="注册中心API"><a href="#注册中心API" class="headerlink" title="注册中心API"></a><strong>注册中心API</strong></h4><ul>
<li>服务注册接口：服务提供者通过调用服务注册接口来完成服务注册。</li>
<li>服务反注册接口：服务提供者通过调用服务反注册接口来完成服务注销。</li>
<li>心跳汇报接口：服务提供者通过调用心跳汇报接口完成节点存活状态上报。</li>
<li>服务订阅接口：服务消费者通过调用服务订阅接口完成服务订阅，获取可用的服务提供者节点列表。</li>
<li>服务变更查询接口：服务消费者通过调用服务变更查询接口，获取最新的可用服务节点列表。</li>
<li>服务查询接口：查询注册中心当前注册了哪些服务信息。</li>
<li>服务修改接口：修改注册中心中某一服务的信息。</li>
</ul>
<h4 id="1-2-2-2-集群部署"><a href="#1-2-2-2-集群部署" class="headerlink" title="1.2.2.2 集群部署"></a>1.2.2.2 集群部署</h4><p>注册中心作为服务提供者和服务消费者之间沟通的桥梁，它的重要性不言而喻。所以注册中心一般都是采用集群部署来保证高可用性，并通过分布式一致性协议来确保集群中不同节点之间的数据保持一致。</p>
<p>以ZooKeeper为例，ZooKeeper集群中包含多个节点，服务提供者和服务消费者可以同任意一个节点通信，因为它们的数据一定是相同的。ZooKeeper的工作原理：</p>
<p><img src="/../images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB/image_o-_tuXD8rn.png"></p>
<ul>
<li>每个Server在内存中存储了一份数据，Client的读请求可以请求任意一个Server</li>
<li>ZooKeeper启动时，将从实例中选举一个leader（Paxos协议）</li>
<li>Leader负责处理数据更新等操作（ZAB协议）</li>
<li>一个更新操作成功，当且仅当大多数Server在内存中成功修改 </li>
</ul>
<p>通过上面这种方式，ZooKeeper保证了<strong>高可用性</strong>以及<strong>数据一致性</strong></p>
<h4 id="目录存储"><a href="#目录存储" class="headerlink" title="目录存储"></a><strong>目录存储</strong></h4><p>还是以ZooKeeper为例，注册中心存储服务信息一般采用层次化的目录结构：</p>
<ul>
<li>每个目录在ZooKeeper中叫作znode，并且其有一个唯一的路径标识。</li>
<li>znode可以包含数据和子znode。</li>
<li>znode中的数据可以有多个版本，比如某一个znode下存有多个数据版本，那么查询这个路径下的数据需带上版本信息。</li>
</ul>
<p><img src="/../images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB/image_gn7reAdS58.png"></p>
<h4 id="服务健康状态检测"><a href="#服务健康状态检测" class="headerlink" title="服务健康状态检测"></a><strong>服务健康状态检测</strong></h4><p>一旦注册中心探测到有服务提供者节点新加入或者被剔除，就必须立刻通知所有订阅该服务的服务消费者，刷新本地缓存的服务节点信息，确保服务调用不会请求不可用的服务提供者节点。</p>
<p>继续以ZooKeeper为例，基于ZooKeeper的<strong>Watcher机制</strong>，来实现服务状态变更通知给服务消费者的。服务消费者在调用ZooKeeper的getData方法订阅服务时，还可以通过监听器Watcher的process方法获取服务的变更，然后调用getData方法来获取变更后的数据，刷新本地缓存的服务节点信息。</p>
<h4 id="1-2-2-5-白名单机制"><a href="#1-2-2-5-白名单机制" class="headerlink" title="1.2.2.5 白名单机制"></a>1.2.2.5 白名单机制</h4><p>在实际应用中，注册中心可以提供一个白名单机制，只有添加到注册中心白名单内的RPC Server，才能够调用注册中心的注册接口，这样的话可以避免测试环境中的节点意外跑到线上环境中去。</p>
<h2 id="1-3-RPC远程调用"><a href="#1-3-RPC远程调用" class="headerlink" title="1.3 RPC远程调用"></a>1.3 RPC远程调用</h2><blockquote>
<p>RPC协议的主要目的是做到不同服务间调用方法像同一服务间调用本地方法一样</p>
</blockquote>
<p>由服务提供者给出业务接口声明，在调用方的程序里面，RPC框架根据调用的服务接口提前生成动态代理实现类，并通过依赖注入等技术注入到声明了该接口的相关业务逻辑里面。该代理实现类会拦截所有的方法调用，在提供的方法处理逻辑里面完成一整套的远程调用，并把远程调用结果返回给调用方，这样调用方在调用远程方法的时候就获得了像调用本地接口一样的体验。</p>
<p><img src="/../images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB/image_cSeWjwsfhb.png"></p>
<p>要完成一次RPC调用，就必须先建立网络连接。建立连接后，双方还必须按照某种约定的协议进行网络通信，这个协议就是通信协议。双方能够正常通信后，服务端接收到请求时，需要以某种方式进行处理，处理成功后，把请求结果返回给客户端。为了减少传输的数据大小，还要对数据进行压缩，也就是对数据进行序列化。</p>
<h3 id="1-3-1-客户端和服务端如何建立网络连接？"><a href="#1-3-1-客户端和服务端如何建立网络连接？" class="headerlink" title="1.3.1 客户端和服务端如何建立网络连接？"></a>1.3.1 客户端和服务端如何建立网络连接？</h3><ol>
<li><p>HTTP通信</p>
</li>
<li><p>Socket通信</p>
<p>Socket通信是基于TCP/IP协议的封装，建立一次Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket；另一个运行于服务器端，称为ServerSocket。Socket通信的过程分为四个步骤：服务器监听、客户端请求、连接确认、数据传输。</p>
</li>
</ol>
<h3 id="1-3-2-服务端如何处理请求？"><a href="#1-3-2-服务端如何处理请求？" class="headerlink" title="1.3.2 服务端如何处理请求？"></a>1.3.2 服务端如何处理请求？</h3><p>三种处理方式：</p>
<ul>
<li><p>同步阻塞方式（BIO）：客户端每发一次请求，服务端就生成一个线程去处理。</p>
<p>适用于连接数比较小的业务场景，这样的话不至于系统中没有可用线程去处理请求。这种方式写的程序也比较简单直观，易于理解。</p>
</li>
<li><p>同步非阻塞方式 (NIO)：客户端每发一次请求，服务端并不是每次都创建一个新线程来处理，而是通过I/O多路复用技术进行处理。就是把多个I/O的阻塞复用到同一个select的阻塞上，从而使系统在单线程的情况下可以同时处理多个客户端请求。</p>
<p>适用于连接数比较多并且请求消耗比较轻的业务场景，比如聊天服务器。这种方式相比BIO，相对来说编程比较复杂。</p>
</li>
<li><p>异步非阻塞方式（AIO）：客户端只需要发起一个I/O操作然后立即返回，等I/O操作真正完成以后，客户端会得到I/O操作完成的通知，此时客户端只需要对数据进行处理就好了，不需要进行实际的I/O读写操作，因为真正的I/O读取或者写入操作已经由内核完成了。</p>
<p>适用于连接数比较多而且请求消耗比较重的业务场景，比如涉及I/O操作的相册服务器。这种方式相比另外两种，编程难度最大，程序也不易于理解。</p>
</li>
</ul>
<p>上面两个问题就是“<em><strong>通信框架</strong></em>”要解决的问题，常用开源通信框架有Netty、MINA等</p>
<h3 id="1-3-3-数据传输采用什么协议？"><a href="#1-3-3-数据传输采用什么协议？" class="headerlink" title="1.3.3 数据传输采用什么协议？"></a>1.3.3 数据传输采用什么协议？</h3><ul>
<li>开放协议：如最常用的Http</li>
<li>私有协议：如Dubbo</li>
</ul>
<p>协议的作用就是“约定”。消费者按照约定对数据进行加密传输，提供者按照约定解码数据并进行处理，最后再加密发给消费者。</p>
<h3 id="1-3-4-数据该如何序列化和反序列化？"><a href="#1-3-4-数据该如何序列化和反序列化？" class="headerlink" title="1.3.4 数据该如何序列化和反序列化？"></a>1.3.4 数据该如何序列化和反序列化？</h3><p>常用的序列化方式分为两类：文本类如<code>XML/JSON</code>等，二进制类如<code>PB/Thrift</code>等，而具体采用哪种序列化方式，主要取决于三个方面的因素。</p>
<h2 id="1-4-服务监控"><a href="#1-4-服务监控" class="headerlink" title="1.4 服务监控"></a>1.4 服务监控</h2><p>服务监控的三个关键点：</p>
<h3 id="1-4-1-监控对象"><a href="#1-4-1-监控对象" class="headerlink" title="1.4.1 监控对象"></a>1.4.1 监控对象</h3><ul>
<li>用户端监控</li>
<li>接口监控</li>
<li>资源监控</li>
<li>基础监控</li>
</ul>
<h3 id="1-4-2-监控指标"><a href="#1-4-2-监控指标" class="headerlink" title="1.4.2 监控指标"></a>1.4.2 监控指标</h3><ul>
<li>请求量</li>
<li>响应时间</li>
<li>错误率</li>
</ul>
<h3 id="1-4-3-监控系统原理"><a href="#1-4-3-监控系统原理" class="headerlink" title="1.4.3 监控系统原理"></a>1.4.3 监控系统原理</h3><p>监控系统主要包括四个环节：数据采集、数据传输、数据处理和数据展示</p>
<h4 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a><strong>数据采集</strong></h4><p>通常有两种数据采集方式：</p>
<ul>
<li>服务主动上报</li>
<li>代理收集</li>
</ul>
<h4 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a><strong>数据传输</strong></h4><ul>
<li>UDP传输</li>
<li>Kafka传输</li>
</ul>
<h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a><strong>数据处理</strong></h4><ul>
<li>接口维度聚合</li>
<li>机器维度聚合</li>
</ul>
<p><strong>数据展示</strong></p>
<p>如常见的曲线图、饼状图等等，以Dashboard方式展示给用户</p>
<p>补充：</p>
<p><strong>①监控架构</strong></p>
<blockquote>
<p>下面的图是大部分公司的一种监控架构图。每一个服务都有一个 Agent，Agent 收集到关键信息，会传到一些 MQ 中，为了解耦。</p>
<p>同时将日志传入 ELK，将 Metrics 传入 InfluxDB 时间序列库。而像 Nagios，可以定期向 Agent 发起信息检查微服务。</p>
<p><img src="https://pic4.zhimg.com/v2-2b4b839b0246785af5e3f47872a81987_b.jpg"></p>
</blockquote>
<h2 id="1-5-服务追踪"><a href="#1-5-服务追踪" class="headerlink" title="1.5 服务追踪"></a>1.5 服务追踪</h2><p>服务追踪可以跟踪记录用户的一次请求都发起了哪些调用，经过哪些服务处理，并记录每一次调用所涉及的服务的详细信息。在出现调用失败的时候，就可以第一时间定位到问题出现的地方。</p>
<p><img src="/../images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB/image_jNdoYfL_Si.png"></p>
<h3 id="1-5-1-服务追踪系统原理"><a href="#1-5-1-服务追踪系统原理" class="headerlink" title="1.5.1 服务追踪系统原理"></a>1.5.1 服务追踪系统原理</h3><p>服务追踪系统的鼻祖：Google发布的一篇的论文<a href="http://bigbully.github.io/Dapper-translation/" title="Dapper, a Large-Scale Distributed Systems Tracing Infrastructure">Dapper, a Large-Scale Distributed Systems Tracing Infrastructure</a>，里面详细讲解了服务追踪系统的实现原理。它的核心理念就是<strong>调用链</strong>：通过一个全局唯一的ID将分布在各个服务节点上的同一次请求串联起来，从而还原原有的调用关系，可以追踪系统问题、分析调用数据并统计各种系统指标。</p>
<p>可以说后面的诞生各种服务追踪系统都是基于Dapper衍生出来的，比较有名的有Twitter的<a href="http://zipkin.io/" title="Zipkin">Zipkin</a>、阿里的<a href="http://www.slideshare.net/terryice/eagleeye-with-taobaojavaone" title="鹰眼">鹰眼</a>、美团的<a href="http://tech.meituan.com/mt_mtrace.html" title="MTrace">MTrace</a>等。</p>
<p>基本概念：<code>traceId</code>、<code>spanId</code>、<code>annonation</code></p>
<ul>
<li><code>traceId</code>，用于标识某一次具体的请求ID。当用户的请求进入系统后，会在RPC调用网络的第一层生成一个全局唯一的traceId，并且会随着每一层的RPC调用，不断往后传递，这样的话通过traceId就可以把一次用户请求在系统中调用的路径串联起来。</li>
<li><code>spanId</code>，用于标识一次RPC调用在分布式请求中的位置。当用户的请求进入系统后，处在RPC调用网络的第一层A时spanId初始值是0，进入下一层RPC调用B的时候spanId是0.1，继续进入下一层RPC调用C时spanId是0.1.1，而与B处在同一层的RPC调用E的spanId是0.2，这样的话通过spanId就可以定位某一次RPC请求在系统调用中所处的位置，以及它的上下游依赖分别是谁。</li>
<li><code>annotation</code>，用于业务自定义埋点数据，可以是业务感兴趣的想上传到后端的数据，比如一次请求的用户UID。</li>
</ul>
<p><img src="/../images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB/image_CSQOKCBHqX.png"></p>
<h3 id="1-5-2-服务追踪系统实现"><a href="#1-5-2-服务追踪系统实现" class="headerlink" title="1.5.2 服务追踪系统实现"></a>1.5.2 服务追踪系统实现</h3><p><img src="/../images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB/image_HPN1q5xycN.png"></p>
<ul>
<li>数据采集层，负责数据埋点并上报。</li>
<li>数据处理层，负责数据的存储与计算。</li>
<li>数据展示层，负责数据的图形化展示。</li>
</ul>
<h4 id="1-5-2-1-数据埋点的流程"><a href="#1-5-2-1-数据埋点的流程" class="headerlink" title="1.5.2.1 数据埋点的流程"></a>1.5.2.1 数据埋点的流程</h4><p><img src="/../images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB/image_eKHdGZHbKl.png"></p>
<p>以红色方框里圈出的A调用B的过程为例，一次RPC请求可以分为四个阶段。</p>
<ul>
<li>CS（Client Send）阶段 : 客户端发起请求，并生成调用的上下文。</li>
<li>SR（Server Recieve）阶段 : 服务端接收请求，并生成上下文。</li>
<li>SS（Server Send）阶段 : 服务端返回请求，这个阶段会将服务端上下文数据上报，下面这张图可以说明上报的数据有：<code>traceId=123456，spanId=0.1，appKey=B，method=B.method，start=103，duration=38</code></li>
<li>CR（Client Recieve）阶段 : 客户端接收返回结果，这个阶段会将客户端上下文数据上报，上报的数据有：<code>traceid=123456，spanId=0.1，appKey=A，method=B.method，start=103，duration=38</code></li>
</ul>
<h2 id="1-6-服务治理"><a href="#1-6-服务治理" class="headerlink" title="1.6 服务治理"></a>1.6 服务治理</h2><p>服务调用出现问题：</p>
<ul>
<li>注册中心宕机；</li>
<li>服务提供者有节点宕机；</li>
<li>服务消费者/提供者与注册中心之间的网络不通；</li>
<li>服务消费者和服务提供者之间的网络不通；</li>
</ul>
<h3 id="1-6-1-节点管理"><a href="#1-6-1-节点管理" class="headerlink" title="1.6.1 节点管理"></a>1.6.1 节点管理</h3><ol>
<li>注册中心主动摘除机制</li>
<li>服务消费者摘除机制</li>
</ol>
<h3 id="1-6-2-负载均衡"><a href="#1-6-2-负载均衡" class="headerlink" title="1.6.2 负载均衡"></a>1.6.2 负载均衡</h3><ul>
<li><strong>随机算法</strong></li>
<li><strong>轮询算法</strong></li>
<li><strong>最少活跃调用算法</strong></li>
<li><strong>一致性Hash算法</strong></li>
</ul>
<h1 id="2-DevOps"><a href="#2-DevOps" class="headerlink" title="2 DevOps"></a>2 DevOps</h1><p>传统业务流程：开发→测试→运维</p>
<p>DevOps：</p>
<ul>
<li>CI（Continuous Integration），持续集成。开发完成代码开发后，能自动地进行代码检查、单元测试、打包部署到测试环境，进行集成测试，跑自动化测试用例。</li>
<li>CD（Continuous Deploy），持续部署/持续交付。代码测试通过后，能自动部署到类生产环境中进行集成测试，测试通过后再进行小流量的灰度验证，验证通过后代码就达到线上发布的要求了，就可以把代码自动部署到线上。</li>
</ul>
<p><img src="/../images/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB/image_kcPQoyjIJ3.png"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
</search>
